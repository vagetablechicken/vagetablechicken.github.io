<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"vagetablechicken.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Grokking the Coding Interview: Patterns for Coding Questions课程原地址 题目目录与答案 Python版——完整题目目录，包含challenge。  题目目录与答案 C++版(附题目OJ的地址)——推荐用OJ测试自己的算法，但是这个repo里基本没有challenge题目。 1. Pattern: Sliding WindowMaximum">
<meta property="og:type" content="article">
<meta property="og:title" content="Grokking Pattern 1">
<meta property="og:url" content="http://vagetablechicken.github.io/2021/05/06/grokking-1/index.html">
<meta property="og:site_name" content="Wei">
<meta property="og:description" content="Grokking the Coding Interview: Patterns for Coding Questions课程原地址 题目目录与答案 Python版——完整题目目录，包含challenge。  题目目录与答案 C++版(附题目OJ的地址)——推荐用OJ测试自己的算法，但是这个repo里基本没有challenge题目。 1. Pattern: Sliding WindowMaximum">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2021-05-06T02:58:13.000Z">
<meta property="article:modified_time" content="2023-07-31T10:56:53.712Z">
<meta property="article:author" content="Huang Wei">
<meta property="article:tag" content="Algo">
<meta property="article:tag" content="LeetCode">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://vagetablechicken.github.io/2021/05/06/grokking-1/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>Grokking Pattern 1 | Wei</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Wei" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Wei</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://vagetablechicken.github.io/2021/05/06/grokking-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Huang Wei">
      <meta itemprop="description" content="Hey">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wei">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Grokking Pattern 1
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-05-06 10:58:13" itemprop="dateCreated datePublished" datetime="2021-05-06T10:58:13+08:00">2021-05-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-07-31 18:56:53" itemprop="dateModified" datetime="2023-07-31T18:56:53+08:00">2023-07-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Algo/" itemprop="url" rel="index"><span itemprop="name">Algo</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="Grokking-the-Coding-Interview-Patterns-for-Coding-Questions"><a href="#Grokking-the-Coding-Interview-Patterns-for-Coding-Questions" class="headerlink" title="Grokking the Coding Interview: Patterns for Coding Questions"></a>Grokking the Coding Interview: Patterns for Coding Questions</h1><p><a target="_blank" rel="noopener" href="https://www.educative.io/courses/grokking-the-coding-interview?aff=K7qB">课程原地址</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/cl2333/Grokking-the-Coding-Interview-Patterns-for-Coding-Questions">题目目录与答案 Python版</a>——完整题目目录，包含challenge。 </p>
<p><a target="_blank" rel="noopener" href="https://github.com/Huixxi/Algorithm-with-Cplusplus/tree/master/%E8%8E%B1%E7%89%B9%E6%89%A3%E7%9A%84-%E7%B3%BB%E5%88%97">题目目录与答案 C++版(附题目OJ的地址)</a>——推荐用OJ测试自己的算法，但是这个repo里基本没有challenge题目。</p>
<h2 id="1-Pattern-Sliding-Window"><a href="#1-Pattern-Sliding-Window" class="headerlink" title="1. Pattern: Sliding Window"></a>1. Pattern: Sliding Window</h2><h3 id="Maximum-Sum-Subarray-of-Size-K-easy-–-GeeksforGeeks"><a href="#Maximum-Sum-Subarray-of-Size-K-easy-–-GeeksforGeeks" class="headerlink" title="Maximum Sum Subarray of Size K (easy) – GeeksforGeeks"></a><a target="_blank" rel="noopener" href="https://www.geeksforgeeks.org/find-maximum-minimum-sum-subarray-size-k/">Maximum Sum Subarray of Size K (easy) – GeeksforGeeks</a></h3><p>k长的<strong>连续子序列</strong>，使该子序列和最大，这个和为output。<br>窗口长度都固定了，只需在遍历一遍时加后一个减前一个就行了，O(n)。</p>
<h3 id="Smallest-Subarray-with-a-given-sum-medium-–-LeetCode"><a href="#Smallest-Subarray-with-a-given-sum-medium-–-LeetCode" class="headerlink" title="Smallest Subarray with a given sum (medium) – LeetCode"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/minimum-size-subarray-sum/">Smallest Subarray with a given sum (medium) – LeetCode</a></h3><p>注意读题，nums都是正整数，target也是正整数。这个条件大概率需要用到。</p>
<p>假设有一段连续子序列了，它已经&gt;=target了，就不需要再继续加入元素了（序列外右边第一个元素），因为再加的话size就变大了。而这个size可以向右横移一格，可以立马算出新的sum（这里很节约时间，降低算法复杂度）。</p>
<p>这个sum如果 &gt;= target，那么它就有机会再小一点，而这一次需要的是减去序列内的第一个元素，可以理解为“收缩窗口”。<br>这个sum如果 &lt; target，那就可以再向右横移了，因为size扩大，对结果没有任何帮助。</p>
<p>总体看下来，只要横移和收缩，算法复杂度是O(n)。</p>
<h4 id="初步思路"><a href="#初步思路" class="headerlink" title="初步思路"></a>初步思路</h4><p>初步思路是，先算个nums[0…x]之和 &gt;= target的窗口，然后这个窗口开始向右移并尝试收缩。但其实不对，因为第一个窗口，不是非得从第0个元素开始，这个窗口自身就应该尝试收缩。这个逻辑补上后是能ac的。<br>不过，初步思路翻译为代码，还是有些小坑，肉眼很难查。建议背一个滑动窗口模板。</p>
<h4 id="滑动窗口模板思路"><a href="#滑动窗口模板思路" class="headerlink" title="滑动窗口模板思路"></a>滑动窗口模板思路</h4><p>此思路最核心的思想就是，不强求窗口横移，反正先向右扩展1个，再左边收缩一个，就达到了横移。<br>因此滑动窗口的头尾都可以移动，而且是分别移动，用两个变量来表示，（start，end）。<br>因为收缩（start向右移）和扩展（end向右移）可以各做各的，所以没必要先找到一个总和 &gt;= target的初始窗口了。</p>
<p>所以，步骤可以化简为，<strong>每一次都扩展1下，然后尽力收缩</strong>（while不定次收缩）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">while end &lt; n:</span><br><span class="line">    tmp_sum += nums[end]</span><br><span class="line">    while tmp_sum &gt;= target:</span><br><span class="line">        win_size = min(win_size, end-start+1)</span><br><span class="line">        tmp_sum -= nums[start]</span><br><span class="line">        start += 1</span><br><span class="line">    end += 1</span><br></pre></td></tr></table></figure>

<p>至于几个变量的初始值，现场推理一下也可以得到，不做赘述。<br>P.S. win_size没必要用int的max，用len(nums)+1就可以了，反正都是不可能的值。</p>
<h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><p>滑动窗口的算法，nums就算有负数也无所谓。（被烟雾弹迷惑🐶）这个条件大概是为“前缀和”这一方法准备的。</p>
<p>前缀和方法，简单来讲就是nums[0..i]之和组成一个sum数组，这个数组严格递增，都不存在相等的元素。</p>
<p>然后就可以用二分来找了（看到有序就要想到二分），当前sum[i]为0到i元素的和，<code>sum[j] - sum[i] &gt;= target</code>转换为<code>sum[j]&gt;=target+sum[i]</code>，那么就是在sum数组里找<code>target+sum[i]</code>的lower bound。</p>
<p>为什么不是以j为结尾，<code>sum[j] - sum[x] &gt;= target</code>转换成<code>sum[x] &lt;= sum[j]-target</code>，找sum[x]呢？因为是upper bound（第一个&gt;某值的元素）的前一个（必定&lt;=某值），不如直接找lower bound简洁，而且不用处理减出负数的情况。</p>
<h3 id="Longest-Substring-with-K-Distinct-Characters-medium-google-–-LintCode"><a href="#Longest-Substring-with-K-Distinct-Characters-medium-google-–-LintCode" class="headerlink" title="Longest Substring with K Distinct Characters (medium, google) – LintCode"></a><a target="_blank" rel="noopener" href="https://www.lintcode.com/problem/longest-substring-with-at-most-k-distinct-characters/description">Longest Substring with K Distinct Characters (medium, google) – LintCode</a></h3><p>Given a string, find the length of the longest substring in it with no more than K distinct characters.</p>
<p>也就是LeetCode340题 Longest Substring at Most K Distinct Characters。</p>
<p>这道题输出是最长子串的长度，所以显然可以套用滑动窗口的模板。和上一个题目一样，都是扩展会使得条件不符，要通过收缩来满足条件。<br>即，窗口扩展一旦字符种类超过k，就可以通过窗口收缩来削减字符种类。<br>唯一不同的点是：update longest string的时机（其实就是用end-start+1来尝试更新记录的longest）<br>因为while distinct_count(dict) &gt; k时是去收缩，break while时说明distinct_count(dict) 已经&lt;=k了，这个时候的[start, end]才是一个可能解，符合条件的可能解。<br>所以update longest string len是在while循环外，而且是之后。<br>至于如何实现dict和distinct_count，随便吧，简单也好，高效也好。</p>
<p>P.S.注意到了吗，这个题目和前面一题Smallest Subarray的区别？</p>
<p>看不出来也正常，我做了几道题才突然回头发现的😂而且明明之前做过笔记，重蹈覆撤🙄️</p>
<p><del>果然人类的本质都是复读机</del></p>
<p>这个题已经开始了longest之路，也就是说，只是想求一个最长的长度，根本不在意“重复无意义的更新”。</p>
<p>按之前的模板，此题的伪代码应写为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">while end &lt; n:</span><br><span class="line">    dic[s[end]]+=1</span><br><span class="line">    while len(dic)&gt;k:</span><br><span class="line">        dic[s[start]]-=1</span><br><span class="line">        if dic[s[start]]==0:</span><br><span class="line">            del dic[s[start]]</span><br><span class="line">        start+=1</span><br><span class="line">    longest = max(longest, end-start+1)</span><br><span class="line">    end+=1</span><br></pre></td></tr></table></figure>

<p>这样的写法，保证了longest变量更新时，当前窗口都是len(dic)&lt;=k的，也就是合法的情况。但确实可能会出现窗口被收缩的很小的时候（为了合法），此时max更新也是白干的（longest还是原值）。</p>
<p>而如果代码将内层while变为if：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">while end &lt; n:</span><br><span class="line">    dic[s[end]]+=1</span><br><span class="line">    if len(dic)&gt;k:</span><br><span class="line">        dic[s[start]]-=1</span><br><span class="line">        if dic[s[start]]==0:</span><br><span class="line">            del dic[s[start]]</span><br><span class="line">        start+=1</span><br><span class="line">    longest = max(longest, end-start+1)</span><br><span class="line">    end+=1</span><br></pre></td></tr></table></figure>

<p>自然，在longest更新时，当前窗口可能都还满足条件，不合法，但仍旧去做了一次longest的更新。但从数值上来讲，由于不满足条件会被收缩一次，加上前面的end扩展一次，窗口等于做了一次平移。那么end=start+1的值就不会变大，longest的更新自然也是不会有实际作用的。</p>
<p>这一个改动，它到底好在了哪里呢？光看经过，start，end两个游标都是单向前进的，2-while和while-if都不会使两个游标左右飘。但由于2-while会保证每次窗口都是合法的，和while-if相比，start这个游标可能会更靠右。举个极端例子，如果longest是[0, n-2]这个窗口，下一次扩展end就会到末尾n-1，while-if此时发现窗口不合法，收缩一次，就溜了。而2-while，会愣是要求[start, n-1]窗口合法，可能start从0不断右移，直到n-1才停止。无用操作在这个例子就占了一半。具体例子就是AAAAB, k =1。</p>
<p>这个优化并不容易读，我也不建议平时代码搞这么tricky。在这个题目里，仅仅在节省len查询和dict更新，都是较高效的操作，而且有次数上限（由于start标最多都走到末尾，操作次数最多n次）。优化效果仅仅锦上添花。但这个将while改为if，在其他题目中可能有奇效。因为while的判断条件如果复杂度较高，这里的收益就很大了，见Longest Substring with Same Letters after Replacement一题。</p>
<h3 id="Fruits-into-Baskets-medium-–-LeetCode"><a href="#Fruits-into-Baskets-medium-–-LeetCode" class="headerlink" title="Fruits into Baskets (medium) – LeetCode"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/fruit-into-baskets/">Fruits into Baskets (medium) – LeetCode</a></h3><p>跟上题一模一样。题目暗示着连续区间，就可以尝试滑动窗口方法。</p>
<p>但这一题case比上一题的规模大，最简单的dict实现（不及时删除value为0的项，每次都要遍历得到distinct count）这种方法就超时了。还是推荐及时删除value为0的项，其实比不删还简单，因为删除这个操作只会在收缩时出现（只有此处count–）。</p>
<p>可优化为while-if。</p>
<h3 id="No-repeat-Substring-medium-–-LeetCode"><a href="#No-repeat-Substring-medium-–-LeetCode" class="headerlink" title="No-repeat Substring (medium) – LeetCode"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/longest-substring-without-repeating-characters/">No-repeat Substring (medium) – LeetCode</a></h3><p>和前面的题目毫无差别。</p>
<p>但注意第二层while的判断条件是什么，如果判断条件是“窗口dict的value全为1”，那么你可以改出while-if。</p>
<p>如果是“当前字符c的count&gt;1”，就改不了了。因为现在只看当前字符，那就意味着窗口必须是合法的，然后扩展，加入当前字符。while-if便不可用。</p>
<p>“只看当前字符”这种方法的优化思路是，如果start要跳，直接让start去“当前字符上一次出现的位置的右边”。 因为前面的字符都可以跳过了。还可以再化简代码，但会很难读，所以还是适合而止吧。</p>
<h3 id="Longest-Substring-with-Same-Letters-after-Replacement-medium-amazon-–-GeeksforGeeks"><a href="#Longest-Substring-with-Same-Letters-after-Replacement-medium-amazon-–-GeeksforGeeks" class="headerlink" title="Longest Substring with Same Letters after Replacement (medium, amazon) – GeeksforGeeks"></a><a target="_blank" rel="noopener" href="https://practice.geeksforgeeks.org/problems/maximum-sub-string-after-at-most-k-changes/0">Longest Substring with Same Letters after Replacement (medium, amazon) – GeeksforGeeks</a></h3><p>We have a string <strong>s</strong> of length n, which consist only UPPERCASE characters and we have a number k (always less than n and greater than 0). We can make at most k changes in our string such that we can get a sub-string of maximum length which have all same characters.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;ABAB&quot;, k = 2</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: Change 2 &#x27;B&#x27; into &#x27;A&#x27;.</span><br></pre></td></tr></table></figure>

<p><strong>Example:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;ABCD&quot;, k = 1</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: Change one &#x27;B&#x27; into &#x27;A&#x27;.</span><br></pre></td></tr></table></figure>

<p>这种要替换字符的题目，往往不用真的替换，只要数值上达到某个条件就行了。比如这个题，不用想着应该替换哪些字符，而应该想“总字符个数 - 不需要被替换的字符个数 &gt;= k”就行了。很容易想到，“不需要被替换的字符个数”就是区间内个数最多的那个字符，这样，总字符数才能多一点（对某个区间而言，不需要理会那些无意义的可能解，“保留频率最高的字符，把其他的替换为该字符”肯定是操作数最少的）。于是，替不替换的问题就化简为简单的统计问题。</p>
<p>统计问题虽然简单，但是复杂度略高。想要快速，可能需要两个map，ch-&gt;count, count-&gt;ch。所以，while-if就很适合了，由于只收缩一次，max_count就从dict里统计一次就好了，不用强求更快速。</p>
<h3 id="Longest-Subarray-with-Ones-after-Replacement-medium-–-GeeksforGeeks"><a href="#Longest-Subarray-with-Ones-after-Replacement-medium-–-GeeksforGeeks" class="headerlink" title="Longest Subarray with Ones after Replacement (medium) – GeeksforGeeks"></a><a target="_blank" rel="noopener" href="https://www.geeksforgeeks.org/longest-subsegment-1s-formed-changing-k-0s/">Longest Subarray with Ones after Replacement (medium) – GeeksforGeeks</a></h3><p>比上题更简单，只需要一个int变量就能描述一个窗口内的0的个数。</p>
<h3 id="Problem-Challenge-1-Permutation-in-a-String-hard"><a href="#Problem-Challenge-1-Permutation-in-a-String-hard" class="headerlink" title="Problem Challenge 1 - Permutation in a String (hard)"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/permutation-in-string/">Problem Challenge 1 - Permutation in a String (hard)</a></h3><p>排列，不允许多一个字符，所以窗口大小是固定的，滑动用来节省“更新窗口属性的代价”。题目如果对字符多加限制，比如此题限制只有小写字母，也就只有26个可能，其实描述窗口用长26的数组都可以，不用非要用counter。用counter有个麻烦点在于当某个字符的count为0时，你需要删掉它，不然就没法和s1的counter比大小。如果两个字符串的counter都先把26个字母的空间开出来，那还不如数组节省空间。</p>
<h3 id="Problem-Challenge-2-String-Anagrams-hard"><a href="#Problem-Challenge-2-String-Anagrams-hard" class="headerlink" title="Problem Challenge 2 - String Anagrams (hard)"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/submissions/">Problem Challenge 2 - String Anagrams (hard)</a></h3><p>和challenge1没有区别</p>
<h3 id="Problem-Challenge-3-Smallest-Window-containing-Substring-hard"><a href="#Problem-Challenge-3-Smallest-Window-containing-Substring-hard" class="headerlink" title="Problem Challenge 3 - Smallest Window containing Substring (hard) *"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-window-substring/">Problem Challenge 3 - Smallest Window containing Substring (hard) *</a></h3><p>没啥特别，就是用collections.Counter()减法，比自己写的比较函数要慢不少，1200ms vs 500ms。</p>
<h3 id="Problem-Challenge-4-Words-Concatenation-hard"><a href="#Problem-Challenge-4-Words-Concatenation-hard" class="headerlink" title="Problem Challenge 4 - Words Concatenation (hard)"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/substring-with-concatenation-of-all-words/">Problem Challenge 4 - Words Concatenation (hard)</a></h3><p>注意读题！words长度相同！匆忙读题后，我还以为要处理不同的切割方式，以为会出现“一个substring里有几种正确的word排列”。那这题可能不止hard了。</p>
<p>可以简单想到的办法就是窗口从0一直滑到尾，step为1，每一次窗口都得重新计算下word-count，然后和words参数比较。</p>
<p>显然这个没有什么巧妙点，没有节约计算量，所以想要利用滑动窗口，当然得想点骚方法。其实就是，每一次都设置一个起点，从这个起点开始，只会按词长来拓展，这样就能像字符型的题目一样，充分利用滑动窗口的扩展收缩，减少计算。举例说明，就是一个单词长度为len，s串总长为n的话，第一趟是从0开始一个len切一刀，这样切割后的串扩展和收缩都是一个词的，第二趟就是从1开始切，以此类推，最后一次是len-1开始切。可以想到，这样也是把所有可能性都考虑到了。</p>
<p>改进后的滑动窗口方法效果是明显的，1000ms到100ms。</p>
<h3 id="Additional"><a href="#Additional" class="headerlink" title="Additional"></a>Additional</h3><h4 id="Sliding-Window-Maximum-hard-–-LeetCode"><a href="#Sliding-Window-Maximum-hard-–-LeetCode" class="headerlink" title="Sliding Window Maximum (hard) – LeetCode"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/sliding-window-maximum/">Sliding Window Maximum (hard) – LeetCode</a></h4><p>这个题跟滑动窗口模板毫无关系，窗口大小都固定牢了。唯一的问题点在于用什么结构体来提炼窗口信息，既能很快查到最大值，又能在窗口滑动时很快更新好（滑动本质就是加入一个数，去掉一个数）。快速查到最大值，可以想到利用堆。但是堆有一个明显问题，就是它不适合去删除内部的某个元素（不是堆首）。而“去掉一个数”这个操作很可能就是去删除某个中间的值。堆的删除操作是个不太ok的操作，因为这个堆是简单的堆（并非压平了看，完全有序的，不是堆排序之后的结果），也就是删除操作不能快速定位到要删除的元素。</p>
<p>但是别直接放弃堆（我就放弃了，想别的方法，走远了）。这时候，尝试多推导一下，就会发现，不用着急删除元素。因为元素可以跟上自己的位置idx，如果堆顶拿到的idx已经不在窗口内，再删除也不迟。也就是延迟了删除操作，正好还让删除操作符合堆的操作习惯，只删堆顶。</p>
<p>到这里，起码算是题目做出来了，而且这个方法也不差，能交差。</p>
<p>但这道题更想考的点是别的，所以还需要再优化。说是优化，不如说是换了解法。从堆想到单调队列，反正我是做不到。。。</p>
<p>单调队列是什么东西？先记住它能够动态地维护定长序列中的最值。所以只要定长、最值，就可以想到尝试单调队列。具体来讲，单调队列是，push元素前会把前面的元素都从后往前访问一遍（遇到比自己大的停止），比当前元素小的都删除，再将元素放在队尾。其实，全访问也没关系，最后结果没有差别，不过，遇到比自己大的就停止可以节省点时间。最后的结果就是队列里头到尾是从大到小有序的。</p>
<p>举例说明(为了多点情况，和leetcode原例子有差别)：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nums = [1,3,-1,-3,-2,3,6,7], k = 3</span><br></pre></td></tr></table></figure>

<p>单调队列应该长什么样？</p>
<p>[1,3,-1]初始窗口入队列后，q=[3,-1]，那么这个窗口的最值就是3；</p>
<p>[3,-1,-3], q=[3,-1,-3]，最值还是3；</p>
<p>[-1,-3,-2], q=[3,-1,-2]，最值3，但3已经不在窗口内，所以pop，q=[-1,-2]，最值-1；</p>
<p>[-3,-2,3], q=[3]，最值3；</p>
<p>[5,3,6], q=[6]，最值6；</p>
<p>[3,6,7], q=[7]，最值7。</p>
<p>可以看到，只用进行简单比较，就能维持着最值，比堆的时间复杂度低。</p>
<p>单调队列它为什么做到了呢？</p>
<p>可以这么想，首先简单起见，只考虑窗口内元素的单调队列情况，比如3,1,2序列，k=3，很明显1会在2进入时被扔掉，因为2进入了之后，怎么也是2比1晚出窗口，就算可能是最大值，也是2可能，1是完全没有可能竞争最大值的。</p>
<p>再考虑队列前部还有窗口外元素的情况，窗口外的元素还留在队列里（可以称为过期元素），也就是说窗口内的单调队列最大值（也就是队列列首）比过期元素小。但这并不影响窗口元素那部分的选择，无论有没有过期元素，窗口那部分的单调队列都长一个样。所以过期元素可以简单地pop出来扔掉。</p>
<p>总的来说，单调队列就是剔除了“必然不能争最大值”的那部分无用值。单调队列实现上没有什么难度，不再赘述。</p>
<p>P.S. Python实现遇到超时问题，因为我没有用pop，而是选择到一个点，取出切片[:x]，然后又append。具体细节待调查。从耗时来看，很明显这一连串操作应该搞出了deep copy之类的耗时操作。都叫单调队列了，就好好用python collections里的deque。</p>
<h4 id="Shortest-Subarray-with-Sum-at-Least-K-hard-–-LeetCode"><a href="#Shortest-Subarray-with-Sum-at-Least-K-hard-–-LeetCode" class="headerlink" title="Shortest Subarray with Sum at Least K (hard) – LeetCode"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/shortest-subarray-with-sum-at-least-k/">Shortest Subarray with Sum at Least K (hard) – LeetCode</a></h4><p>仔细读题，这个题的数组里有负数。滑动窗口的算法模板是没办法直接套用的，因为窗口收缩的停止条件是sum &lt; k，由于有负数，你不能在窗口sum &lt; k时停止，你必须继续收缩，否则就可能错过解。</p>
<p>停留在滑动窗口算法模板这个框架里，是没办法找到解法的。</p>
<p>这时候<del>只能躺平</del>。</p>
<p>只能说先回答个O(n^2)的解法吧，聊胜于无。很明显，所有区间和都是可能的最佳答案，所以前缀和加<strong>二级遍历</strong>所有区间，能得到答案。</p>
<p>当然可以优化，但是很难凭空想出来参考答案“单调队列”。接下来的说明是以知道“前缀和+单调队列是较好解法”为前提来看这个题目，所以没有什么顺理成章推导，全凭参考答案提示。</p>
<p>单调队列维护什么？</p>
<p>题目核心是求最短的合法子串，所以短是最核心的，和只要&gt;=k什么都行。那么假设当前看i，以i开头的最佳子串，当然是从i开始寻找第一个j，能使sum[i..j]&gt;k（前缀和数组里两个数减一下就好了）。j之后的都不用找了，没有比i到j更短的了。那么反过来思考，从i到j，中间可能有多个值，一一遍历就是暴力解法，优化当然是更快找到j，那么如何迅速定位到j呢？</p>
<p>或者换个说法，i到j中间的多个可能性，有哪些是必然不可能的，可以直接过滤？答案是没得😛。因为如果从[i, n)区间提取出单调递增的部分，可以使用二分，但这个题应该用不着。那这个思路还有什么优势呢？我们一一遍历到j，然后得到这个i的最优解，然后i++，然后你还是得遍历过去，因为单调递增队列本身不能有更多的改动，最多把队列头比i小的pop出来。那换个角度，递增队列是不是能从后往前看，当某个靠后的j满足了条件，你能把它怎么样？你不能动它，因为接下来的i（更大的i）和j一起也能满足条件，这个窗口长度肯定比现在的短，你删了这个j，就丢掉了解。</p>
<p>那么就应该考虑换个顺序，以当前j为标杆，去找前面的i，它有个什么好处呢？当你从前往后找i，某个i满足条件后，你可以大胆删了它，因为j会++，当前的i充分发挥价值（用来更新window len）后，就不需要了，后面的j和这个i组合是无意义的。</p>
<p>P.S. 我想到了以j找i，但又想的是从j-1往0这个方向找，想想看，跟以i找j没什么差别，它们跟暴力解法比，完全不是稳定降低复杂度，甚至可以劣到没区别。（于是Python实现也完美超时了）</p>
<p>总的看“前缀和+单调队列”，大概的最好状态是每次O(1)，然后n个j，所以O(n)，比如，每次看队列头d[0]的preSum都很大，不能让preSum[j]-preSum[d[0]]&gt;=k，单调递增的d后面的元素也不能满足要求了，所以每次就立马完成。最差的状态可能是某次j，从0到j遍历，每次都符合条件，都要pop并更新window len。但很明显，队列最多跟n一样长，而且pop出去了又不会回来，所以次数最多n次，并不会膨胀。所以总的复杂度还是O(n)的。</p>
<p>这道题还是很难的，难在拼出正确的方法，知道方法后，代码实现不难。</p>
<h4 id="Max-Consecutive-Ones-III"><a href="#Max-Consecutive-Ones-III" class="headerlink" title="Max Consecutive Ones III"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/max-consecutive-ones-iii/">Max Consecutive Ones III</a></h4><p>突如其来的一道复习题。while-if即可，虽然和while-while实测没什么区别，大概是case的原因。</p>
<h4 id="Replace-the-Substring-for-Balanced-String-medium-–-LeetCode"><a href="#Replace-the-Substring-for-Balanced-String-medium-–-LeetCode" class="headerlink" title="Replace the Substring for Balanced String (medium) – LeetCode"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/replace-the-substring-for-balanced-string/">Replace the Substring for Balanced String (medium) – LeetCode</a></h4><p>题目是说要替换的字符包含在一个子串里，要求子串最短，子串符合某个条件即可，那就很适合套用滑动窗口模板了。</p>
<h4 id="Count-Number-of-Nice-Subarrays-medium-–-LeetCode"><a href="#Count-Number-of-Nice-Subarrays-medium-–-LeetCode" class="headerlink" title="Count Number of Nice Subarrays (medium) – LeetCode"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/count-number-of-nice-subarrays/">Count Number of Nice Subarrays (medium) – LeetCode</a></h4><p>这题一看就不适合立马套用模板，扩展和收缩求最长最短很有效，但这里没有用处。举例说明，当我们找到一个窗口恰好有k个奇数，此时可以滑动窗口么？当然不能。所以放弃吧。然后考虑到奇数是核心，先找到k个奇数的最小可能，它的左右两边如果分别有a个偶数和b个偶数，那么这里就有很多个子串可能，1+a+b+a*b。而找奇数，可以直接抽出奇数，这样奇数数组里每k个就是一个base，延展下两边的偶数。既没有重复也不会漏算。</p>
<p>滑动窗口完结撒花🎉</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Algo/" rel="tag"># Algo</a>
              <a href="/tags/LeetCode/" rel="tag"># LeetCode</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/05/06/grokking-4/" rel="prev" title="Grokking Pattern 4">
      <i class="fa fa-chevron-left"></i> Grokking Pattern 4
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/05/06/grokking-6/" rel="next" title="Grokking Pattern 6">
      Grokking Pattern 6 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Grokking-the-Coding-Interview-Patterns-for-Coding-Questions"><span class="nav-number">1.</span> <span class="nav-text">Grokking the Coding Interview: Patterns for Coding Questions</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-Pattern-Sliding-Window"><span class="nav-number">1.1.</span> <span class="nav-text">1. Pattern: Sliding Window</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Maximum-Sum-Subarray-of-Size-K-easy-%E2%80%93-GeeksforGeeks"><span class="nav-number">1.1.1.</span> <span class="nav-text">Maximum Sum Subarray of Size K (easy) – GeeksforGeeks</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Smallest-Subarray-with-a-given-sum-medium-%E2%80%93-LeetCode"><span class="nav-number">1.1.2.</span> <span class="nav-text">Smallest Subarray with a given sum (medium) – LeetCode</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9D%E6%AD%A5%E6%80%9D%E8%B7%AF"><span class="nav-number">1.1.2.1.</span> <span class="nav-text">初步思路</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%A8%A1%E6%9D%BF%E6%80%9D%E8%B7%AF"><span class="nav-number">1.1.2.2.</span> <span class="nav-text">滑动窗口模板思路</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A1%A5%E5%85%85"><span class="nav-number">1.1.2.3.</span> <span class="nav-text">补充</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Longest-Substring-with-K-Distinct-Characters-medium-google-%E2%80%93-LintCode"><span class="nav-number">1.1.3.</span> <span class="nav-text">Longest Substring with K Distinct Characters (medium, google) – LintCode</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Fruits-into-Baskets-medium-%E2%80%93-LeetCode"><span class="nav-number">1.1.4.</span> <span class="nav-text">Fruits into Baskets (medium) – LeetCode</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#No-repeat-Substring-medium-%E2%80%93-LeetCode"><span class="nav-number">1.1.5.</span> <span class="nav-text">No-repeat Substring (medium) – LeetCode</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Longest-Substring-with-Same-Letters-after-Replacement-medium-amazon-%E2%80%93-GeeksforGeeks"><span class="nav-number">1.1.6.</span> <span class="nav-text">Longest Substring with Same Letters after Replacement (medium, amazon) – GeeksforGeeks</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Longest-Subarray-with-Ones-after-Replacement-medium-%E2%80%93-GeeksforGeeks"><span class="nav-number">1.1.7.</span> <span class="nav-text">Longest Subarray with Ones after Replacement (medium) – GeeksforGeeks</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Problem-Challenge-1-Permutation-in-a-String-hard"><span class="nav-number">1.1.8.</span> <span class="nav-text">Problem Challenge 1 - Permutation in a String (hard)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Problem-Challenge-2-String-Anagrams-hard"><span class="nav-number">1.1.9.</span> <span class="nav-text">Problem Challenge 2 - String Anagrams (hard)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Problem-Challenge-3-Smallest-Window-containing-Substring-hard"><span class="nav-number">1.1.10.</span> <span class="nav-text">Problem Challenge 3 - Smallest Window containing Substring (hard) *</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Problem-Challenge-4-Words-Concatenation-hard"><span class="nav-number">1.1.11.</span> <span class="nav-text">Problem Challenge 4 - Words Concatenation (hard)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Additional"><span class="nav-number">1.1.12.</span> <span class="nav-text">Additional</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Sliding-Window-Maximum-hard-%E2%80%93-LeetCode"><span class="nav-number">1.1.12.1.</span> <span class="nav-text">Sliding Window Maximum (hard) – LeetCode</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Shortest-Subarray-with-Sum-at-Least-K-hard-%E2%80%93-LeetCode"><span class="nav-number">1.1.12.2.</span> <span class="nav-text">Shortest Subarray with Sum at Least K (hard) – LeetCode</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Max-Consecutive-Ones-III"><span class="nav-number">1.1.12.3.</span> <span class="nav-text">Max Consecutive Ones III</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Replace-the-Substring-for-Balanced-String-medium-%E2%80%93-LeetCode"><span class="nav-number">1.1.12.4.</span> <span class="nav-text">Replace the Substring for Balanced String (medium) – LeetCode</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Count-Number-of-Nice-Subarrays-medium-%E2%80%93-LeetCode"><span class="nav-number">1.1.12.5.</span> <span class="nav-text">Count Number of Nice Subarrays (medium) – LeetCode</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Huang Wei</p>
  <div class="site-description" itemprop="description">Hey</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">15</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Huang Wei</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
