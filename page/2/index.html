<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"vagetablechicken.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Coding, Struggling, and Living.">
<meta property="og:type" content="website">
<meta property="og:title" content="Wei">
<meta property="og:url" content="http://vagetablechicken.github.io/page/2/index.html">
<meta property="og:site_name" content="Wei">
<meta property="og:description" content="Coding, Struggling, and Living.">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Huang Wei">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://vagetablechicken.github.io/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Wei</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Wei" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Wei</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://vagetablechicken.github.io/2021/05/06/grokking-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Huang Wei">
      <meta itemprop="description" content="Coding, Struggling, and Living.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wei">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/06/grokking-3/" class="post-title-link" itemprop="url">Grokking Pattern 3</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-05-06 10:58:13" itemprop="dateCreated datePublished" datetime="2021-05-06T10:58:13+08:00">2021-05-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-07-31 18:56:53" itemprop="dateModified" datetime="2023-07-31T18:56:53+08:00">2023-07-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Algo/" itemprop="url" rel="index"><span itemprop="name">Algo</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Grokking-the-Coding-Interview-Patterns-for-Coding-Questions"><a href="#Grokking-the-Coding-Interview-Patterns-for-Coding-Questions" class="headerlink" title="Grokking the Coding Interview: Patterns for Coding Questions"></a>Grokking the Coding Interview: Patterns for Coding Questions</h1><p>See <a href="/2021/05/06/grokking-1/" title="Grokking Pattern 1">Grokking Pattern 1</a>.</p>
<h2 id="3-Pattern-Fast-amp-Slow-pointers"><a href="#3-Pattern-Fast-amp-Slow-pointers" class="headerlink" title="3. Pattern: Fast &amp; Slow pointers"></a>3. Pattern: Fast &amp; Slow pointers</h2><h3 id="LinkedList-Cycle-easy"><a href="#LinkedList-Cycle-easy" class="headerlink" title="LinkedList Cycle (easy)"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/linked-list-cycle/">LinkedList Cycle (easy)</a></h3><p>题目描述很反人类，但其实就是给你一个链表（只有head指针），让你判断是否有环。进阶是只使用O(1)的空间，也就是常量空间。</p>
<p>有环的链表肯定会访问到重复的节点，环内有1个或以上的节点。搞一个空间存已经访问过的节点，查到之前访问过就能判断了，但空间最坏能到O(n)。常量空间，自然要用快慢指针。</p>
<p>推理一下，快慢指针什么时候能证明链表有环？</p>
<p>猜想肯定是快慢指针指向同一个节点时，但怀疑是否存在“有环链表下快慢指针也不会同时指向同一个节点”。画画图，列一下方程式，假设链表入环前有s个节点，环上有c个节点，可以知道，当走整数倍c（2倍起，同时还得&gt;s）的时候快慢指针是能遇到的，这个值不会不存在，还会多次相遇。所以不用担心快慢节点会永远遇不到。</p>
<p>编码上很简单了，记住init时fast，slow都指向head，然后while内先走再check。</p>
<h3 id="Middle-of-the-LinkedList-easy"><a href="#Middle-of-the-LinkedList-easy" class="headerlink" title="Middle of the LinkedList (easy)"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/middle-of-the-linked-list/">Middle of the LinkedList (easy)</a></h3><p>很简单的题，把两个case都手动推理一遍，就知道了。hint：fast先走，提前退出，slow就不用走了。</p>
<h3 id="Start-of-LinkedList-Cycle-medium"><a href="#Start-of-LinkedList-Cycle-medium" class="headerlink" title="Start of LinkedList Cycle (medium)"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">Start of LinkedList Cycle (medium)</a></h3><p>这个题猜得到是需要快慢指针相遇后再加点什么操作的，但是推理容易卡壳。主要还是对快慢指针相遇的情况理解的不够。</p>
<p>快慢指针相遇很好写，node地址相等就是了。但相遇时，快慢指针并不是可能走了无数圈。这里有一个点必须记住，就是“慢指针入环后，和快指针相遇时，慢指针在环上是不会走超过一圈的”。也就是慢指针入环后继续走，一圈以内必定碰到快指针。</p>
<p>这个知识点，我以前应该用方程式推过，也不记得推理有没有漏洞了，这次做题还没推出来。所以这里最直观也正确的解法是数学归纳法。我们讲slow入环后和fast相遇，那么最快相的情况，当然是slow和fast直接在入环点直接相遇，0步。再麻烦点，就是fast在slow的前面（此刻的位置是fast.next==slow），这样两个相邻的节点，只需1步就能相遇。假设fast更远一点，即fast.next.next==slow，就需要2步，以此类推，入环时刻，fast和slow的距离（fast的n个next==slow）假设为n，就需要n步相遇。但fast和slow之间最大距离就是fast在slow的前一个，假设环里有k个节点，fast和slow的最大距离就是k-1，所以最多k-1步，fast和slow必定相遇。所以slow不可能在相遇前走几圈。</p>
<p>知道slow在一圈内就会和fast相遇，其中几个关键长度如下图所示。那么相遇时slow的公式应该写为，slow=a+b，fast=a+b+n(b+c)。</p>
<p><img src="https://assets.leetcode-cn.com/solution-static/142/142_fig1.png" alt="示意图"></p>
<p>(leetcode图源，可能会挂，自行戳网址)</p>
<p>再回到题目本身，当两指针在紫色点上相遇时，代入化简一下已有式子，得a+b=n(b+c)，即a=c+(n-1)(b+c)，为什么化简成这样？不是因为这样a可以通过等式右边得到，右边这式子也没法继续求。而是因为，右边写成这样，b+c是一整圈，也就是说，如果一个指针从链表头开始走起，另一个指针从紫色点走了c长度又走了几个完整圈，它们会在入环口相遇，另一个指针走几圈完全不用在意。</p>
<p>但注意，这个式子可能有坑，思考下有没有可能a很小，c很大？</p>
<p>n必然&gt;=1，因为fast肯定走的多点，不然fast=a+b+n(b+c)就不对了。那么，a最小就等于c，不可能比c小。这个事情挺有趣的。没有想到一个很通俗易懂的表达，但数学证明了也就证明了吧。</p>
<h3 id="Happy-Number-medium"><a href="#Happy-Number-medium" class="headerlink" title="Happy Number (medium)"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/happy-number/">Happy Number (medium)</a></h3><p>这题现在是简单😂</p>
<p>题目没有读仔细，所以第一时间没能察觉到和快慢指针有什么联系。题目表述为“也可能是 <strong>无限循环</strong> 但始终变不到 1”，我简单地想到了不能一直计算，但忘记了无限循环不是每一次结果都不一样，它只是每次结果都是不是1，不是说每次结果都是从未出现的数字。</p>
<p>接着，就排除了用定义一直计算这种思路，变成了想利用数学之类的其他方法来解决。虽然也推理出了平方和计算中，不能爆出非常大的值，最大32bit的数，十进制也就是13位，就算13位都是9，一次平方和计算下来，也不过1053。而1053的平方和也挺小的，1053以内能算出较大平方和的也就是999。而999再算一步也就是243。</p>
<p>可以明显感觉到，不可能出现一个小的数字经过多次计算膨胀的很大，只可能很大的初始数一下子变得很小。当然像case1中19经过计算会变大，但这都是一定范围，最大不可能超过1053。</p>
<p>然而，从这里开始，我就期待用动态规划一类的方式，类似斐波那契数列，提前算好所有快乐数。所以我认为，可以从1，10，100，1000反推平方和等于它们的数，但是反推的链路有点长，说不定反推也会不能停止，毕竟这个思路不太对劲，可能有不少漏洞。</p>
<p>总结还是应该利用平方和结果范围有限这一点，也就是抽象成链表的有环判定。当然，因为平方和都是即时算的，不像链表问题提前准备好链表。简单的方案就是直接保存之前计算出的结果，也就是不用快慢指针，而是用是否已存在来判断。而如果还是想用快慢指针，可以def一个next函数，考虑到节约空间，next函数只管计算不用缓存。快指针两次next，慢指针一次next就好了。</p>
<p>纯数学的角度其实也可以继续推下去。但需要更仔细的范围研究。所以，回顾之前的推理，最大的数字13个9，也会瞬间收缩到1053，再归纳总结，12个9收缩到。。。4个9收缩到324，这里特别的来了，999到243。为什么说999到243特别，因为这里位数不降了，之前的那些大数都会收缩位数，变得更小，999虽然会经过一次计算变小，但位数不会收。所以一旦计算结果收缩到3位数，接下来的所有平方和结果都是三位数以内，不可能膨胀，且跌入三位数后（三位数后再计算一次），必然困在243以下。而为什么就243了，有没有可能实际数字更小？简单举例99就知道，它能变大到162，也就是涨到三位数，但不可能从三位数继续变大。所以，计算进入243以内后，可能会振荡，比如2位数蹦到3位数，但不可能比243更大，也就是出不去了。</p>
<p>那么，假设计算结果小于等于243时，我们能直接给出结论，是不是快乐数。就不用进入无限的循环了。所以问题变成243以内的数字，哪些是快乐数？</p>
<p>而这样的问题缩减，有什么好处呢？好处在于，243个数字，最大值也就是243，大可以暴力算加是否已存在判定，最大空间复杂度也就到243，比起给一个数就缓存，空间占用要小一些。（其实应该也小不了多少，毕竟收缩很快）但把&lt;=243的数字直接打成表，对于频繁查快乐数的情况，就会节约时间的多。oj时间上节省的会比较明显。如果只是一次快乐数判定，当然打表反而还浪费时间。</p>
<h3 id="Problem-Challenge-1-Palindrome-LinkedList-medium"><a href="#Problem-Challenge-1-Palindrome-LinkedList-medium" class="headerlink" title="Problem Challenge 1 - Palindrome LinkedList (medium)"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/palindrome-linked-list/">Problem Challenge 1 - Palindrome LinkedList (medium)</a></h3><p>难度简单。</p>
<p>很明显快慢指针能够找到链表的中部。而中部开始向左向右比对，就能判定是否回文。右半边很顺畅，不用改动，关键在于左半部分。但左半部分再快慢指针途中是被遍历访问过的。这其实也就提示了，如果修改链表，就能降低空间复杂度。题目进阶就是希望用O(1)空间，那大概率就是原地修改链表的左半部分。</p>
<p>很直接的就能想到是反向指。写写画画，不难得到简单的代码。得到了链表中部的指针后，当然是往两边走，逐个对比。但注意，奇数回文串和偶数回文串比较的起点是不一样的。我粗心的只想到了偶数回文，跑测试才发现奇数回文跑不过。</p>
<p>P.S.</p>
<p>这个题还有个递归解法，我不太擅长递归，经常起手就是迭代，所以这里值得再学习下。首先，递归能给我们什么？假设我们只是简单的print val，那么递归就能从尾到头，逆序读出每个节点的值。假设我们递归到底了，现在能读到尾部节点，这个时候我们应该拿头部节点和它进行比较，接着递归会读倒数第二个，而这时又应该拿顺数第二个节点比较。可以看到，从头部开始读也可以用一个指针来解决，但这个指针得是外部的变量，放在递归函数里面太困难了。再思考奇偶情况，奇数节点两指针地址会指向同一个节点，容易判断，偶数情况本来以为会麻烦点，但还好，因为两个指针指向的节点是相邻的，所以只要next判断一下就好了。leetcode官方解更飘逸，全遍历，不用提前返回，那对栈空间要求更高了。不大实用，但可以多熟悉下递归。论简单，还是递归这个写法代码少。</p>
<h3 id="Problem-Challenge-2-Rearrange-a-LinkedList-medium"><a href="#Problem-Challenge-2-Rearrange-a-LinkedList-medium" class="headerlink" title="Problem Challenge 2 - Rearrange a LinkedList (medium)"></a>Problem Challenge 2 - Rearrange a LinkedList (medium)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Given the head of a Singly LinkedList, write a method to modify the LinkedList such that the nodes from the second half of the LinkedList are inserted alternately to the nodes from the first half in reverse order. So if the LinkedList has nodes 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6 -&gt; null, your method should return 1 -&gt; 6 -&gt; 2 -&gt; 5 -&gt; 3 -&gt; 4 -&gt; null.</span><br><span class="line"></span><br><span class="line">Your algorithm should not use any extra space and the input LinkedList should be modified in-place.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: 2 -&gt; 4 -&gt; 6 -&gt; 8 -&gt; 10 -&gt; 12 -&gt; null</span><br><span class="line">Output: 2 -&gt; 12 -&gt; 4 -&gt; 10 -&gt; 6 -&gt; 8 -&gt; null</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: 2 -&gt; 4 -&gt; 6 -&gt; 8 -&gt; 10 -&gt; null</span><br><span class="line">Output: 2 -&gt; 10 -&gt; 4 -&gt; 8 -&gt; 6 -&gt; null</span><br></pre></td></tr></table></figure>

<p>跟challenge1类似，尝试了一下递归的写法，比较容易写，就是先把偶数链表搞定，再补一下奇数情况的判断就行了。但是注意，debug时别打印链表，修改中途的临时链表很可能是有环的，打印也打不出来。当然可以限制下打印的node个数，调试时还是可以有的。</p>
<p>如果不用递归写法，这个题还是和challenge1一样，可以把后半部分链表原地反转。不多赘述。</p>
<h3 id="Problem-Challenge-3-Cycle-in-a-Circular-Array-hard"><a href="#Problem-Challenge-3-Cycle-in-a-Circular-Array-hard" class="headerlink" title="Problem Challenge 3 - Cycle in a Circular Array (hard)"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/circular-array-loop/">Problem Challenge 3 - Cycle in a Circular Array (hard)</a></h3><p>题目有点难读，但解析下来，题目的意思是，首先有个环有n个节点，节点里的值表示下一步会向前or向后跳几个节点，可以理解为<strong>在做链表的next链接</strong>。这样下来很可能会出现环状的链表，而且题目定义的链表更狭窄点，k=1（一个节点自环）的不算，不算一会儿前进一会儿后退的。</p>
<p>根据“链表next”和“判断是否循环”，就知道可以用快慢指针。但快慢指针会测到自环，所以即使判断有环，还得再一次确认是否是k=1自环的情况。</p>
<p>而“不算一会儿前进一会儿后退”这一点很重要，题目的说法是循环的下标序列不是全正就是全负。那么指针跑的时候去要看自己现在所处的位置i，这个位置指定的步数，也就是nums[i]如果和之前的nums[…]符号不同，就可以直接判断为False。</p>
<p>那么，还剩两个问题。</p>
<ol>
<li>快慢指针没有null作为退出条件了，不知道能不能结束。这里可以考虑防御性编程，加个一定限制。但其实不需要，原因是，如果一个nums值全为正，选一个元素来看，它必然得指向某个元素，这个元素如果是它自己，就会发现一个自环；如果不是，它势必要指向一个新元素（我们还未访问的）。但访问得一直继续，如果每次都不是循环（快慢指针查不到的），不会停止，一直访问下去，那么元素迟早被访问完，那下一步会去哪儿呢？所以必然会有快慢指针能够查到的环，虽然自环不能算本题定义的“循环”。<ol>
<li>总结一下，就是，除了不是全正or全负会提前退出，快慢指针是必然会相遇的。自信点，不用防御编程。</li>
</ol>
</li>
<li>此题不是简单的从数组头开始。拿个示例画一下，也能发现，从某个下标开始跑快慢指针，结果都是不一样的。所以理论上，每个数组元素都是可能的循环的开始。</li>
</ol>
<p>总结到这里，突然想到一个问题，既然只有全正全负会陷入while loop不能提前退出，而全正全负又一定能有广义的环。那么完全不用快慢指针，只需要把每个点当作可能的入环口，也就是从这个点开始我能转回这个点，就找到了一个广义环。并不是非得快慢指针。只是这里有个坑，那就是这个点只是可能的入环口，它也有可能是类似有环链表的直线部分，走了几步才入环。所以得有个限制退出while步进，不然会死循环出不去。又由前面整理的结果，想要全正or全负没有环是不可能的，最大的环也就到整个数组的长度（当然，可能链表箭头走的很骚，不是说只能沿着数组+1/-1步这么走，但长度是不能再长了）。</p>
<p>这个思路比快慢指针代码上简单点，时间复杂度上却不是变少，因为这个思路走满环，最坏时能达到数组长度，O(n)，快慢指针中fast指针和slow指针第一次相遇时slow也没有走满环，fast多一倍步数，也没差多少。所以这个思路也不会带来质变，聊胜于无。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://vagetablechicken.github.io/2021/05/06/grokking-4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Huang Wei">
      <meta itemprop="description" content="Coding, Struggling, and Living.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wei">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/06/grokking-4/" class="post-title-link" itemprop="url">Grokking Pattern 4</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-05-06 10:58:13" itemprop="dateCreated datePublished" datetime="2021-05-06T10:58:13+08:00">2021-05-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-07-31 18:56:53" itemprop="dateModified" datetime="2023-07-31T18:56:53+08:00">2023-07-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Algo/" itemprop="url" rel="index"><span itemprop="name">Algo</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Grokking-the-Coding-Interview-Patterns-for-Coding-Questions"><a href="#Grokking-the-Coding-Interview-Patterns-for-Coding-Questions" class="headerlink" title="Grokking the Coding Interview: Patterns for Coding Questions"></a>Grokking the Coding Interview: Patterns for Coding Questions</h1><p>See <a href="/2021/05/06/grokking-1/" title="Grokking Pattern 1">Grokking Pattern 1</a>.</p>
<h2 id="4-Pattern-Merge-Intervals"><a href="#4-Pattern-Merge-Intervals" class="headerlink" title="4. Pattern: Merge Intervals"></a>4. Pattern: Merge Intervals</h2><h3 id="Merge-Intervals-medium"><a href="#Merge-Intervals-medium" class="headerlink" title="Merge Intervals (medium)"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/merge-intervals/">Merge Intervals (medium)</a></h3><p>挺简单的题，尤其是我对这种merge interval的题有一个印象，就是“反着比正着简单”。所以很容易就想到了，这题应该反向来看intervals，所以遍历顺序是end大的到end小的，合并interval或者即时push interval到result里，都很简单，不用多注意什么。</p>
<h3 id="Insert-Interval-medium"><a href="#Insert-Interval-medium" class="headerlink" title="Insert Interval (medium) *"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/insert-interval/">Insert Interval (medium) *</a></h3><p>这个题目纯粹是恶心人，没啥别的作用了。由于每个interval都有两个数表示，又得两个interval之间比较，绕的很晕。</p>
<p>大概逻辑很好想，由于加入new interval（后面简称new），可能new和intervals内的多个interval（后面简称i）有重叠，所以可能会消除多个i，为了代码简洁，肯定是新建一个list，符合条件的才插入，这个逻辑比较好。</p>
<p>又回到new和多个i的合并上，重叠就需要合并，合并后的new’可能还是不应该插入，毕竟可能多个i都需要跟new合并，所以需要一个tmp interval。很容易发现，直接用new来做这个tmp interval正好。</p>
<p>本来思路到这儿还是很清晰的，但是由于对“重叠”的定义没先弄清楚，所以写出了漏洞百出的算法。这一点需要吸取教训。算法如果一开始用数学很难表示，就应该先用形容，能把算法定义清晰了，再翻译为数学。不要总想一步到位。</p>
<p>而“重叠”定义，最简单的办法就是画图，画两个interval的相对位置关系，可以看到，分四种情况，a的右边跟b重叠，a的左边跟b重叠，a完全在b内，a完全包容b。当然数学上，由于与或非关系，可以把前三个写为一个判断式，但第四个无法合并，很容易忘记这一种情况，要细心。</p>
<p>当然，可以反向来看，那就是“不重叠”的非集就是“重叠”。而“不重叠”的判定更简单（我一开始是这么想的，但当时对“重叠”情况的处理很混乱，所以换了思路）。如果再次做此题，正向反向都容易想到，没有特别的坑。</p>
<p>当扩展后的new和当前i不再重合时，需要把new和i都加入result里。这里需要一个布尔量表示new有没有已经被加入，这个步骤没办法写的更优雅。</p>
<p>coding时，还可以注意，我在妄想一步到位时，写满了[0]，[1]。。。把自己都给绕进去了。python是可以<code>for left, right in intervals</code>这么写的，所以别折磨自己，python is beautiful!</p>
<h3 id="Intervals-Intersection-medium"><a href="#Intervals-Intersection-medium" class="headerlink" title="Intervals Intersection (medium)"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/interval-list-intersections/">Intervals Intersection (medium)</a></h3><p>拟定一下算法流程，照着流程过一遍example，就没什么坑了。没什么巧思，一个一个if-else保证正确就行了。</p>
<h3 id="Conflicting-Appointments-medium"><a href="#Conflicting-Appointments-medium" class="headerlink" title="Conflicting Appointments (medium)"></a>Conflicting Appointments (medium)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Problem Statement</span><br><span class="line">Given an array of intervals representing ‘N’ appointments, find out if a person can attend all the appointments.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Appointments: [[1,4], [2,5], [7,9]]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: Since [1,4] and [2,5] overlap, a person cannot attend both of these appointments.</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Appointments: [[6,7], [2,4], [8,12]]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: None of the appointments overlap, therefore a person can attend all of them.</span><br><span class="line"></span><br><span class="line">Example 3:</span><br><span class="line"></span><br><span class="line">Appointments: [[4,5], [2,3], [3,6]]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: Since [4,5] and [3,6] overlap, a person cannot attend both of these appointments.</span><br></pre></td></tr></table></figure>

<p>最简单的区间问题，排序完了，遍历就行了。排序是正着还是反着都行。反正拍完序，只需要看相邻两个区间有没有相交。</p>
<h3 id="Problem-Challenge-1-Minimum-Meeting-Rooms-hard"><a href="#Problem-Challenge-1-Minimum-Meeting-Rooms-hard" class="headerlink" title="Problem Challenge 1 - Minimum Meeting Rooms (hard)"></a>Problem Challenge 1 - Minimum Meeting Rooms (hard)</h3><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/meeting-rooms-ii/">https://leetcode-cn.com/problems/meeting-rooms-ii/</a> plus</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Given a list of intervals representing the start and end time of ‘N’ meetings,</span><br><span class="line">find the minimum number of rooms required to hold all the meetings.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Meetings: [[1,4], [2,5], [7,9]]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: Since [1,4] and [2,5] overlap, we need two rooms to hold these two meetings. [7,9] can</span><br><span class="line">occur in any of the two rooms later.</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Meetings: [[6,7], [2,4], [8,12]]</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: None of the meetings overlap, therefore we only need one room to hold all meetings.</span><br><span class="line"></span><br><span class="line">Example 3:</span><br><span class="line"></span><br><span class="line">Meetings: [[1,4], [2,3], [3,6]]</span><br><span class="line">Output:2</span><br><span class="line">Explanation: Since [1,4] overlaps with the other two meetings [2,3] and [3,6], we need two rooms to</span><br><span class="line">hold all the meetings.</span><br><span class="line"></span><br><span class="line">Example 4:</span><br><span class="line"></span><br><span class="line">Meetings: [[4,5], [2,3], [2,4], [3,5]]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: We will need one room for [2,3] and [3,5], and another room for [2,4] and [4,5].</span><br></pre></td></tr></table></figure>

<p>因为所有intervals都得被满足，所以贪心策略可能可以得到最优解？</p>
<p>简单设想一下，已经排序好的intervals，一个一个尽量排，重叠了就新增一个room。</p>
<p>假设，此时已经用贪心策略得到了2个room，r1和r2，假设r1.end &lt;= r2.end，这时又想加入一个interval，它的start如果比两个end都小，那必然得出第三个room，这个不可能缩减。而如果start比一个小比一个大，那肯定是放入，但放1还是2？我们先比较，肯定是选r1（end最小的room）来比，如果end最小都放不下新的itv，就新增room。如果r1能放下新的itv，为了代码简洁，也应该直接放下了。（假设r2也放得下新itv，那么下一个itv也能放到r2，不会新建room；假设r2放不下新的itv，那就更不可能放r2了，至于下一个itv，就看更新后的r1r2能否满足了。）</p>
<p>——这一部分用数学推理下。</p>
<p>但显然，room不可能只限2个，所以可以考虑一个排序的容器，保存room的end。容器需要支持重复key，因为多个room的end可能数字一样。容器只需要取的出最小的end，之后end可能更新变大再插回容器，其他位置不用管。所以用优先队列最符合要求，而且python没有multiset，想不用优先队列都不行。</p>
<p>代码写起来还是很简单，rooms只会“堆顶被pop再更新push”和“pop新的room”两种情况。不过题解里有一个很骚的操作，就是会把rooms里end&lt;=itv.start的元素都pop掉。怎么理解这个东西？</p>
<p>首先按我原本的设计，rooms的len只会不变和变大，不仅如此，当前itv的end是必然会进优先队列的，区别只在于堆顶会不会pop（也可以理解为itv是会进入优先队列的，因为这里需要考虑itv.start了）。原本设计里优先队列“时刻对应”rooms的已有排列。但前面的思考里，也体现出了，rooms内可能多个room的end都&lt;=itv.start，这部分rooms不会对当前itv和之后的itv产生影响。无法产生影响，就可以直接当做“不存在”。“不存在”，所以可以从heapq里剔除掉，当前itv必然加入heapq（itv会不会影响，要看下一个itv的比较），当然，这时的heapq可能比“当前实际rooms len”小，所以用max来追踪heapq的len最长的时候。</p>
<p>（题解思路还不够清晰，有空再思考下）</p>
<h3 id="Problem-Challenge-2-Maximum-CPU-Load-hard"><a href="#Problem-Challenge-2-Maximum-CPU-Load-hard" class="headerlink" title="Problem Challenge 2 - Maximum CPU Load (hard)"></a>Problem Challenge 2 - Maximum CPU Load (hard)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">We are given a list of Jobs. Each job has a Start time, an End time, and a CPU load when it is running.</span><br><span class="line">Our goal is to find the maximum CPU load at any time if all the jobs are running on the same machine.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Jobs: [[1,4,3], [2,5,4], [7,9,6]]</span><br><span class="line">Output: 7</span><br><span class="line">Explanation: Since [1,4,3] and [2,5,4] overlap, their maximum CPU load (3+4=7) will be when both the</span><br><span class="line">jobs are running at the same time i.e., during the time interval (2,4).</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Jobs: [[6,7,10], [2,4,11], [8,12,15]]</span><br><span class="line">Output: 15</span><br><span class="line">Explanation: None of the jobs overlap, therefore we will take the maximum load of any job which is 15.</span><br><span class="line"></span><br><span class="line">Example 3:</span><br><span class="line"></span><br><span class="line">Jobs: [[1,4,2], [2,4,1], [3,6,5]]</span><br><span class="line">Output: 8</span><br><span class="line">Explanation: Maximum CPU load will be 8 as all jobs overlap during the time interval [3,4].</span><br></pre></td></tr></table></figure>

<p>很容易发现这个题和上一题安排会议，抽象下来是一样的。最容易想到的push/poppush的方法，但由于题目是求max load，所以要尝试改造，然后发现不行。因为这种方法没办法跟踪当前load sum。举例说明，假设itv已经排好序，start小的排前面，start相等时end小的排前面，如果itv1和itv2重合一部分，itv3和itv2重合，但是它并不与itv1重合，在看itv2和3重合的那一段时，load应该是2和3的load之和；而如果itv3和itv1也重合了，这时就应该是三个itv的load之和。但push/poppush是区分不了的，因为它只和heap top比较了一下，摸不到别的itv。</p>
<p>再想到while pop这个方法，虽然在上一题里它很不容易理解，但这道题反而该使用这个方法。核心在于while pop出和当前itv无关的itv，并相应减掉它们的load，就能够实时追踪到某一个时刻的load之和了。</p>
<ul>
<li><input disabled="" type="checkbox"> 再理解下上一题和while pop方法。</li>
</ul>
<h3 id="Problem-Challenge-3-Employee-Free-Time-hard"><a href="#Problem-Challenge-3-Employee-Free-Time-hard" class="headerlink" title="Problem Challenge 3 - Employee Free Time (hard)"></a>Problem Challenge 3 - Employee Free Time (hard)</h3><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/employee-free-time/">https://leetcode-cn.com/problems/employee-free-time/</a> plus</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">For ‘K’ employees, we are given a list of intervals representing the working hours of each employee.</span><br><span class="line">Our goal is to find out if there is a free interval that is common to all employees.</span><br><span class="line">You can assume that each list of employee working hours is sorted on the start time.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: Employee Working Hours=[[[1,3], [5,6]], [[2,3], [6,8]]]</span><br><span class="line">Output: [3,5]</span><br><span class="line">Explanation: Both the employess are free between [3,5].</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: Employee Working Hours=[[[1,3], [9,12]], [[2,4]], [[6,8]]]</span><br><span class="line">Output: [4,6], [8,9]</span><br><span class="line">Explanation: All employess are free between [4,6] and [8,9].</span><br><span class="line"></span><br><span class="line">Example 3:</span><br><span class="line"></span><br><span class="line">Input: Employee Working Hours=[[[1,3]], [[2,4]], [[3,5], [7,9]]]</span><br><span class="line">Output: [5,7]</span><br><span class="line">Explanation: All employess are free between [5,7].</span><br></pre></td></tr></table></figure>

<p>这题本质是一种反向，题目提过工作时间，让你求非工作的某种时间，所以可以用交集并集差集来理解这个题，方便快速的分辨多个解法的复杂度。当然，最佳算法可能比这种逻辑运算的计算量更小，但不熟悉这类题目的情况下，越抽象的思考越容易做。</p>
<p>可以看到k个list，每个list都多个interval，所有的interval的并集，就是所有员工的工作时间，这个集合的反，就是所有的空闲区间（空闲区间显然也可以是多个）。</p>
<p>题目说明了，k个list，list内的区间都是有序的。这很像k路归并排序。按理可以比所有inteval混在一起排序更高效。那我们先mark这个归并思路，放在一边。（有序基本就是在提醒我们存在“利用有序”的优化算法）</p>
<h4 id="简单思路"><a href="#简单思路" class="headerlink" title="简单思路"></a>简单思路</h4><p>假设经过某种算法，已经计算出了所有working hours的并集，这个并集当然可能是多个区间，不一定是一个连续区间。求反只需要遍历这一堆区间就行了。</p>
<p>再来考虑，这个“某种算法”求并集，怎么做。最简单的肯定是全排序。每个区间先比较start，小的排在前面，end随意。这里很可能会出现连续几个区间是有重合部分的，所以，求并集，还得遍历一边，重组一下区间，得到并集（不重合的区间组成的数组）。然后还得再遍历求反。</p>
<p>简单一想，也知道，最后一次遍历多余了。</p>
<p>所以，可以立马优化为，遍历已排序的区间时就求空闲区间。</p>
<p>可以再思考一下，我先每个list先求反，得到每个员工的空闲时间，所有的空闲时间的交集也是最终答案。但空闲时间区间个数不见得比工作区间个数少多少（应该是，对每个list，空闲区间=工作区间-1）。并没有把复杂降低。而且求交集比求并集复杂，因为空闲区间没办法全部一起求交集。想象一下，假设5个员工，有1个在[0,t]之间都不空闲，但是另外4个却可以在[0,t]这个时间内存在交集，但是这个交集是不能要的，因为那一个人不空闲。区间全混在一起时，根本无法判断。所以还是求并集吧。</p>
<h4 id="归并思路"><a href="#归并思路" class="headerlink" title="归并思路"></a>归并思路</h4><p>每个list“有序“，自然是提醒我们要充分利用这个特性。全排序肯定不够用。而list内interval有序，很显然可以做类似归并排序的操作。</p>
<p>归并思路，k个list也就是k路，每次都从k个list的头上选出最小的。这k个区间比还呆在list里的区间的start都要小，在k个中选出来的start最小的区间，也就是全局start最小的区间。所以，当我们将k个中选start最小看作一个模块时，我们从这个模块中拿出“剩余区间”中start最小那个区间。一个一个拿，就是总能按顺序拿出区间了。</p>
<p>核心是这个模块如何实现，即考虑“k个中选最小的”怎么高效，归并算法如果只有两路，当然if-else都能行，但k路肯定是不可能一个一个比的，很明显可以利用最小堆，每次的top就是最小的，top取出来后，top所在的list就应该补充一个区间进入最小堆。python中也就是使用heapq，可以极快的写完代码。</p>
<p>堆算法解释见<a href="/2022/10/07/abs-algo/" title="Heap">Heap</a>。</p>
<p>具体到这个题目，首先要思考这个堆该如何运行，放多少数据，pop出来后又push多少进去，初步设计应该尽量分割步骤，目标是迅速写出正确的算法，后面再做优化。</p>
<p>所以初步设想是，k路数组，每个数组自己内部有序，但k个数组的头，我们是不知道谁最小的，所以把k个数组的头放进堆，我们就可以立马拿到最小的数，此时堆里剩k-1个数，这时候应该将pop出去的那一路的新头补充进堆，因为我们知道数组内的都比堆里的大，只有堆里的有资格比拼一下，所以堆大小在运行期间应该保持为k，不需要多放，多了增加复杂度，少了就比不出全局最小了。</p>
<p>Grokking标准答案也是使用python heapq来做，这个确实写得最快。</p>
<h5 id="败者树"><a href="#败者树" class="headerlink" title="败者树"></a>败者树</h5><p>堆解法不是终点， 如果提到有没有别的思路，就肯定要说到败者树算法了。本质都是树，不会有数量级提升。但总有些区别。</p>
<h6 id="外排序todo"><a href="#外排序todo" class="headerlink" title="外排序todo"></a>外排序todo</h6><p>winner/loser tree很像B+树，非叶子节点是不存值的，所以，和B+树类似，它们可以用在“外排序external sorting”上。</p>
<p><a target="_blank" rel="noopener" href="https://www.cise.ufl.edu/~sahni/cop5536/">https://www.cise.ufl.edu/~sahni/cop5536/</a> 这个网站有很详细的exteral sorting的ppt，需要好好看看。（但是很难懂。。可以当作提纲）</p>
<p>针对winner/loser tree（统一可以叫做Tournament Tree）来讲，你需要知道，Tournament Tree可以利用于improve run generation, 也可以improve run merging。</p>
<p>解释下run generation。外排序不可能把所有的扔进内存里，所以只能先切分成小部分排序，然后做merge，这两步叫做，run generation和run merging。A run is a sorted squence of records。</p>
<p>improve run generation最简单的就是reduce the number of runs(也就是increase average run length)。但这也是有极限的，而且由于外排序在IO上很耗时，所以overlap IO也是一个优化方法。都在课件里，之后再慢慢看。</p>
<h6 id="返回tournament-tree"><a href="#返回tournament-tree" class="headerlink" title="返回tournament tree"></a>返回tournament tree</h6><p>败者树和胜者树是可以一起看的类似结构。胜/败者树都是类似B+树，只有叶子节点是真实值，非叶子节点是胜者/败者的标号，而且它是完全二叉树，不会有歧义。但胜者树和败者树<strong>不是</strong>单纯的一个非叶子节点记录胜者，一个非叶子节点记录败者，否则这两种就应该是一种树，只要compare函数求个反就行了。</p>
<p>胜者树</p>
<p>胜者树更简单，我们先看胜者树，比如小的是胜者，那么每个非叶节点都是它的子节点中更小的那一个。原理很简单，实现上要捋一捋。</p>
<p>可以把整个建树过程理解为打比赛，那比赛，肯定是从下往上打。最下层的非叶子结点先被填上值。按最简单的想法，胜者树用数组表示，每个元素是值（比较大小的值，不是索引）。这样子会有什么问题？当我们把胜者根节点拿出去，我们都不知道应该补上哪个list的元素。所以这个胜者树的节点，应该有索引，标记第i个list，这样就可以补充list[i].top进来。节点可以又保存值，又保存list标号，不过被拿来建树用的k个区间，本来也会放在一个地方，可以叫做ext数组，这样，胜者树节点只需要保存list标号就行了。ext[i]可以取值，list[i].top可以拿到补充用的区间。</p>
<p>而且注意，胜者树是所有参赛者都作为叶子节点的，比如，有3个叶子节点时怎么建树？有6个叶结点时，上一层3个节点，那它的上一层又怎么办？</p>
<p>注意，胜者树定义为complete binary tree，完全二叉树，它只有最底层可能少尾部一些节点，其他节点都是满的。所以，不会存在6个叶节点，上一层只有3个节点的情况，这棵树必须是最底层6个节点（理论上是8个），上一层4个节点（即使这一层最右的这个节点是没意义的，可以用max值，这样不影响比赛结果）。</p>
<p>解决胜者树的节点结构和树形，这两个问题，就可以写算法了。Ref </p>
<p><a target="_blank" rel="noopener" href="https://gist.github.com/vagetablechicken/8a2fc94da27f127921c0b6dd08d7863f">https://gist.github.com/vagetablechicken/8a2fc94da27f127921c0b6dd08d7863f</a></p>
<p>败者树</p>
<p>而败者树呢，非叶节点是记录败者，但是往上送的参赛者是“胜者”（关键点）。</p>
<p>为什么这么做呢？假设胜者树的重新比赛，一个叶子节点被换了，那么它要和它的兄弟节点比。而败者树里，更新的节点只需要找它的parent，就能决定parent是否要更新，不用去访问兄弟节点。</p>
<p>这里粗略一想，觉得很莫名，也没有节约多少东西？</p>
<p>假设两个兄弟节点n1、n2，n1之前不是胜者，但现在比较一下发现n1是胜者，n1的parent就要被我更新为n1？而在败者树里面，我虽然只需要访问n1和n1的parent，不用访问n2，但这能节约多少？</p>
<p>这个问题，如果只看算法题目这种规模当然节约不了什么。但败者树通常用于外排序，外排序的数据规模就很可观了。就访问而言，以前要访问两个，现在要访问一个，访问总次数一多，耗时差距就很大了。（应该不用觉得兄弟节点会需要单独一次I/O从磁盘里读出来，毕竟外部排序的归并部分也是应该保证在内存里进行的，归并部分都要存硬盘了，这个归并k选的也不太对了。）</p>
<p>逻辑上走通了，再来说说code的问题。两个叶子节点比较，得到败者作为父节点，这里还很常规，但是还得往上送胜者，这里就微妙了。难道代表败者树的数组，每个元素都得存两个东西，胜者和败者？还是说，得用node指针来构建树？</p>
<p>complete binary tree不用数组怪浪费的。而且node指针构建树，一开始只有k个单节点的败者树，还要把它们merge起来。merge得先两两merge，注意，要一直保持每棵树的complete binary tree性质。所以，还总是需要构建无意义的节点，为了保持complete binary tree。有点离谱。</p>
<p>还是尝试用数组来表示败者树。其实败者树从构建成功起，就不会再变更树结构，所以建树期间的胜者可以用单独变量来保存，建好树之后，它们就没有意义了，只有全局的那个胜者有意义。</p>
<p>还是在 <a target="_blank" rel="noopener" href="https://gist.github.com/vagetablechicken/8a2fc94da27f127921c0b6dd08d7863f">https://gist.github.com/vagetablechicken/8a2fc94da27f127921c0b6dd08d7863f</a></p>
<p>注意，胜者树可以随便更新参赛者，并且需要从叶子一路更新到根节点，不然可能存在问题。因为，新参赛者即使曾经是某一层的winner，现在值变了还是winner，但它的值变了，往上走它可能就不是了。只有它之前是loser，现在跟之前的winner比还是loser时，才可以停下来。这个优化可以，但没必要，容易写错。建议先写出简单不易错的算法，再谈要不要优化。</p>
<p>败者树则是必须更新winner所在的值，因为败者树要保证只更改胜者走的那条路径。有了这个保证，才能肯定parent存的败者一定是兄弟节点，才可以避免访问兄弟节点。败者树也得一路到根节点，不能因为以前是胜者，现在还是，就不往上比较了，值变了！！！</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://vagetablechicken.github.io/2021/05/06/grokking-6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Huang Wei">
      <meta itemprop="description" content="Coding, Struggling, and Living.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wei">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/06/grokking-6/" class="post-title-link" itemprop="url">Grokking Pattern 6</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-05-06 10:58:13" itemprop="dateCreated datePublished" datetime="2021-05-06T10:58:13+08:00">2021-05-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-07-31 18:56:53" itemprop="dateModified" datetime="2023-07-31T18:56:53+08:00">2023-07-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Algo/" itemprop="url" rel="index"><span itemprop="name">Algo</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Grokking-the-Coding-Interview-Patterns-for-Coding-Questions"><a href="#Grokking-the-Coding-Interview-Patterns-for-Coding-Questions" class="headerlink" title="Grokking the Coding Interview: Patterns for Coding Questions"></a>Grokking the Coding Interview: Patterns for Coding Questions</h1><p>See <a href="/2021/05/06/grokking-1/" title="Grokking Pattern 1">Grokking Pattern 1</a>.</p>
<h2 id="6-Pattern-In-place-Reversal-of-a-LinkedList"><a href="#6-Pattern-In-place-Reversal-of-a-LinkedList" class="headerlink" title="6. Pattern In-place Reversal of a LinkedList"></a>6. Pattern In-place Reversal of a LinkedList</h2><h3 id="Reverse-a-LinkedList-easy"><a href="#Reverse-a-LinkedList-easy" class="headerlink" title="Reverse a LinkedList (easy)"></a>Reverse a LinkedList (easy)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Given the head of a Singly LinkedList, reverse the LinkedList.</span><br><span class="line"> Write a function to return the new head of the reversed LinkedList.</span><br></pre></td></tr></table></figure>

<p>反转的基本操作：两个指针，一前一后，改变后一节点的next指针，同时就会失去后一节点的原next，所以需要第三个指针，保住后一节点的原next。</p>
<p>再优化：由于每一次新的比较，都只需要两个指针，指向“后一节点的next节点”的指针是可以在此基础上再找到的，不需要一直追着。</p>
<p>遍历结束后，最后一个节点就是头节点，所以不需要别的额外的变量。</p>
<h3 id="Reverse-a-Sub-list-medium"><a href="#Reverse-a-Sub-list-medium" class="headerlink" title="Reverse a Sub-list (medium)"></a>Reverse a Sub-list (medium)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Given the head of a LinkedList and two positions ‘p’ and ‘q’, reverse the LinkedList from position ‘p’ to ‘q’.</span><br></pre></td></tr></table></figure>

<p>p,q是positions，也就是第几个元素。不是value，更不是直接的node地址。</p>
<h3 id="Reverse-every-K-element-Sub-list-medium"><a href="#Reverse-every-K-element-Sub-list-medium" class="headerlink" title="Reverse every K-element Sub-list (medium) *"></a>Reverse every K-element Sub-list (medium) *</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Given the head of a LinkedList and a number ‘k’, reverse every ‘k’ sized sub-list starting from the head.</span><br><span class="line"></span><br><span class="line">If, in the end, you are left with a sub-list with less than ‘k’ elements, reverse it too.</span><br></pre></td></tr></table></figure>

<p>首先看边界，因为末尾不足k的也翻转，所以可以无脑翻转。如果题目末尾变成不足k的<strong>不可以翻转</strong>（<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-nodes-in-k-group/">leetcode 原题</a>），那么就得先数k，不到k个就退出，有k个再翻转，多了一次遍历，不过也是O(n)。</p>
<p>题目有些细节，但本质还是两个指针的事情，不难做对。不过我第一反应是不会改动初始链表的，但这一题如果加哨兵（一个dummy node接上链表head），会更简单点，不用在遍历while里写if判断是不是首次翻转，如果是首次，需要存下这个new head。（效率还是更高的，虽然不算太重要）</p>
<h3 id="Problem-Challenge-1-Reverse-alternating-K-element-Sub-list-medium"><a href="#Problem-Challenge-1-Reverse-alternating-K-element-Sub-list-medium" class="headerlink" title="Problem Challenge 1 - Reverse alternating K-element Sub-list (medium)"></a>Problem Challenge 1 - Reverse alternating K-element Sub-list (medium)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Given the head of a LinkedList and a number ‘k’, reverse every alternating ‘k’ sized sub-list starting from the head.</span><br><span class="line"></span><br><span class="line">If, in the end, you are left with a sub-list with less than ‘k’ elements, reverse it too.</span><br></pre></td></tr></table></figure>

<h3 id="Problem-Challenge-2-Rotate-a-LinkedList-medium"><a href="#Problem-Challenge-2-Rotate-a-LinkedList-medium" class="headerlink" title="Problem Challenge 2 - Rotate a LinkedList (medium)"></a>Problem Challenge 2 - Rotate a LinkedList (medium)</h3>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://vagetablechicken.github.io/2021/05/06/grokking-5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Huang Wei">
      <meta itemprop="description" content="Coding, Struggling, and Living.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wei">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/06/grokking-5/" class="post-title-link" itemprop="url">Grokking Pattern 5</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-05-06 10:58:13" itemprop="dateCreated datePublished" datetime="2021-05-06T10:58:13+08:00">2021-05-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-07-31 18:56:53" itemprop="dateModified" datetime="2023-07-31T18:56:53+08:00">2023-07-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Algo/" itemprop="url" rel="index"><span itemprop="name">Algo</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Grokking-the-Coding-Interview-Patterns-for-Coding-Questions"><a href="#Grokking-the-Coding-Interview-Patterns-for-Coding-Questions" class="headerlink" title="Grokking the Coding Interview: Patterns for Coding Questions"></a>Grokking the Coding Interview: Patterns for Coding Questions</h1><p>See <a href="/2021/05/06/grokking-1/" title="Grokking Pattern 1">Grokking Pattern 1</a>.</p>
<h2 id="5-Pattern-Cyclic-Sort"><a href="#5-Pattern-Cyclic-Sort" class="headerlink" title="5. Pattern Cyclic Sort"></a>5. Pattern Cyclic Sort</h2><p>这个cyclic sort，需要一点预备知识。cyclic sort条件是，数组元素必须是1到n，虽然乱序，但我们可以确定这个n长的数组里一定是1到n这n个数字，不会有别的数字。如果要对这种特别的数组排序，就可以环型排序，也可以叫圈排序。都知道1到n了还排序就很离谱，所以这并不是cyclic sort的使用场景。事实上，使用场景是Cyclic Sort这一题之外的题目。</p>
<h3 id="Cyclic-Sort-easy"><a href="#Cyclic-Sort-easy" class="headerlink" title="Cyclic Sort (easy)"></a>Cyclic Sort (easy)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Problem Statement</span><br><span class="line">We are given an array containing ‘n’ objects. Each object, when created, was assigned a unique number from 1 to ‘n’ based on their creation sequence.</span><br><span class="line">This means that the object with sequence number ‘3’ was created just before the object with sequence number ‘4’.</span><br><span class="line"></span><br><span class="line">Write a function to sort the objects in-place on their creation sequence number in O(n) and without any extra space.</span><br><span class="line">For simplicity, let’s assume we are passed an integer array containing only the sequence numbers, though each number is actually an object.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: [3, 1, 5, 4, 2]</span><br><span class="line">Output: [1, 2, 3, 4, 5]</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: [2, 6, 4, 3, 1, 5]</span><br><span class="line">Output: [1, 2, 3, 4, 5, 6]</span><br><span class="line"></span><br><span class="line">Example 3:</span><br><span class="line"></span><br><span class="line">Input: [1, 5, 6, 4, 3, 2]</span><br><span class="line">Output: [1, 2, 3, 4, 5, 6]</span><br></pre></td></tr></table></figure>

<p>这个题目着实惊呆我了，我遍历一遍直接将第i个元素改成i+1都通过测试。</p>
<p>不过老实做题的话，这个确实可以用cyclic sort做。cyclic sort具体步骤是，遍历，当当前的元素不在它应该在的位置时，把它和它应该在的那个位置的值做个交换，比如数组[4,3,2,1]，当前看第一个元素4，它应该在最后，所以就交换一下，变成[1,3,2,4]。并且下一个要处理的元素还是当前，因为被交换了过来的元素可能也不是正确位置。</p>
<p>这个排序法的时间复杂度看起来很诡异，不知道怎么算。但可以这么考虑，因为我每一次swap，必然把一个元素放对位置了，所以swap次数最多就n-1次。因为n-1个元素位置对了，自然最后一个元素位置就对了，所以只有n-1次。</p>
<p>可以举个最差例子，[3,1,2]每个元素都不在正确位置。看3，swap后为[2,1,3]，3就放对了，继续看2，swap后[1,2,3]，由于2放对了，最后剩的一个元素就对了。</p>
<p>代码很好写，不用赘述。</p>
<p>但这个排序算法的意义何在呢？接下来的题目里可以提现。</p>
<h3 id="Find-the-Missing-Number-easy-–-LeetCode"><a href="#Find-the-Missing-Number-easy-–-LeetCode" class="headerlink" title="Find the Missing Number (easy) – LeetCode"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/missing-number/">Find the Missing Number (easy) – LeetCode</a></h3><p>这个题目当然可以用cyclic sort做，但是需要注意，题目中是0-n少了某一个，然后乱序放在n长的数组里。假设缺少的那个数不是n，那么数组里就有n，上个题解中的cyclic sort，当然是不能把n这个数放对位置的，因为n长数组idx最大到n-1，没有n。</p>
<p>这怎么办呢？看了<a target="_blank" rel="noopener" href="https://emre.me/coding-patterns/cyclic-sort/">Coding Patterns: Cyclic Sort - emre.me</a>就知道了，只需要忽略n就可以了，如果访问到n，就跳过n，往后访问。这样，遍历操作一遍后，就会出现，n在“不存在的那个数”的位置上，其他数都在对应的位置上。再遍历一次数组，就可以找到missing number了，显然如果遍历一遍数字都对，那么就是missing n这个数了。</p>
<p>这个题目有多种解法，bitmap等等，还能用数学的方法来做。但cyclic sort有一个好处，就是完全没有用额外空间。</p>
<h3 id="Find-all-Missing-Numbers-easy"><a href="#Find-all-Missing-Numbers-easy" class="headerlink" title="Find all Missing Numbers (easy)"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/">Find all Missing Numbers (easy)</a></h3><p>跟上题不一样了，输入n长的数组，里面就是1-n的某些，数字可重复，要输出all missing numbers。</p>
<p>但也容易做出来，拿example 1推演一遍就知道该怎么做了。把”错误位置的元素swap到正确位置“这一条规则不变，但如果有重复元素，就会出现nums[i]!=i and nums[nums[i]] == nums[i]（意思是这么，但实际上idx从0到n-1，数值从1-n，代码里得偏移），此时nums[i]这个元素就是多余的，做一个特殊标记就行了，比如0或者-1，遍历中也要先ignore特殊值。于是missing numbers就是有特殊标记的那些，因为找不到值放在这些特殊位置上，说明这些值不存在。<del>代码也简单，不多赘述。</del></p>
<p>同样，什么bitmap之类的都能做这个题，但cyclic sort可以O(n) and without extra space。</p>
<p>说代码简单，但也撞上错误了。主要是想节约空间，就直接拿nums[nums[i]]来swap，python swap a,b = b,a 也是有执行顺序的，nums[i]中途变了，最后结果反而是没有swap。很神奇。</p>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/a/62038590">algorithm - How swapping variables is implemented in Python? - Stack Overflow</a>可以知道，a,b=b,a实际上是x1=a, x2=b,a=x2,b=x1，当然x1、x2是栈空间，还是需要auxiliary temporary locations。swap也没有magic。</p>
<p>不过还有一个点，就是swap这个写法，等式右边也是寻址才能拿到值，不是常量值，这里的规则是先把=右边算出来，详情见<a target="_blank" rel="noopener" href="https://stackoverflow.com/a/51950571">algorithm - python a,b = b,a implementation? How is it different from C++ swap function? - Stack Overflow</a>。假设nums[i]值为v1，nums[nums[i]]值为v2，</p>
<p>nums[i], nums[nums[i]] = nums[nums[i]], nums[i]这一句会先拿出=右边的值，于是等价于nums[i], nums[nums[i]] = v2, v1。</p>
<p>然后这个时候才会真正找左边的地址，走x1，x2那一套交换。先找nums[i]，找到了，然后赋值v2，然后nums[nums[i]]就是nums[v2]，会把v1赋值给nums[v2]。</p>
<p>本来这个写法最多就是触发了错误的赋值，因为nums[v2]这个位置原本不应该参与进来。</p>
<p>但有趣的是，如果case比较巧合，碰上了v2==i，例如[2,1,0]，取i=0，nums[i]=2，v1=2，nums[nums[i]]=0，v2=0，这就给循环上了。于是nums[i]先被赋值为v2，也就是nums[0]=0(v2)，然后nums[v2]被赋值v1，也就是nums[0]=2，搞了半天，什么也没有变，nums[i]这个位置的值变了又变回来。</p>
<p>恰好我随便写的例子[4,3,2,1]完美符合。</p>
<p>而leetcode的case1 [4,3,2,7,8,2,3,1]，也会死循环。举例说明，第一次交换时用的4和7(idx 0和3)，即num[i], nums[nums[i]-1] = (7, 4)，nums[0]=7，nums[7-1]=4，而第二次交换就要num[i], nums[nums[i]-1] = (4, 7)，nums[0]=4, nums[4-1]=7，第三次交换则是num[i], num[nums[i]-1]=(7, 4)，然后无限循环。这么说肯定很难懂，可以自己推演四五次交换，就会发现，由于第一次交换，无脑地使num[7-1]=4，导致之后，nums[4-1]和nums[7-1]就都不会变了，永远是7和4。然后nums[i]也就是nums[0]不是赋值为7就是赋值为4。</p>
<p>如果用nums[i]=v1,nums[v1]=v2来表示，假设nums[v2]可以访问，第一次交换后，nums[i]的值就会v1、v2反复横跳，nums[v1]永远=v2，nums[v2]永远=v1，虽然是（从1次开始计数）奇数次给v2赋值，偶数次给v1赋值，但第2次交换开始，给v1、v2赋的值永远一样，看起来就是永远不变。leetcode case1并没有太特别，只需要nums[v2]可以访问，就能永远死循环下去。</p>
<p>总之，一旦python swap的时候值是嵌套定位的，就要小心，最好避免swap里有嵌套。</p>
<h3 id="Find-the-Duplicate-Number-medium-–-LeetCode"><a href="#Find-the-Duplicate-Number-medium-–-LeetCode" class="headerlink" title="Find the Duplicate Number (medium) – LeetCode"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-the-duplicate-number/">Find the Duplicate Number (medium) – LeetCode</a></h3><p>这个题目grokking和leetcode的要求不一样，grokking是不允许额外空间，但可以修改输入数组。leetcode则是不能修改输入数组，并且只是用常数量的额外空间。</p>
<p>grokking的限制下，当然还是cyclic sort了，sort途中就能发现重复的那一个数（题目说只有一个，发现后立刻返回就行了）。</p>
<p>leetcode的限制下，就不一样了，最简单当然是set/hash存，但不满足额外空间的限制。不能简单求和，因为他不是保证1到n都出现，而是只限制在[1, n]范围内，而且虽然只有一个数重复出现，但它可以出现2次以上。没有预备知识，很难想到这个题目可以用二分查找或者链表来解，链表还好说点，二分查找这个方法真有点过绕了，而且复杂度也要到nlogn，纯属脑筋急转弯。。。</p>
<p>不过确实也是个思路，而且不能直接套用基础版的二分查找，需要一定的改动，就算没改动，也需要证明可行性。整理了一下，没什么特别的坑，很容易做出来。算法设计期间需要注意，[left, right]这个搜索范围能不能缩小，如果某些情况不能缩小，自然不能最后缩小为最终答案一个值。</p>
<ul>
<li><input disabled="" type="checkbox"> 链表方法解这道题</li>
</ul>
<h3 id="Find-all-Duplicate-Numbers-medium-–-LeetCode"><a href="#Find-all-Duplicate-Numbers-medium-–-LeetCode" class="headerlink" title="Find all Duplicate Numbers (medium) – LeetCode"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-all-duplicates-in-an-array/">Find all Duplicate Numbers (medium) – LeetCode</a></h3><p>这一题grokking和leetcode要求类似了，grokking不允许额外空间（一些临时变量的栈空间肯定是允许的，不然代码都写不了），也就是常数量级的空间了。</p>
<p>这题用cyclic sort很容易做。因为题目保证了数字最多出现2次，“出现2次”在cyclic sort框架里是可以判断的，比如规则写为“出现一次的就在对应的位置上，当又想swap该值到对应位置，就说明该值第二次出现，该位置记为-2”，当你读到-2的时候就说明i这个值出现了2次。出现更多次也可以以此类推。cyclic sort可以说是完美的，不论统计出现几次的值，都可以做到。</p>
<p>但包括这个题和之前的题目，都有另一种常见做法。本质上是hash算法，因为通过自定义的hash，我们能把原数组变成hash桶，原来的nums内每一个位置都是一个数值，hash以后，nums每一个位置i都表示“数值i”出现的情况（这个情况实际当然是数字，而且由于是原地修改nums数组，这个“情况”是编码后的样子，得对应解码才能得出真实信息。）核心就是“编码规则”。设想下，如果你不编码，假设遇到i位置上值为x，你改了nums[x]，并且不理会nums[x]原来位置的值，如果x大于i，你之后遍历到x位置时，就丢了这个数。所以必须编码，用一种方法，能够保留住原数值信息，同时也能存下这个位置i表示的数i出现了多少次。</p>
<p>最简单的做法就是+n+1，因为值最大到n，当你遍历数组时，发现i处的数值&gt;n+1时，说明i值在前面出现过，而出现几次就相应+n+1，这样数值为x时，可以x//(n+1)得到出现次数，而x%(n+1)就可以得到i位置原始的数值，不会漏数。这就是一种编解码规则。</p>
<p>P.S. 也可以+n，当然，计算公式要跟着改变，[1,n]中如果取值n，求余就只能得到0了，所以值-1再求余，才可以。刚好，余数直接对应idx，+n+1的情况余数是真实数值，还得减一才能得到idx。</p>
<p>取反也是可以使用的编解码规则，出现一次就取反，但出现第二次还取反的话，就不行了，所以最多做到得出“出现两次”这个信息（都只能即时拿到，不能二次取反写入nums数组，这样跟一次没出现的情况就混在一次了），不可能辨别有没有出现第三次。</p>
<h3 id="Problem-Challenge-1-Find-the-Corrupt-Pair-easy"><a href="#Problem-Challenge-1-Find-the-Corrupt-Pair-easy" class="headerlink" title="Problem Challenge 1 - Find the Corrupt Pair (easy)"></a>Problem Challenge 1 - Find the Corrupt Pair (easy)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">We are given an unsorted array containing ‘n’ numbers taken from the range 1 to ‘n’. The array originally contained all the numbers from 1 to ‘n’, but due to a data error, one of the numbers got duplicated which also resulted in one number going missing. Find both these numbers.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: [3, 1, 2, 5, 2]</span><br><span class="line">Output: [2, 4]</span><br><span class="line">Explanation: &#x27;2&#x27; is duplicated and &#x27;4&#x27; is missing.</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: [3, 1, 2, 3, 6, 4]</span><br><span class="line">Output: [3, 5]</span><br><span class="line">Explanation: &#x27;3&#x27; is duplicated and &#x27;5&#x27; is missing.</span><br></pre></td></tr></table></figure>

<p>题目不难，还是满足cyclic sort，但if-else有点多，不太简洁。因为我没有当发现duplicate number后即时保存，而是标记为-2，missing number则是标记为0。这样的算法，覆盖面更广，如果有多个duplicate或者missing number，都可以被查出来。但这个题已经明确说了dup和missing都只有一个，所以可以更简化一点。</p>
<p>回归最简单的cyclic sort，拿example推演一下，如果发现了nums[i]想要换到的位置已经有了，这个时候dup就知道了，但是这一次要不要swap？</p>
<p>举例说明，[1,2,3,2]，当我们看到第二个2时，显然不能swap，会死循环。不swap，那怎么做呢？按前面的算法逻辑，就该把[i]这个位置标记为0或者什么。但这么做的话，又会增加if-else，因为下一次读[i]可能有0这个值了，必须单独考虑。</p>
<p>所以，再简单点，不swap，我也不操作了，就i+=1去搞下一个元素。这么做，是没问题的，很类似Find the Missing Number (easy)“n长的数组，是0到n这n+1个数缺了某个数”。Find the Missing Number (easy)的数组中可能有n，n是没办法交换到它应该在的位置的，所以放着就好了，它会在missing的那个位置上，或者整个数组都ok，n这个值就是missing的那一个。</p>
<p>再总结，例如[1,2,3,2]这个数组，我们忽略第二个2，那么数组最后的样子就是[1,2,3,2]，再次遍历数组，i为3时[i]!=i+1，说明了什么？说明这个地方应该出现的值没在，所以i+1是missing number，而[i]==2，说明2是多的那个，所以[i]是dup number。</p>
<p>最后，再理解一下，这个题目其实和Find the Missing Number一模一样，因为dup和missing number都是通过错误的那一个位置可以得到。</p>
<p>代码见 <a target="_blank" rel="noopener" href="https://gist.github.com/vagetablechicken/31b210446ec55944cb490c658c3c6a04">https://gist.github.com/vagetablechicken/31b210446ec55944cb490c658c3c6a04</a></p>
<h3 id="Problem-Challenge-2-Find-the-Smallest-Missing-Positive-Number-medium"><a href="#Problem-Challenge-2-Find-the-Smallest-Missing-Positive-Number-medium" class="headerlink" title="Problem Challenge 2 - Find the Smallest Missing Positive Number (medium)"></a>Problem Challenge 2 - Find the Smallest Missing Positive Number (medium)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Given an unsorted array containing numbers, find the smallest missing positive number in it.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: [-3, 1, 5, 4, 2]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The smallest missing positive number is &#x27;3&#x27;</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: [3, -2, 0, 1, 2]</span><br><span class="line">Output: 4</span><br><span class="line"></span><br><span class="line">Example 3:</span><br><span class="line"></span><br><span class="line">Input: [3, 2, 5, 1]</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure>

<p>这个题目简单一想，就是cyclic sort，sort完后第一个nums[i]!=i+1的地方就是the smallest missing positive number。但是要注意到（就算没注意到，example 3也过不了），nums中可能会出现&gt;len+1的数，cyclic sort时也没办法把这种数放到“正确的位置”。再细想一下，总共就len这么多个数字，如果真就[1,len]每个数字出现一次，smallest missing positive number自然就只能是len+1了。所以，smallest missing positive number的取值范围只可能是[1,len+1]，不会更大了。</p>
<h3 id="Problem-Challenge-3-Find-the-First-K-Missing-Positive-Numbers-hard"><a href="#Problem-Challenge-3-Find-the-First-K-Missing-Positive-Numbers-hard" class="headerlink" title="Problem Challenge 3 - Find the First K Missing Positive Numbers (hard)"></a>Problem Challenge 3 - Find the First K Missing Positive Numbers (hard)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Given an unsorted array containing numbers and a number ‘k’, find the first ‘k’ missing positive numbers in the array.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: [3, -1, 4, 5, 5], k=3</span><br><span class="line">Output: [1, 2, 6]</span><br><span class="line">Explanation: The smallest missing positive numbers are 1, 2 and 6.</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: [2, 3, 4], k=3</span><br><span class="line">Output: [1, 5, 6]</span><br><span class="line">Explanation: The smallest missing positive numbers are 1, 5 and 6.</span><br><span class="line"></span><br><span class="line">Example 3:</span><br><span class="line"></span><br><span class="line">Input: [-2, -3, 4], k=2</span><br><span class="line">Output: [1, 2]</span><br><span class="line">Explanation: The smallest missing positive numbers are 1 and 2.</span><br></pre></td></tr></table></figure>

<p>看起来是挺简单的变种题目，但并不是。首先数组内元素没有限制，如果数组里存在&gt;len的数，它是会影响结果的，不能直接忽略。</p>
<p>可以也先不管&gt;len的数，但这样的结果就是，可以O(n)知道&lt;=len的missing numbers，更大的missing numbers只能枚举，而且还得排除存在于nums数组里的，所以得有个set保存nums中存在的&gt;len的数，每个数都要查一次是否存在，O(nlogn)。</p>
<p>这个&gt;len的查询是省不掉的。参考答案里也是这个方法，简单朴实。</p>
<p>注意一下example1，因为它有重复的5和5，不能用最简单的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">while i&lt;len:</span><br><span class="line">    if cond and nums[i] != i+1:</span><br><span class="line">        swap</span><br><span class="line">    else:</span><br><span class="line">        i+=1</span><br></pre></td></tr></table></figure>

<p>这么的话，经过几次swap，num[0]==5了，5想要被换到idx 4的地方，但恰好这里又是5，陷入死循环。</p>
<p>更好的逻辑是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">while i&lt;len:</span><br><span class="line">    j = nums[i]-1</span><br><span class="line">    if cond and nums[i] != nums[j]:</span><br><span class="line">        swap</span><br><span class="line">    else:</span><br><span class="line">        i+=1</span><br></pre></td></tr></table></figure>

<p>因为nums[i]==i+1时，j就等于i，指向的同一个位置i，[i]!=[j]就可以判断了，还避免了重复情况。</p>
<p>其他坑，例如要保证output个数为k个等等都比较好修复。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://vagetablechicken.github.io/2021/05/06/grokking-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Huang Wei">
      <meta itemprop="description" content="Coding, Struggling, and Living.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wei">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/06/grokking-1/" class="post-title-link" itemprop="url">Grokking Pattern 1</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-05-06 10:58:13" itemprop="dateCreated datePublished" datetime="2021-05-06T10:58:13+08:00">2021-05-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-07-31 18:56:53" itemprop="dateModified" datetime="2023-07-31T18:56:53+08:00">2023-07-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Algo/" itemprop="url" rel="index"><span itemprop="name">Algo</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Grokking-the-Coding-Interview-Patterns-for-Coding-Questions"><a href="#Grokking-the-Coding-Interview-Patterns-for-Coding-Questions" class="headerlink" title="Grokking the Coding Interview: Patterns for Coding Questions"></a>Grokking the Coding Interview: Patterns for Coding Questions</h1><p><a target="_blank" rel="noopener" href="https://www.educative.io/courses/grokking-the-coding-interview?aff=K7qB">课程原地址</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/cl2333/Grokking-the-Coding-Interview-Patterns-for-Coding-Questions">题目目录与答案 Python版</a>——完整题目目录，包含challenge。 </p>
<p><a target="_blank" rel="noopener" href="https://github.com/Huixxi/Algorithm-with-Cplusplus/tree/master/%E8%8E%B1%E7%89%B9%E6%89%A3%E7%9A%84-%E7%B3%BB%E5%88%97">题目目录与答案 C++版(附题目OJ的地址)</a>——推荐用OJ测试自己的算法，但是这个repo里基本没有challenge题目。</p>
<h2 id="1-Pattern-Sliding-Window"><a href="#1-Pattern-Sliding-Window" class="headerlink" title="1. Pattern: Sliding Window"></a>1. Pattern: Sliding Window</h2><h3 id="Maximum-Sum-Subarray-of-Size-K-easy-–-GeeksforGeeks"><a href="#Maximum-Sum-Subarray-of-Size-K-easy-–-GeeksforGeeks" class="headerlink" title="Maximum Sum Subarray of Size K (easy) – GeeksforGeeks"></a><a target="_blank" rel="noopener" href="https://www.geeksforgeeks.org/find-maximum-minimum-sum-subarray-size-k/">Maximum Sum Subarray of Size K (easy) – GeeksforGeeks</a></h3><p>k长的<strong>连续子序列</strong>，使该子序列和最大，这个和为output。<br>窗口长度都固定了，只需在遍历一遍时加后一个减前一个就行了，O(n)。</p>
<h3 id="Smallest-Subarray-with-a-given-sum-medium-–-LeetCode"><a href="#Smallest-Subarray-with-a-given-sum-medium-–-LeetCode" class="headerlink" title="Smallest Subarray with a given sum (medium) – LeetCode"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/minimum-size-subarray-sum/">Smallest Subarray with a given sum (medium) – LeetCode</a></h3><p>注意读题，nums都是正整数，target也是正整数。这个条件大概率需要用到。</p>
<p>假设有一段连续子序列了，它已经&gt;=target了，就不需要再继续加入元素了（序列外右边第一个元素），因为再加的话size就变大了。而这个size可以向右横移一格，可以立马算出新的sum（这里很节约时间，降低算法复杂度）。</p>
<p>这个sum如果 &gt;= target，那么它就有机会再小一点，而这一次需要的是减去序列内的第一个元素，可以理解为“收缩窗口”。<br>这个sum如果 &lt; target，那就可以再向右横移了，因为size扩大，对结果没有任何帮助。</p>
<p>总体看下来，只要横移和收缩，算法复杂度是O(n)。</p>
<h4 id="初步思路"><a href="#初步思路" class="headerlink" title="初步思路"></a>初步思路</h4><p>初步思路是，先算个nums[0…x]之和 &gt;= target的窗口，然后这个窗口开始向右移并尝试收缩。但其实不对，因为第一个窗口，不是非得从第0个元素开始，这个窗口自身就应该尝试收缩。这个逻辑补上后是能ac的。<br>不过，初步思路翻译为代码，还是有些小坑，肉眼很难查。建议背一个滑动窗口模板。</p>
<h4 id="滑动窗口模板思路"><a href="#滑动窗口模板思路" class="headerlink" title="滑动窗口模板思路"></a>滑动窗口模板思路</h4><p>此思路最核心的思想就是，不强求窗口横移，反正先向右扩展1个，再左边收缩一个，就达到了横移。<br>因此滑动窗口的头尾都可以移动，而且是分别移动，用两个变量来表示，（start，end）。<br>因为收缩（start向右移）和扩展（end向右移）可以各做各的，所以没必要先找到一个总和 &gt;= target的初始窗口了。</p>
<p>所以，步骤可以化简为，<strong>每一次都扩展1下，然后尽力收缩</strong>（while不定次收缩）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">while end &lt; n:</span><br><span class="line">    tmp_sum += nums[end]</span><br><span class="line">    while tmp_sum &gt;= target:</span><br><span class="line">        win_size = min(win_size, end-start+1)</span><br><span class="line">        tmp_sum -= nums[start]</span><br><span class="line">        start += 1</span><br><span class="line">    end += 1</span><br></pre></td></tr></table></figure>

<p>至于几个变量的初始值，现场推理一下也可以得到，不做赘述。<br>P.S. win_size没必要用int的max，用len(nums)+1就可以了，反正都是不可能的值。</p>
<h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><p>滑动窗口的算法，nums就算有负数也无所谓。（被烟雾弹迷惑🐶）这个条件大概是为“前缀和”这一方法准备的。</p>
<p>前缀和方法，简单来讲就是nums[0..i]之和组成一个sum数组，这个数组严格递增，都不存在相等的元素。</p>
<p>然后就可以用二分来找了（看到有序就要想到二分），当前sum[i]为0到i元素的和，<code>sum[j] - sum[i] &gt;= target</code>转换为<code>sum[j]&gt;=target+sum[i]</code>，那么就是在sum数组里找<code>target+sum[i]</code>的lower bound。</p>
<p>为什么不是以j为结尾，<code>sum[j] - sum[x] &gt;= target</code>转换成<code>sum[x] &lt;= sum[j]-target</code>，找sum[x]呢？因为是upper bound（第一个&gt;某值的元素）的前一个（必定&lt;=某值），不如直接找lower bound简洁，而且不用处理减出负数的情况。</p>
<h3 id="Longest-Substring-with-K-Distinct-Characters-medium-google-–-LintCode"><a href="#Longest-Substring-with-K-Distinct-Characters-medium-google-–-LintCode" class="headerlink" title="Longest Substring with K Distinct Characters (medium, google) – LintCode"></a><a target="_blank" rel="noopener" href="https://www.lintcode.com/problem/longest-substring-with-at-most-k-distinct-characters/description">Longest Substring with K Distinct Characters (medium, google) – LintCode</a></h3><p>Given a string, find the length of the longest substring in it with no more than K distinct characters.</p>
<p>也就是LeetCode340题 Longest Substring at Most K Distinct Characters。</p>
<p>这道题输出是最长子串的长度，所以显然可以套用滑动窗口的模板。和上一个题目一样，都是扩展会使得条件不符，要通过收缩来满足条件。<br>即，窗口扩展一旦字符种类超过k，就可以通过窗口收缩来削减字符种类。<br>唯一不同的点是：update longest string的时机（其实就是用end-start+1来尝试更新记录的longest）<br>因为while distinct_count(dict) &gt; k时是去收缩，break while时说明distinct_count(dict) 已经&lt;=k了，这个时候的[start, end]才是一个可能解，符合条件的可能解。<br>所以update longest string len是在while循环外，而且是之后。<br>至于如何实现dict和distinct_count，随便吧，简单也好，高效也好。</p>
<p>P.S.注意到了吗，这个题目和前面一题Smallest Subarray的区别？</p>
<p>看不出来也正常，我做了几道题才突然回头发现的😂而且明明之前做过笔记，重蹈覆撤🙄️</p>
<p><del>果然人类的本质都是复读机</del></p>
<p>这个题已经开始了longest之路，也就是说，只是想求一个最长的长度，根本不在意“重复无意义的更新”。</p>
<p>按之前的模板，此题的伪代码应写为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">while end &lt; n:</span><br><span class="line">    dic[s[end]]+=1</span><br><span class="line">    while len(dic)&gt;k:</span><br><span class="line">        dic[s[start]]-=1</span><br><span class="line">        if dic[s[start]]==0:</span><br><span class="line">            del dic[s[start]]</span><br><span class="line">        start+=1</span><br><span class="line">    longest = max(longest, end-start+1)</span><br><span class="line">    end+=1</span><br></pre></td></tr></table></figure>

<p>这样的写法，保证了longest变量更新时，当前窗口都是len(dic)&lt;=k的，也就是合法的情况。但确实可能会出现窗口被收缩的很小的时候（为了合法），此时max更新也是白干的（longest还是原值）。</p>
<p>而如果代码将内层while变为if：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">while end &lt; n:</span><br><span class="line">    dic[s[end]]+=1</span><br><span class="line">    if len(dic)&gt;k:</span><br><span class="line">        dic[s[start]]-=1</span><br><span class="line">        if dic[s[start]]==0:</span><br><span class="line">            del dic[s[start]]</span><br><span class="line">        start+=1</span><br><span class="line">    longest = max(longest, end-start+1)</span><br><span class="line">    end+=1</span><br></pre></td></tr></table></figure>

<p>自然，在longest更新时，当前窗口可能都还满足条件，不合法，但仍旧去做了一次longest的更新。但从数值上来讲，由于不满足条件会被收缩一次，加上前面的end扩展一次，窗口等于做了一次平移。那么end=start+1的值就不会变大，longest的更新自然也是不会有实际作用的。</p>
<p>这一个改动，它到底好在了哪里呢？光看经过，start，end两个游标都是单向前进的，2-while和while-if都不会使两个游标左右飘。但由于2-while会保证每次窗口都是合法的，和while-if相比，start这个游标可能会更靠右。举个极端例子，如果longest是[0, n-2]这个窗口，下一次扩展end就会到末尾n-1，while-if此时发现窗口不合法，收缩一次，就溜了。而2-while，会愣是要求[start, n-1]窗口合法，可能start从0不断右移，直到n-1才停止。无用操作在这个例子就占了一半。具体例子就是AAAAB, k =1。</p>
<p>这个优化并不容易读，我也不建议平时代码搞这么tricky。在这个题目里，仅仅在节省len查询和dict更新，都是较高效的操作，而且有次数上限（由于start标最多都走到末尾，操作次数最多n次）。优化效果仅仅锦上添花。但这个将while改为if，在其他题目中可能有奇效。因为while的判断条件如果复杂度较高，这里的收益就很大了，见Longest Substring with Same Letters after Replacement一题。</p>
<h3 id="Fruits-into-Baskets-medium-–-LeetCode"><a href="#Fruits-into-Baskets-medium-–-LeetCode" class="headerlink" title="Fruits into Baskets (medium) – LeetCode"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/fruit-into-baskets/">Fruits into Baskets (medium) – LeetCode</a></h3><p>跟上题一模一样。题目暗示着连续区间，就可以尝试滑动窗口方法。</p>
<p>但这一题case比上一题的规模大，最简单的dict实现（不及时删除value为0的项，每次都要遍历得到distinct count）这种方法就超时了。还是推荐及时删除value为0的项，其实比不删还简单，因为删除这个操作只会在收缩时出现（只有此处count–）。</p>
<p>可优化为while-if。</p>
<h3 id="No-repeat-Substring-medium-–-LeetCode"><a href="#No-repeat-Substring-medium-–-LeetCode" class="headerlink" title="No-repeat Substring (medium) – LeetCode"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/longest-substring-without-repeating-characters/">No-repeat Substring (medium) – LeetCode</a></h3><p>和前面的题目毫无差别。</p>
<p>但注意第二层while的判断条件是什么，如果判断条件是“窗口dict的value全为1”，那么你可以改出while-if。</p>
<p>如果是“当前字符c的count&gt;1”，就改不了了。因为现在只看当前字符，那就意味着窗口必须是合法的，然后扩展，加入当前字符。while-if便不可用。</p>
<p>“只看当前字符”这种方法的优化思路是，如果start要跳，直接让start去“当前字符上一次出现的位置的右边”。 因为前面的字符都可以跳过了。还可以再化简代码，但会很难读，所以还是适合而止吧。</p>
<h3 id="Longest-Substring-with-Same-Letters-after-Replacement-medium-amazon-–-GeeksforGeeks"><a href="#Longest-Substring-with-Same-Letters-after-Replacement-medium-amazon-–-GeeksforGeeks" class="headerlink" title="Longest Substring with Same Letters after Replacement (medium, amazon) – GeeksforGeeks"></a><a target="_blank" rel="noopener" href="https://practice.geeksforgeeks.org/problems/maximum-sub-string-after-at-most-k-changes/0">Longest Substring with Same Letters after Replacement (medium, amazon) – GeeksforGeeks</a></h3><p>We have a string <strong>s</strong> of length n, which consist only UPPERCASE characters and we have a number k (always less than n and greater than 0). We can make at most k changes in our string such that we can get a sub-string of maximum length which have all same characters.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;ABAB&quot;, k = 2</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: Change 2 &#x27;B&#x27; into &#x27;A&#x27;.</span><br></pre></td></tr></table></figure>

<p><strong>Example:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;ABCD&quot;, k = 1</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: Change one &#x27;B&#x27; into &#x27;A&#x27;.</span><br></pre></td></tr></table></figure>

<p>这种要替换字符的题目，往往不用真的替换，只要数值上达到某个条件就行了。比如这个题，不用想着应该替换哪些字符，而应该想“总字符个数 - 不需要被替换的字符个数 &gt;= k”就行了。很容易想到，“不需要被替换的字符个数”就是区间内个数最多的那个字符，这样，总字符数才能多一点（对某个区间而言，不需要理会那些无意义的可能解，“保留频率最高的字符，把其他的替换为该字符”肯定是操作数最少的）。于是，替不替换的问题就化简为简单的统计问题。</p>
<p>统计问题虽然简单，但是复杂度略高。想要快速，可能需要两个map，ch-&gt;count, count-&gt;ch。所以，while-if就很适合了，由于只收缩一次，max_count就从dict里统计一次就好了，不用强求更快速。</p>
<h3 id="Longest-Subarray-with-Ones-after-Replacement-medium-–-GeeksforGeeks"><a href="#Longest-Subarray-with-Ones-after-Replacement-medium-–-GeeksforGeeks" class="headerlink" title="Longest Subarray with Ones after Replacement (medium) – GeeksforGeeks"></a><a target="_blank" rel="noopener" href="https://www.geeksforgeeks.org/longest-subsegment-1s-formed-changing-k-0s/">Longest Subarray with Ones after Replacement (medium) – GeeksforGeeks</a></h3><p>比上题更简单，只需要一个int变量就能描述一个窗口内的0的个数。</p>
<h3 id="Problem-Challenge-1-Permutation-in-a-String-hard"><a href="#Problem-Challenge-1-Permutation-in-a-String-hard" class="headerlink" title="Problem Challenge 1 - Permutation in a String (hard)"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/permutation-in-string/">Problem Challenge 1 - Permutation in a String (hard)</a></h3><p>排列，不允许多一个字符，所以窗口大小是固定的，滑动用来节省“更新窗口属性的代价”。题目如果对字符多加限制，比如此题限制只有小写字母，也就只有26个可能，其实描述窗口用长26的数组都可以，不用非要用counter。用counter有个麻烦点在于当某个字符的count为0时，你需要删掉它，不然就没法和s1的counter比大小。如果两个字符串的counter都先把26个字母的空间开出来，那还不如数组节省空间。</p>
<h3 id="Problem-Challenge-2-String-Anagrams-hard"><a href="#Problem-Challenge-2-String-Anagrams-hard" class="headerlink" title="Problem Challenge 2 - String Anagrams (hard)"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/submissions/">Problem Challenge 2 - String Anagrams (hard)</a></h3><p>和challenge1没有区别</p>
<h3 id="Problem-Challenge-3-Smallest-Window-containing-Substring-hard"><a href="#Problem-Challenge-3-Smallest-Window-containing-Substring-hard" class="headerlink" title="Problem Challenge 3 - Smallest Window containing Substring (hard) *"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-window-substring/">Problem Challenge 3 - Smallest Window containing Substring (hard) *</a></h3><p>没啥特别，就是用collections.Counter()减法，比自己写的比较函数要慢不少，1200ms vs 500ms。</p>
<h3 id="Problem-Challenge-4-Words-Concatenation-hard"><a href="#Problem-Challenge-4-Words-Concatenation-hard" class="headerlink" title="Problem Challenge 4 - Words Concatenation (hard)"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/substring-with-concatenation-of-all-words/">Problem Challenge 4 - Words Concatenation (hard)</a></h3><p>注意读题！words长度相同！匆忙读题后，我还以为要处理不同的切割方式，以为会出现“一个substring里有几种正确的word排列”。那这题可能不止hard了。</p>
<p>可以简单想到的办法就是窗口从0一直滑到尾，step为1，每一次窗口都得重新计算下word-count，然后和words参数比较。</p>
<p>显然这个没有什么巧妙点，没有节约计算量，所以想要利用滑动窗口，当然得想点骚方法。其实就是，每一次都设置一个起点，从这个起点开始，只会按词长来拓展，这样就能像字符型的题目一样，充分利用滑动窗口的扩展收缩，减少计算。举例说明，就是一个单词长度为len，s串总长为n的话，第一趟是从0开始一个len切一刀，这样切割后的串扩展和收缩都是一个词的，第二趟就是从1开始切，以此类推，最后一次是len-1开始切。可以想到，这样也是把所有可能性都考虑到了。</p>
<p>改进后的滑动窗口方法效果是明显的，1000ms到100ms。</p>
<h3 id="Additional"><a href="#Additional" class="headerlink" title="Additional"></a>Additional</h3><h4 id="Sliding-Window-Maximum-hard-–-LeetCode"><a href="#Sliding-Window-Maximum-hard-–-LeetCode" class="headerlink" title="Sliding Window Maximum (hard) – LeetCode"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/sliding-window-maximum/">Sliding Window Maximum (hard) – LeetCode</a></h4><p>这个题跟滑动窗口模板毫无关系，窗口大小都固定牢了。唯一的问题点在于用什么结构体来提炼窗口信息，既能很快查到最大值，又能在窗口滑动时很快更新好（滑动本质就是加入一个数，去掉一个数）。快速查到最大值，可以想到利用堆。但是堆有一个明显问题，就是它不适合去删除内部的某个元素（不是堆首）。而“去掉一个数”这个操作很可能就是去删除某个中间的值。堆的删除操作是个不太ok的操作，因为这个堆是简单的堆（并非压平了看，完全有序的，不是堆排序之后的结果），也就是删除操作不能快速定位到要删除的元素。</p>
<p>但是别直接放弃堆（我就放弃了，想别的方法，走远了）。这时候，尝试多推导一下，就会发现，不用着急删除元素。因为元素可以跟上自己的位置idx，如果堆顶拿到的idx已经不在窗口内，再删除也不迟。也就是延迟了删除操作，正好还让删除操作符合堆的操作习惯，只删堆顶。</p>
<p>到这里，起码算是题目做出来了，而且这个方法也不差，能交差。</p>
<p>但这道题更想考的点是别的，所以还需要再优化。说是优化，不如说是换了解法。从堆想到单调队列，反正我是做不到。。。</p>
<p>单调队列是什么东西？先记住它能够动态地维护定长序列中的最值。所以只要定长、最值，就可以想到尝试单调队列。具体来讲，单调队列是，push元素前会把前面的元素都从后往前访问一遍（遇到比自己大的停止），比当前元素小的都删除，再将元素放在队尾。其实，全访问也没关系，最后结果没有差别，不过，遇到比自己大的就停止可以节省点时间。最后的结果就是队列里头到尾是从大到小有序的。</p>
<p>举例说明(为了多点情况，和leetcode原例子有差别)：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nums = [1,3,-1,-3,-2,3,6,7], k = 3</span><br></pre></td></tr></table></figure>

<p>单调队列应该长什么样？</p>
<p>[1,3,-1]初始窗口入队列后，q=[3,-1]，那么这个窗口的最值就是3；</p>
<p>[3,-1,-3], q=[3,-1,-3]，最值还是3；</p>
<p>[-1,-3,-2], q=[3,-1,-2]，最值3，但3已经不在窗口内，所以pop，q=[-1,-2]，最值-1；</p>
<p>[-3,-2,3], q=[3]，最值3；</p>
<p>[5,3,6], q=[6]，最值6；</p>
<p>[3,6,7], q=[7]，最值7。</p>
<p>可以看到，只用进行简单比较，就能维持着最值，比堆的时间复杂度低。</p>
<p>单调队列它为什么做到了呢？</p>
<p>可以这么想，首先简单起见，只考虑窗口内元素的单调队列情况，比如3,1,2序列，k=3，很明显1会在2进入时被扔掉，因为2进入了之后，怎么也是2比1晚出窗口，就算可能是最大值，也是2可能，1是完全没有可能竞争最大值的。</p>
<p>再考虑队列前部还有窗口外元素的情况，窗口外的元素还留在队列里（可以称为过期元素），也就是说窗口内的单调队列最大值（也就是队列列首）比过期元素小。但这并不影响窗口元素那部分的选择，无论有没有过期元素，窗口那部分的单调队列都长一个样。所以过期元素可以简单地pop出来扔掉。</p>
<p>总的来说，单调队列就是剔除了“必然不能争最大值”的那部分无用值。单调队列实现上没有什么难度，不再赘述。</p>
<p>P.S. Python实现遇到超时问题，因为我没有用pop，而是选择到一个点，取出切片[:x]，然后又append。具体细节待调查。从耗时来看，很明显这一连串操作应该搞出了deep copy之类的耗时操作。都叫单调队列了，就好好用python collections里的deque。</p>
<h4 id="Shortest-Subarray-with-Sum-at-Least-K-hard-–-LeetCode"><a href="#Shortest-Subarray-with-Sum-at-Least-K-hard-–-LeetCode" class="headerlink" title="Shortest Subarray with Sum at Least K (hard) – LeetCode"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/shortest-subarray-with-sum-at-least-k/">Shortest Subarray with Sum at Least K (hard) – LeetCode</a></h4><p>仔细读题，这个题的数组里有负数。滑动窗口的算法模板是没办法直接套用的，因为窗口收缩的停止条件是sum &lt; k，由于有负数，你不能在窗口sum &lt; k时停止，你必须继续收缩，否则就可能错过解。</p>
<p>停留在滑动窗口算法模板这个框架里，是没办法找到解法的。</p>
<p>这时候<del>只能躺平</del>。</p>
<p>只能说先回答个O(n^2)的解法吧，聊胜于无。很明显，所有区间和都是可能的最佳答案，所以前缀和加<strong>二级遍历</strong>所有区间，能得到答案。</p>
<p>当然可以优化，但是很难凭空想出来参考答案“单调队列”。接下来的说明是以知道“前缀和+单调队列是较好解法”为前提来看这个题目，所以没有什么顺理成章推导，全凭参考答案提示。</p>
<p>单调队列维护什么？</p>
<p>题目核心是求最短的合法子串，所以短是最核心的，和只要&gt;=k什么都行。那么假设当前看i，以i开头的最佳子串，当然是从i开始寻找第一个j，能使sum[i..j]&gt;k（前缀和数组里两个数减一下就好了）。j之后的都不用找了，没有比i到j更短的了。那么反过来思考，从i到j，中间可能有多个值，一一遍历就是暴力解法，优化当然是更快找到j，那么如何迅速定位到j呢？</p>
<p>或者换个说法，i到j中间的多个可能性，有哪些是必然不可能的，可以直接过滤？答案是没得😛。因为如果从[i, n)区间提取出单调递增的部分，可以使用二分，但这个题应该用不着。那这个思路还有什么优势呢？我们一一遍历到j，然后得到这个i的最优解，然后i++，然后你还是得遍历过去，因为单调递增队列本身不能有更多的改动，最多把队列头比i小的pop出来。那换个角度，递增队列是不是能从后往前看，当某个靠后的j满足了条件，你能把它怎么样？你不能动它，因为接下来的i（更大的i）和j一起也能满足条件，这个窗口长度肯定比现在的短，你删了这个j，就丢掉了解。</p>
<p>那么就应该考虑换个顺序，以当前j为标杆，去找前面的i，它有个什么好处呢？当你从前往后找i，某个i满足条件后，你可以大胆删了它，因为j会++，当前的i充分发挥价值（用来更新window len）后，就不需要了，后面的j和这个i组合是无意义的。</p>
<p>P.S. 我想到了以j找i，但又想的是从j-1往0这个方向找，想想看，跟以i找j没什么差别，它们跟暴力解法比，完全不是稳定降低复杂度，甚至可以劣到没区别。（于是Python实现也完美超时了）</p>
<p>总的看“前缀和+单调队列”，大概的最好状态是每次O(1)，然后n个j，所以O(n)，比如，每次看队列头d[0]的preSum都很大，不能让preSum[j]-preSum[d[0]]&gt;=k，单调递增的d后面的元素也不能满足要求了，所以每次就立马完成。最差的状态可能是某次j，从0到j遍历，每次都符合条件，都要pop并更新window len。但很明显，队列最多跟n一样长，而且pop出去了又不会回来，所以次数最多n次，并不会膨胀。所以总的复杂度还是O(n)的。</p>
<p>这道题还是很难的，难在拼出正确的方法，知道方法后，代码实现不难。</p>
<h4 id="Max-Consecutive-Ones-III"><a href="#Max-Consecutive-Ones-III" class="headerlink" title="Max Consecutive Ones III"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/max-consecutive-ones-iii/">Max Consecutive Ones III</a></h4><p>突如其来的一道复习题。while-if即可，虽然和while-while实测没什么区别，大概是case的原因。</p>
<h4 id="Replace-the-Substring-for-Balanced-String-medium-–-LeetCode"><a href="#Replace-the-Substring-for-Balanced-String-medium-–-LeetCode" class="headerlink" title="Replace the Substring for Balanced String (medium) – LeetCode"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/replace-the-substring-for-balanced-string/">Replace the Substring for Balanced String (medium) – LeetCode</a></h4><p>题目是说要替换的字符包含在一个子串里，要求子串最短，子串符合某个条件即可，那就很适合套用滑动窗口模板了。</p>
<h4 id="Count-Number-of-Nice-Subarrays-medium-–-LeetCode"><a href="#Count-Number-of-Nice-Subarrays-medium-–-LeetCode" class="headerlink" title="Count Number of Nice Subarrays (medium) – LeetCode"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/count-number-of-nice-subarrays/">Count Number of Nice Subarrays (medium) – LeetCode</a></h4><p>这题一看就不适合立马套用模板，扩展和收缩求最长最短很有效，但这里没有用处。举例说明，当我们找到一个窗口恰好有k个奇数，此时可以滑动窗口么？当然不能。所以放弃吧。然后考虑到奇数是核心，先找到k个奇数的最小可能，它的左右两边如果分别有a个偶数和b个偶数，那么这里就有很多个子串可能，1+a+b+a*b。而找奇数，可以直接抽出奇数，这样奇数数组里每k个就是一个base，延展下两边的偶数。既没有重复也不会漏算。</p>
<p>滑动窗口完结撒花🎉</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://vagetablechicken.github.io/2021/03/22/leetcode-roadmap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Huang Wei">
      <meta itemprop="description" content="Coding, Struggling, and Living.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wei">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/22/leetcode-roadmap/" class="post-title-link" itemprop="url">leetcode-roadmap</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-03-22 20:15:54" itemprop="dateCreated datePublished" datetime="2021-03-22T20:15:54+08:00">2021-03-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-07-31 18:56:53" itemprop="dateModified" datetime="2023-07-31T18:56:53+08:00">2023-07-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Algo/" itemprop="url" rel="index"><span itemprop="name">Algo</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>推荐站点：</p>
<p><a target="_blank" rel="noopener" href="https://qoogle.top/xiaoxu-explaination-leetcode/">https://qoogle.top/xiaoxu-explaination-leetcode/</a></p>
<p><a target="_blank" rel="noopener" href="https://codetop.cc/">https://codetop.cc/</a> </p>
<h1 id="https-codetop-cc-微软"><a href="#https-codetop-cc-微软" class="headerlink" title="https://codetop.cc/ 微软"></a><a target="_blank" rel="noopener" href="https://codetop.cc/">https://codetop.cc/</a> 微软</h1><h2 id="227-基本计算器-II-2012-03-22-23"><a href="#227-基本计算器-II-2012-03-22-23" class="headerlink" title="227. 基本计算器 II 2012/03/22-23"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/basic-calculator-ii/">227. 基本计算器 II</a> 2012/03/22-23</h2><p>这道题，用栈是最快速的，可以现场推理思路，完成80%应该不是问题。<br>但这种表达式，很可能会被考变种，比如加了括号，加了UnaryOp，甚至更难。<br>括号，UnaryOp或是自定义函数，这几类还是可以通过少量修改代码支持。但要能做到像高级计算器一样的，抵抗各种灵活拷问，我目前知道的万能方法就是，编译器的基本思路，也就是词法-解析-翻译，这种流程。毕竟我们使用的编译器就是这个思路，没有比这个更完善的了。</p>
<p>当然，编译器思路不好写。总结来说，基本思路需要Lexer，Interpreter。如果Token过于复杂，最好加个Parser，Parser解析出AST，Interpreter再遍历AST树，计算结果。</p>
<p>面试时使用这个思路，写代码会慢一点，但是比栈思路，更深更硬核。</p>
<h3 id="双栈思路"><a href="#双栈思路" class="headerlink" title="双栈思路"></a>双栈思路</h3><p>一个栈存操作符Op，一个栈存数字Int。双栈思路的核心就是“先算乘除”，所以扫描处理完整个表达式后，Op栈里应该只有加减号，没有乘除号。</p>
<p>但还有一个点要考虑，就是Op里已有+号，此时你扫描到了新的+号，要怎么做？</p>
<p>如果将栈中的+号及时处理了（也就是同优先级优先计算前面的符号），那么整个表达式算完，就只有一个加号或减号，没什么问题。</p>
<p>如果选择了加减号不先算，直接放栈里，就需要注意，之后的计算顺序。举例说明，一个复杂的表达式化简成只剩加减号时，可能是1-2-3，这时候Op栈是“-，-”，Int栈是“1，2，3”，不能再使用栈的pop，那样就变成了1-(2-3)，得用list/vector的顺序计算。<br>（我临时推理时用了这个思路，大概率以后还会这么干😅。我习惯思维是只push进栈，不爱随时pop，最后会统一pop出来计算。大概是觉得这种流程，代码会比较好看。）</p>
<p>还是推荐大家尽量改善自己的思路，选择第一种方式，以免现场推理出来的逻辑不够完备。</p>
<h4 id="单栈"><a href="#单栈" class="headerlink" title="单栈"></a>单栈</h4><p>Leetcode官方题解其实是单栈，但如果你亲手写了双栈，你一定会感受到，如果及时计算同优先级的运算符，Op栈最多只会有一个运算符（+/-号），所以不需要栈，一个变量就能保存了。这就是单栈思路，没什么特别。</p>
<h4 id="边界"><a href="#边界" class="headerlink" title="边界"></a>边界</h4><p>栈的大体思路都是如此，如果加入括号或是其他二元运算符，都还能work。加入括号的话，请一定要用第一种方式😂，处理起来方便很多，不然思路容易卡住。</p>
<p>如果加入UnaryOp正负号，尤其是负号，也就是说leetcode 227题的表达式中的整数不保证是非负整数，又需要一次变化。巧妙的思路是给“-”打头的表达式开头添“0”，变成“0-正整数”。将所有”(-“替换为”(0-“，用字符串replace，还可以不用改变算法主体代码，很简单。<br>而如果还加正号，比如“3++4”合理，这种情况就比有负数的情况还要麻烦了。这要求你的算法能，判断第二个+号是和整数结合的正号（Unary Plus）。再扩展下，“3–++2”等等。代码上就得增加一段逻辑，来处理好UnaryOp。这样当然可以work，但是这也暴露了栈思路的一个问题，就是它没有符合逻辑的解析能力。它似乎只是我们在努力的修补规则，“3–++2”是读取了“3-”后发现还是符号，才会开始解释为一元符号，从左到右计算到底是正号还是负号。但按照逻辑，我们应该是将表达式看作3-(-(+(+(2))))，也就是，真的计算的时刻，2是和前面的正负号结合，然后作为整体又跟前面的正负号结合。也就是解析是顺序，计算是倒序，有种递归下降，然后逐层返回结果的感觉。</p>
<p>其实没什么差别，但是我个人觉得，栈的思路是有些勉强的。因此，当学了一点点编译原理后，我就想用编译的思路来解决这道题了。</p>
<h4 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h4><p>所有计算器题目，都总结下。</p>
<ol start="224">
<li><p>双栈，加减括号，注意允许(+4)这种写法出现，但不用考虑1++2。</p>
</li>
<li><p>双栈，加减乘除，无括号，不用考虑(+4)或一元运算符的情况。</p>
</li>
<li><p>基本计算器 IV，只可能使用编译器思路来解决了，而且还要能处理变量。</p>
</li>
</ol>
<h3 id="编译器思路"><a href="#编译器思路" class="headerlink" title="编译器思路"></a>编译器思路</h3><p>编译器思路，自然是难的，写起来也不够快。但是学习编译器基本原理，我觉得是有意义的，因为底层到程序编译，稍高层的SQL解析，都是这套思路。Parser，Token，blabla。</p>
<ul>
<li><input disabled="" type="checkbox"> 细节，新开一页讲，也可看<a target="_blank" rel="noopener" href="https://ruslanspivak.com/lsbasi-part1/">https://ruslanspivak.com/lsbasi-part1/</a> 一步一步跟着做</li>
</ul>
<p>简单来说，就是用代码实现几行范式。加入新的符号，就修改范式。</p>
<p>比如，只有加减乘除：</p>
<p><img src="https://ruslanspivak.com/lsbasi-part5/lsbasi_part5_grammar.png"></p>
<p>加入括号(LPAREN,RPAREN)：<br><img src="https://ruslanspivak.com/lsbasi-part6/lsbasi_part6_grammar.png"></p>
<p>再加入一元运算符（正负号）：<br><img src="https://ruslanspivak.com/lsbasi-part8/lsbasi_part8_grammar.png"></p>
<p>Parser/Interpreter实现这几条规则就可以了。</p>
<h2 id="91-解码方法-2021-03-24-25"><a href="#91-解码方法-2021-03-24-25" class="headerlink" title="91. 解码方法 2021/03/24-25"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/decode-ways/">91. 解码方法</a> 2021/03/24-25</h2><p>需要注意dp访问越界的问题。<br>通常dp[i]负责看第i个元素（索引其实是i-1），就可以保护住需要访问dp[i-1]的dp公式，因为计算dp数组是i从1开始，dp[0]不会越界。<br>如果dp公式有dp[i-2]，不要慌，dp[1]特殊处理后，dp[2]开始又可以通用处理了。</p>
<h2 id="124-二叉树中的最大路径和-2021-03-26"><a href="#124-二叉树中的最大路径和-2021-03-26" class="headerlink" title="124. 二叉树中的最大路径和 2021/03/26"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/">124. 二叉树中的最大路径和</a> 2021/03/26</h2><ul>
<li><input disabled="" type="checkbox"> wait zx</li>
</ul>
<h2 id="224-Basic-Calculator-2021-03-31-04-03"><a href="#224-Basic-Calculator-2021-03-31-04-03" class="headerlink" title="224. Basic Calculator 2021/03/31-04/03"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/basic-calculator/">224. Basic Calculator</a> 2021/03/31-04/03</h2><p>s consists of digits, ‘+’, ‘-‘, ‘(‘, ‘)’, and ‘ ‘.</p>
<p>227类型的题。这个版本由于没有乘除，用Lexer+Interpreter的版本，范式也不难写。</p>
<ul>
<li><input disabled="" type="checkbox"> TODO 写一下范式</li>
</ul>
<p>当然更简单的，还是可以使用双栈。</p>
<p>而且建议只记忆双栈，<strong>不用去记一些扩展性不够高的思路</strong>。</p>
<p>注意，test case有”1-(+1+1)”这种。虽然不用考虑1+-1这种写法，但’(‘号后跟’+/-‘号是要被考虑的。<br>因此是基本的双栈思路，加过滤空格，再加处理’(+/-‘。</p>
<p>具体说下双栈思路。</p>
<p>首先，框架是逐个字符扫描，但考虑到数字可能是多位，所以最方便的做法应该是<code>while i &lt; len(s):</code>，解析数字时i可能会多加点，其他符号只需+1。</p>
<p>再是每个字符c可能是些什么，各自需要如何处理。如果没什么印象，建议逐个分析，有需要的再合并，想不清楚，直接逐个if-else都行，总比写错了强。<br>所以，逐个看待，伪代码写作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">if c is space:</span><br><span class="line">    pass</span><br><span class="line">elif c is digit:</span><br><span class="line">    # func parse_int TODO</span><br><span class="line">    num = parse_int()</span><br><span class="line">    # TODO calc or push to nums?</span><br><span class="line">elif c is &#x27;(&#x27;:</span><br><span class="line">    # TODO handle &#x27;(+/-&#x27;</span><br><span class="line">    push to ops queue</span><br><span class="line">elif c is &#x27;)&#x27;:</span><br><span class="line">    # ops top is &#x27;(&#x27;</span><br><span class="line">    ops pop</span><br><span class="line">    num = nums.pop()</span><br><span class="line">    # TODO calc or push to nums?</span><br><span class="line">elif c is &#x27;+&#x27; or &#x27;-&#x27;:</span><br><span class="line">    push to nums queue</span><br></pre></td></tr></table></figure>

<p>上面就是最详细的分支情况，由于没有乘除，所以分支数量也没什么可以优化的点。注意我写的TODO，基本都应该封装为一个函数，以免主逻辑太难读，给自己增加难度。</p>
<p>特别的，<code>calc or push to nums</code>是最需要注意的一个地方，明显的，两个分支都用到这一逻辑，封成函数是最好的，我命名为<code>calc_with()</code>。</p>
<p>而这个数什么时候用来计算，什么时候直接push进栈呢？</p>
<p>举例分析，我想把nums栈顶top和现有的num拿来计算，那么ops栈顶当然得是+/-号，如果栈顶是’(‘，那自然不该算。只需要考虑这一个条件。</p>
<p>如果不计算，直接push。如果pop栈顶计算了一次，之后的结果，该如何处理？</p>
<p>很容易想到，这个结果，还是应该push进栈。但还是应该多思考一下，有没有什么坑？</p>
<p>这一点可能有点不直观，但你可以手写推理或者debug代码测试，就会知道，<code>calc_with()</code>总是在尽力地合并，只有遇到’(‘才会无法合并，导致nums和ops栈多增一个元素。</p>
<p>简单起见，假设只有+号没有-号，某个时刻的栈只能是<code>+(+((+</code>，不会有<code>++(++(++</code>。</p>
<p>假设此时ops栈为<code>+(+((+</code>,现有num，ops栈pop出+号，再nums栈里pop一个数num1，计算出结果res，这个res push回nums栈是合理的。无论后面跟什么符号，都能正确处理。</p>
<h2 id="770-基本计算器-IV"><a href="#770-基本计算器-IV" class="headerlink" title="770. 基本计算器 IV"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/basic-calculator-iv/">770. 基本计算器 IV</a></h2><p>这个题太长了，看的人头皮发麻。但是抽象一下，就能发现，它实际上难点在于括号展开。因为我们已有的知识已经能把一个有括号的表达式解析出来了，可以转成AST树，也可以在解析parse时及时计算。但是，没有包含过“括号展开”的逻辑。</p>
<p>简单的想一下，AST树完全不知道该怎么去实现括号的展开，所以pass。</p>
<p>所以就考虑下parse时及时计算的时候能不能加上“括号展开”。</p>
<p>parse时，可以知道pre_calc * new term的，具体2 * (a-b)，new term为(a-b)，之前的计算结果为2（简单起见，用数字举例）。</p>
<p>接下来，该怎么做？</p>
<p>应该做到拆出2 * a-2 * b。这一步即括号展开，是此题的核心。题目也暗示了可以理解为2 * a与-2 * b两项，那么也就是2要跟（1 * a)和(-1 * b)都分别乘一下。代码上其实就是for循环。当然(a-b)这个factor得拆成一个数组（2个元素，a和-b）。还需要拆成系数和word，那系数和word怎么对上号呢？</p>
<p>考虑到2 * a + 1 * a能合并为3 * a，主要功劳是在word上，所以以word为key，系数为value是很合适的。</p>
<p>所以可以用dict，{a: 1, b: -1}这样来表示。</p>
<p>再进一步完善，如果是(c * d - 2 * f) * (a - b)，那pre_calc，即(c * d - 2 * f)，也得用dict来表示。其实pre_calc没有什么特别，就是一个factor，无论是一个数，还是圆括号扩起来的长表达式。所以用一样的规则，{c*d: 1, f: -2}，很通用，也合理。</p>
<h3 id="整理思路"><a href="#整理思路" class="headerlink" title="整理思路"></a>整理思路</h3><ul>
<li><input disabled="" type="checkbox"> TODO 写出范式</li>
</ul>
<p>也就是说，每个factor（不可再拆分的元素）都可以用一组kv来表示，也就是一个dict。一个term是多个dict合并，最终可以得到1个dict（遍历所有dict，体现加法，因为负号作为系数去了，所以可以当作只有加法）。</p>
<p>term和term之间的乘法，也就是dict和dict组合出一个新的dict（二维for循环，体现乘法）。从左到右一个一个组合，最后得到一个dict，即为最后结果。</p>
<h2 id="剑指-Offer-40-最小的k个数"><a href="#剑指-Offer-40-最小的k个数" class="headerlink" title="剑指 Offer 40. 最小的k个数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/">剑指 Offer 40. 最小的k个数</a></h2><p>TopK，面试时也遇到过，我认为heap K最稳定，但面试官更希望我用快排思想，虽然快排思想有一定几率会很慢–最坏O(n^2)。除了复杂度，实际运行，由于现代计算机架构，inner loop可以很快，见<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/zh-cn/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F">wiki</a>。具体的复杂度算法也可以看wiki。不要仅考虑理论复杂度。</p>
<p>不过有个点，我也不知道是不是记错了，面试官当时可能说c++ stl的paritial_sort是快排思想，但实际paritial_sort就是先构建k大小的堆，然后把剩下的都和堆顶比。nth_element才是快排的思路。</p>
<p>核心快排思路见 <a href="/2022/10/07/abs-algo/" title="Quick Sort">Quick Sort</a>。</p>
<p>最小k个、最大k个，第k大，第k小问题底层都是一样的，快排，变换一下都可以变为“左边&lt;=，pivot，右边&gt;=”这样的格式。类似golang或stl里，pred作为参数传入。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://vagetablechicken.github.io/2021/01/08/bookmark/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Huang Wei">
      <meta itemprop="description" content="Coding, Struggling, and Living.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wei">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/08/bookmark/" class="post-title-link" itemprop="url">Bookmarks</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-01-08 16:35:53" itemprop="dateCreated datePublished" datetime="2021-01-08T16:35:53+08:00">2021-01-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-07-31 18:56:53" itemprop="dateModified" datetime="2023-07-31T18:56:53+08:00">2023-07-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/tool/" itemprop="url" rel="index"><span itemprop="name">tool</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Bookmarks"><a href="#Bookmarks" class="headerlink" title="Bookmarks"></a>Bookmarks</h1><p>C &amp; Go 对照表：<a target="_blank" rel="noopener" href="https://hyperpolyglot.org/c">https://hyperpolyglot.org/c</a></p>
<p>vim等使用方法快查：<a target="_blank" rel="noopener" href="https://hyperpolyglot.org/text-mode-editors">https://hyperpolyglot.org/text-mode-editors</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://vagetablechicken.github.io/2021/01/07/java-string-charset/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Huang Wei">
      <meta itemprop="description" content="Coding, Struggling, and Living.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wei">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/07/java-string-charset/" class="post-title-link" itemprop="url">JAVA String Charset</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-01-07 16:25:05" itemprop="dateCreated datePublished" datetime="2021-01-07T16:25:05+08:00">2021-01-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-07-31 18:56:53" itemprop="dateModified" datetime="2023-07-31T18:56:53+08:00">2023-07-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/programming/" itemprop="url" rel="index"><span itemprop="name">programming</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="JAVA-String-Charset"><a href="#JAVA-String-Charset" class="headerlink" title="JAVA String Charset"></a>JAVA String Charset</h1><p>JAVA的String使用上一般不会考虑到编码字符集的问题，即encode charset。但如果出现数据交互，就需要考虑了，因为不同环境就可能存在差别。如果编码对不上，可能会出现乱码。JAVA中我经常见到的是<code>?</code>乱码（多个问号），不排除其他可能。</p>
<h1 id="An-Example"><a href="#An-Example" class="headerlink" title="An Example"></a>An Example</h1><p>host A用utf-8编码<code>String</code>，以<code>byte[]</code>形式发送到host B，如果host B只简单的用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new String(receivedBytes)</span><br></pre></td></tr></table></figure>
<p>来转成String使用，这里使用的charset就是default charset。</p>
<blockquote>
<p>The Java platform depends heavily on a property called the default charset. The Java Virtual Machine (JVM) determines the default charset during start-up.</p>
</blockquote>
<p>可以用下面的方法测试出当前平台的default charset。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Charset.defaultCharset().displayName();</span><br></pre></td></tr></table></figure>
<p>我个人的jvm default charset是<code>US-ASCII</code>，所以不设置String的charset就出现乱码。</p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><ol>
<li><code>new String</code>时指定charset</li>
<li>修改JVM的default charset，方法自行搜索</li>
</ol>
<h1 id="Further"><a href="#Further" class="headerlink" title="Further"></a>Further</h1><p>即使String的编码正确了，也不代表console output或output file就不会乱码。涉及了多个模块，可能需要更多的配置，请随机应变。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://vagetablechicken.github.io/2021/01/06/build-hexo/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Huang Wei">
      <meta itemprop="description" content="Coding, Struggling, and Living.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wei">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/06/build-hexo/" class="post-title-link" itemprop="url">Hexo</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-01-06 11:18:37" itemprop="dateCreated datePublished" datetime="2021-01-06T11:18:37+08:00">2021-01-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-09-07 09:48:30" itemprop="dateModified" datetime="2023-09-07T09:48:30+08:00">2023-09-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/build/" itemprop="url" rel="index"><span itemprop="name">build</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h1><p>Hexo的创建使用不多赘述。注意，先搞清楚hexo是否满足书写要求，可能你需要的是sphinx。</p>
<h2 id="With-github"><a href="#With-github" class="headerlink" title="With github"></a>With github</h2><p>Hexo通过<code>hexo d</code>来发布到github，因此github中deploy到的分支是网站目录。也就是deploy后在本地可以看到的<code>.deloy_git</code>。<br>我个人使用了另一个branch来保存hexo项目的原始文件，也就是_config.yml配置，md文档等等。</p>
<h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><p>名字解释：<br><code>&lt;root&gt;</code>: 指的网页根目录，或者说是hexo deploy到的repo分支根目录。</p>
<p>Q: 遇到网站repo中路径是存在的，比如<code>&lt;root&gt;/categories/index.html</code>确实存在，但是浏览器点击却是404？<br>A: 可以自行访问尝试下<code>&lt;root&gt;/categories/</code>或者全路径，看看<code>index.html</code>是不是有问题。如果这样就能访问到正常页面，那么问题大概就是缓存了。你可以换个浏览器快速检查下，或清除该页面缓存重试下。</p>
<h3 id="附赠-chrome清除单个页面缓存"><a href="#附赠-chrome清除单个页面缓存" class="headerlink" title="附赠-chrome清除单个页面缓存"></a>附赠-chrome清除单个页面缓存</h3><p>chrome的<code>开发者工具-setting</code>中<code>Network-Disable cache(while DevTools is open)</code>，此选项打开后，在你想要调试的页面，打开开发者工具，就不会出现一些奇怪的缓存现象了。</p>
<h2 id="Hexo-cmds"><a href="#Hexo-cmds" class="headerlink" title="Hexo cmds"></a>Hexo cmds</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br><span class="line">cd &lt;blog-source&gt;</span><br><span class="line">npm install</span><br><span class="line"># if ERROR Package xxx is not installed</span><br><span class="line">npm install xxx</span><br><span class="line"></span><br><span class="line">hexo new draft &lt;draft_name&gt; # just the name, no .md</span><br><span class="line"># writing, writing, ...</span><br><span class="line">hexo publish &lt;draft_name&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo d</span><br></pre></td></tr></table></figure>

<p>If you want to delete a post, just delete it in the source folder.</p>
<p>Localhost debug way:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s --debug</span><br></pre></td></tr></table></figure>

<h2 id="Hexo-writing"><a href="#Hexo-writing" class="headerlink" title="Hexo writing"></a>Hexo writing</h2><h3 id="link-to-another-post"><a href="#link-to-another-post" class="headerlink" title="link to another post"></a>link to another post</h3><p>Ref <a target="_blank" rel="noopener" href="https://hexo.io/docs/tag-plugins.html#Include-Posts">Include Posts</a>.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% post_link 要跳转文章md文件名(不要后缀) %&#125;</span><br></pre></td></tr></table></figure>

<h3 id="pics"><a href="#pics" class="headerlink" title="pics"></a>pics</h3><p>hexo默认的图片格式不是markdown的语法，想要写md时预览，可能需要vscode安装插件Hexo Utils。<br>但有个方法可以继续用md的image格式（<a target="_blank" rel="noopener" href="https://hexo.io/docs/asset-folders#Embedding-an-image-using-markdown%EF%BC%89%EF%BC%9A">https://hexo.io/docs/asset-folders#Embedding-an-image-using-markdown）：</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm i --save hexo-renderer-marked</span><br><span class="line">npm i --save hexo-asset-link</span><br></pre></td></tr></table></figure>
<p>然后确保_config.yml中有（一般都有）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">post_asset_folder: true</span><br><span class="line">marked:</span><br><span class="line">  prependRoot: true</span><br><span class="line">  postAsset: true</span><br></pre></td></tr></table></figure>

<h2 id="NPM-install"><a href="#NPM-install" class="headerlink" title="NPM install"></a>NPM install</h2><p>如果<code>apt install npm</code>遇到gcc update-alternatives slave问题，就先把update-alternatives清理了，再添加也方便，<a target="_blank" rel="noopener" href="https://gist.github.com/ArseniyShestakov/a458b96a354014f80ab8d95676100c03">清除参考写法</a>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># cleanup</span><br><span class="line">update-alternatives --remove-all gcc</span><br><span class="line"># set one g++</span><br><span class="line">update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-9 10</span><br><span class="line"># recover</span><br><span class="line">update-alternatives --remove-all cc</span><br><span class="line">update-alternatives --remove-all c++</span><br><span class="line">update-alternatives --remove-all gcc </span><br><span class="line">update-alternatives --remove-all g++</span><br><span class="line">update-alternatives --remove-all clang</span><br><span class="line">update-alternatives --remove-all clang++</span><br><span class="line">update-alternatives --remove-all icc</span><br><span class="line">update-alternatives --remove-all icc++</span><br><span class="line">update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-8 80 --slave /usr/bin/g++ g++ /usr/bin/g++-8 --slave /usr/bin/gcov gcov /usr/bin/gcov-8 --slave /usr/bin/c++ c++ /usr/bin/g++</span><br></pre></td></tr></table></figure>
<p>slave有个好处是不怕个别版本被修改，还是建议维持这个样子。</p>
<p>但ubuntu版本早的话，node.js版本可能太低了，hexo没法用，报错：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TypeError: line.matchAll is not a function</span><br><span class="line">       at res.value.res.value.split.map.line (/root/vagetablechicken.github.io/node_modules/hexo-util/lib/highlight.js:121:26</span><br></pre></td></tr></table></figure>
<p>比如，我ubuntu20.04装的node就是10.19.0，需要12及以上的。<br>升级：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt -y install curl dirmngr apt-transport-https lsb-release ca-certificates</span><br><span class="line">curl -sL https://deb.nodesource.com/setup_12.x | sudo -E bash -</span><br><span class="line">sudo apt -y install nodejs</span><br></pre></td></tr></table></figure>

<p><code>hexo version</code>可以查到相关version。</p>
<p>然后又可能遇到<code>npm rebuild node-sass</code>很慢的问题，卡在github上下载node-sass了。可以换下源试试，<code>npm i node-sass --sass_binary_site=https://npm.taobao.org/mirrors/node-sass/</code>。socks5代理会hang up，不知道是不是暂时的不稳定。</p>
<p>node版本再升高，<a target="_blank" rel="noopener" href="https://github.com/nodesource/distributions#debian-and-ubuntu-based-distributions">https://github.com/nodesource/distributions#debian-and-ubuntu-based-distributions</a> 。</p>
<p>hexo-renderer-sass有点旧，node版本高了不行，升高sass版本就没有问题了。</p>
<p>我想要个block admonition，但没有插件能做到解析’<code>&#123;note&#125;</code>‘这种。只能改用现有语法，缺陷是vscode没法preview，只能deploy/server后看效果。最终还是决定使用hexo next主题自带的。preview的问题不大，用的频率不会太多。<br>切换sphinx有点麻烦，hexo配reStructuredText插件，例如hexo-renderer-pandoc，没成功，据说这个插件也比较大，deploy会慢。</p>
<h2 id="Next-Dark"><a href="#Next-Dark" class="headerlink" title="Next Dark"></a>Next Dark</h2><p>@media (prefers-color-scheme: dark) {}删了，只保留内层。否则，会考察OS或浏览器的主题，可能不能dark，强制弄黑，保护眼睛。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Huang Wei</p>
  <div class="site-description" itemprop="description">Coding, Struggling, and Living.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">19</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Huang Wei</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
