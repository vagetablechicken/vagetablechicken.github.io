<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"vagetablechicken.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Hey">
<meta property="og:type" content="website">
<meta property="og:title" content="Wei">
<meta property="og:url" content="http://vagetablechicken.github.io/page/2/index.html">
<meta property="og:site_name" content="Wei">
<meta property="og:description" content="Hey">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Huang Wei">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://vagetablechicken.github.io/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Wei</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Wei" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Wei</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://vagetablechicken.github.io/2021/05/06/grokking-4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Huang Wei">
      <meta itemprop="description" content="Hey">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wei">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/06/grokking-4/" class="post-title-link" itemprop="url">Grokking Pattern 4</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-05-06 10:58:13" itemprop="dateCreated datePublished" datetime="2021-05-06T10:58:13+08:00">2021-05-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-07-31 18:56:53" itemprop="dateModified" datetime="2023-07-31T18:56:53+08:00">2023-07-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Algo/" itemprop="url" rel="index"><span itemprop="name">Algo</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Grokking-the-Coding-Interview-Patterns-for-Coding-Questions"><a href="#Grokking-the-Coding-Interview-Patterns-for-Coding-Questions" class="headerlink" title="Grokking the Coding Interview: Patterns for Coding Questions"></a>Grokking the Coding Interview: Patterns for Coding Questions</h1><p>See <a href="/2021/05/06/grokking-1/" title="Grokking Pattern 1">Grokking Pattern 1</a>.</p>
<h2 id="4-Pattern-Merge-Intervals"><a href="#4-Pattern-Merge-Intervals" class="headerlink" title="4. Pattern: Merge Intervals"></a>4. Pattern: Merge Intervals</h2><h3 id="Merge-Intervals-medium"><a href="#Merge-Intervals-medium" class="headerlink" title="Merge Intervals (medium)"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/merge-intervals/">Merge Intervals (medium)</a></h3><p>挺简单的题，尤其是我对这种merge interval的题有一个印象，就是“反着比正着简单”。所以很容易就想到了，这题应该反向来看intervals，所以遍历顺序是end大的到end小的，合并interval或者即时push interval到result里，都很简单，不用多注意什么。</p>
<h3 id="Insert-Interval-medium"><a href="#Insert-Interval-medium" class="headerlink" title="Insert Interval (medium) *"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/insert-interval/">Insert Interval (medium) *</a></h3><p>这个题目纯粹是恶心人，没啥别的作用了。由于每个interval都有两个数表示，又得两个interval之间比较，绕的很晕。</p>
<p>大概逻辑很好想，由于加入new interval（后面简称new），可能new和intervals内的多个interval（后面简称i）有重叠，所以可能会消除多个i，为了代码简洁，肯定是新建一个list，符合条件的才插入，这个逻辑比较好。</p>
<p>又回到new和多个i的合并上，重叠就需要合并，合并后的new’可能还是不应该插入，毕竟可能多个i都需要跟new合并，所以需要一个tmp interval。很容易发现，直接用new来做这个tmp interval正好。</p>
<p>本来思路到这儿还是很清晰的，但是由于对“重叠”的定义没先弄清楚，所以写出了漏洞百出的算法。这一点需要吸取教训。算法如果一开始用数学很难表示，就应该先用形容，能把算法定义清晰了，再翻译为数学。不要总想一步到位。</p>
<p>而“重叠”定义，最简单的办法就是画图，画两个interval的相对位置关系，可以看到，分四种情况，a的右边跟b重叠，a的左边跟b重叠，a完全在b内，a完全包容b。当然数学上，由于与或非关系，可以把前三个写为一个判断式，但第四个无法合并，很容易忘记这一种情况，要细心。</p>
<p>当然，可以反向来看，那就是“不重叠”的非集就是“重叠”。而“不重叠”的判定更简单（我一开始是这么想的，但当时对“重叠”情况的处理很混乱，所以换了思路）。如果再次做此题，正向反向都容易想到，没有特别的坑。</p>
<p>当扩展后的new和当前i不再重合时，需要把new和i都加入result里。这里需要一个布尔量表示new有没有已经被加入，这个步骤没办法写的更优雅。</p>
<p>coding时，还可以注意，我在妄想一步到位时，写满了[0]，[1]。。。把自己都给绕进去了。python是可以<code>for left, right in intervals</code>这么写的，所以别折磨自己，python is beautiful!</p>
<h3 id="Intervals-Intersection-medium"><a href="#Intervals-Intersection-medium" class="headerlink" title="Intervals Intersection (medium)"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/interval-list-intersections/">Intervals Intersection (medium)</a></h3><p>拟定一下算法流程，照着流程过一遍example，就没什么坑了。没什么巧思，一个一个if-else保证正确就行了。</p>
<h3 id="Conflicting-Appointments-medium"><a href="#Conflicting-Appointments-medium" class="headerlink" title="Conflicting Appointments (medium)"></a>Conflicting Appointments (medium)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Problem Statement</span><br><span class="line">Given an array of intervals representing ‘N’ appointments, find out if a person can attend all the appointments.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Appointments: [[1,4], [2,5], [7,9]]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: Since [1,4] and [2,5] overlap, a person cannot attend both of these appointments.</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Appointments: [[6,7], [2,4], [8,12]]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: None of the appointments overlap, therefore a person can attend all of them.</span><br><span class="line"></span><br><span class="line">Example 3:</span><br><span class="line"></span><br><span class="line">Appointments: [[4,5], [2,3], [3,6]]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: Since [4,5] and [3,6] overlap, a person cannot attend both of these appointments.</span><br></pre></td></tr></table></figure>

<p>最简单的区间问题，排序完了，遍历就行了。排序是正着还是反着都行。反正拍完序，只需要看相邻两个区间有没有相交。</p>
<h3 id="Problem-Challenge-1-Minimum-Meeting-Rooms-hard"><a href="#Problem-Challenge-1-Minimum-Meeting-Rooms-hard" class="headerlink" title="Problem Challenge 1 - Minimum Meeting Rooms (hard)"></a>Problem Challenge 1 - Minimum Meeting Rooms (hard)</h3><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/meeting-rooms-ii/">https://leetcode-cn.com/problems/meeting-rooms-ii/</a> plus</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Given a list of intervals representing the start and end time of ‘N’ meetings,</span><br><span class="line">find the minimum number of rooms required to hold all the meetings.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Meetings: [[1,4], [2,5], [7,9]]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: Since [1,4] and [2,5] overlap, we need two rooms to hold these two meetings. [7,9] can</span><br><span class="line">occur in any of the two rooms later.</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Meetings: [[6,7], [2,4], [8,12]]</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: None of the meetings overlap, therefore we only need one room to hold all meetings.</span><br><span class="line"></span><br><span class="line">Example 3:</span><br><span class="line"></span><br><span class="line">Meetings: [[1,4], [2,3], [3,6]]</span><br><span class="line">Output:2</span><br><span class="line">Explanation: Since [1,4] overlaps with the other two meetings [2,3] and [3,6], we need two rooms to</span><br><span class="line">hold all the meetings.</span><br><span class="line"></span><br><span class="line">Example 4:</span><br><span class="line"></span><br><span class="line">Meetings: [[4,5], [2,3], [2,4], [3,5]]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: We will need one room for [2,3] and [3,5], and another room for [2,4] and [4,5].</span><br></pre></td></tr></table></figure>

<p>因为所有intervals都得被满足，所以贪心策略可能可以得到最优解？</p>
<p>简单设想一下，已经排序好的intervals，一个一个尽量排，重叠了就新增一个room。</p>
<p>假设，此时已经用贪心策略得到了2个room，r1和r2，假设r1.end &lt;= r2.end，这时又想加入一个interval，它的start如果比两个end都小，那必然得出第三个room，这个不可能缩减。而如果start比一个小比一个大，那肯定是放入，但放1还是2？我们先比较，肯定是选r1（end最小的room）来比，如果end最小都放不下新的itv，就新增room。如果r1能放下新的itv，为了代码简洁，也应该直接放下了。（假设r2也放得下新itv，那么下一个itv也能放到r2，不会新建room；假设r2放不下新的itv，那就更不可能放r2了，至于下一个itv，就看更新后的r1r2能否满足了。）</p>
<p>——这一部分用数学推理下。</p>
<p>但显然，room不可能只限2个，所以可以考虑一个排序的容器，保存room的end。容器需要支持重复key，因为多个room的end可能数字一样。容器只需要取的出最小的end，之后end可能更新变大再插回容器，其他位置不用管。所以用优先队列最符合要求，而且python没有multiset，想不用优先队列都不行。</p>
<p>代码写起来还是很简单，rooms只会“堆顶被pop再更新push”和“pop新的room”两种情况。不过题解里有一个很骚的操作，就是会把rooms里end&lt;=itv.start的元素都pop掉。怎么理解这个东西？</p>
<p>首先按我原本的设计，rooms的len只会不变和变大，不仅如此，当前itv的end是必然会进优先队列的，区别只在于堆顶会不会pop（也可以理解为itv是会进入优先队列的，因为这里需要考虑itv.start了）。原本设计里优先队列“时刻对应”rooms的已有排列。但前面的思考里，也体现出了，rooms内可能多个room的end都&lt;=itv.start，这部分rooms不会对当前itv和之后的itv产生影响。无法产生影响，就可以直接当做“不存在”。“不存在”，所以可以从heapq里剔除掉，当前itv必然加入heapq（itv会不会影响，要看下一个itv的比较），当然，这时的heapq可能比“当前实际rooms len”小，所以用max来追踪heapq的len最长的时候。</p>
<p>（题解思路还不够清晰，有空再思考下）</p>
<h3 id="Problem-Challenge-2-Maximum-CPU-Load-hard"><a href="#Problem-Challenge-2-Maximum-CPU-Load-hard" class="headerlink" title="Problem Challenge 2 - Maximum CPU Load (hard)"></a>Problem Challenge 2 - Maximum CPU Load (hard)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">We are given a list of Jobs. Each job has a Start time, an End time, and a CPU load when it is running.</span><br><span class="line">Our goal is to find the maximum CPU load at any time if all the jobs are running on the same machine.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Jobs: [[1,4,3], [2,5,4], [7,9,6]]</span><br><span class="line">Output: 7</span><br><span class="line">Explanation: Since [1,4,3] and [2,5,4] overlap, their maximum CPU load (3+4=7) will be when both the</span><br><span class="line">jobs are running at the same time i.e., during the time interval (2,4).</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Jobs: [[6,7,10], [2,4,11], [8,12,15]]</span><br><span class="line">Output: 15</span><br><span class="line">Explanation: None of the jobs overlap, therefore we will take the maximum load of any job which is 15.</span><br><span class="line"></span><br><span class="line">Example 3:</span><br><span class="line"></span><br><span class="line">Jobs: [[1,4,2], [2,4,1], [3,6,5]]</span><br><span class="line">Output: 8</span><br><span class="line">Explanation: Maximum CPU load will be 8 as all jobs overlap during the time interval [3,4].</span><br></pre></td></tr></table></figure>

<p>很容易发现这个题和上一题安排会议，抽象下来是一样的。最容易想到的push/poppush的方法，但由于题目是求max load，所以要尝试改造，然后发现不行。因为这种方法没办法跟踪当前load sum。举例说明，假设itv已经排好序，start小的排前面，start相等时end小的排前面，如果itv1和itv2重合一部分，itv3和itv2重合，但是它并不与itv1重合，在看itv2和3重合的那一段时，load应该是2和3的load之和；而如果itv3和itv1也重合了，这时就应该是三个itv的load之和。但push/poppush是区分不了的，因为它只和heap top比较了一下，摸不到别的itv。</p>
<p>再想到while pop这个方法，虽然在上一题里它很不容易理解，但这道题反而该使用这个方法。核心在于while pop出和当前itv无关的itv，并相应减掉它们的load，就能够实时追踪到某一个时刻的load之和了。</p>
<ul>
<li><input disabled="" type="checkbox"> 再理解下上一题和while pop方法。</li>
</ul>
<h3 id="Problem-Challenge-3-Employee-Free-Time-hard"><a href="#Problem-Challenge-3-Employee-Free-Time-hard" class="headerlink" title="Problem Challenge 3 - Employee Free Time (hard)"></a>Problem Challenge 3 - Employee Free Time (hard)</h3><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/employee-free-time/">https://leetcode-cn.com/problems/employee-free-time/</a> plus</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">For ‘K’ employees, we are given a list of intervals representing the working hours of each employee.</span><br><span class="line">Our goal is to find out if there is a free interval that is common to all employees.</span><br><span class="line">You can assume that each list of employee working hours is sorted on the start time.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: Employee Working Hours=[[[1,3], [5,6]], [[2,3], [6,8]]]</span><br><span class="line">Output: [3,5]</span><br><span class="line">Explanation: Both the employess are free between [3,5].</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: Employee Working Hours=[[[1,3], [9,12]], [[2,4]], [[6,8]]]</span><br><span class="line">Output: [4,6], [8,9]</span><br><span class="line">Explanation: All employess are free between [4,6] and [8,9].</span><br><span class="line"></span><br><span class="line">Example 3:</span><br><span class="line"></span><br><span class="line">Input: Employee Working Hours=[[[1,3]], [[2,4]], [[3,5], [7,9]]]</span><br><span class="line">Output: [5,7]</span><br><span class="line">Explanation: All employess are free between [5,7].</span><br></pre></td></tr></table></figure>

<p>这题本质是一种反向，题目提过工作时间，让你求非工作的某种时间，所以可以用交集并集差集来理解这个题，方便快速的分辨多个解法的复杂度。当然，最佳算法可能比这种逻辑运算的计算量更小，但不熟悉这类题目的情况下，越抽象的思考越容易做。</p>
<p>可以看到k个list，每个list都多个interval，所有的interval的并集，就是所有员工的工作时间，这个集合的反，就是所有的空闲区间（空闲区间显然也可以是多个）。</p>
<p>题目说明了，k个list，list内的区间都是有序的。这很像k路归并排序。按理可以比所有inteval混在一起排序更高效。那我们先mark这个归并思路，放在一边。（有序基本就是在提醒我们存在“利用有序”的优化算法）</p>
<h4 id="简单思路"><a href="#简单思路" class="headerlink" title="简单思路"></a>简单思路</h4><p>假设经过某种算法，已经计算出了所有working hours的并集，这个并集当然可能是多个区间，不一定是一个连续区间。求反只需要遍历这一堆区间就行了。</p>
<p>再来考虑，这个“某种算法”求并集，怎么做。最简单的肯定是全排序。每个区间先比较start，小的排在前面，end随意。这里很可能会出现连续几个区间是有重合部分的，所以，求并集，还得遍历一边，重组一下区间，得到并集（不重合的区间组成的数组）。然后还得再遍历求反。</p>
<p>简单一想，也知道，最后一次遍历多余了。</p>
<p>所以，可以立马优化为，遍历已排序的区间时就求空闲区间。</p>
<p>可以再思考一下，我先每个list先求反，得到每个员工的空闲时间，所有的空闲时间的交集也是最终答案。但空闲时间区间个数不见得比工作区间个数少多少（应该是，对每个list，空闲区间=工作区间-1）。并没有把复杂降低。而且求交集比求并集复杂，因为空闲区间没办法全部一起求交集。想象一下，假设5个员工，有1个在[0,t]之间都不空闲，但是另外4个却可以在[0,t]这个时间内存在交集，但是这个交集是不能要的，因为那一个人不空闲。区间全混在一起时，根本无法判断。所以还是求并集吧。</p>
<h4 id="归并思路"><a href="#归并思路" class="headerlink" title="归并思路"></a>归并思路</h4><p>每个list“有序“，自然是提醒我们要充分利用这个特性。全排序肯定不够用。而list内interval有序，很显然可以做类似归并排序的操作。</p>
<p>归并思路，k个list也就是k路，每次都从k个list的头上选出最小的。这k个区间比还呆在list里的区间的start都要小，在k个中选出来的start最小的区间，也就是全局start最小的区间。所以，当我们将k个中选start最小看作一个模块时，我们从这个模块中拿出“剩余区间”中start最小那个区间。一个一个拿，就是总能按顺序拿出区间了。</p>
<p>核心是这个模块如何实现，即考虑“k个中选最小的”怎么高效，归并算法如果只有两路，当然if-else都能行，但k路肯定是不可能一个一个比的，很明显可以利用最小堆，每次的top就是最小的，top取出来后，top所在的list就应该补充一个区间进入最小堆。python中也就是使用heapq，可以极快的写完代码。</p>
<p>堆算法解释见<a href="/2022/10/07/abs-algo/" title="Heap">Heap</a>。</p>
<p>具体到这个题目，首先要思考这个堆该如何运行，放多少数据，pop出来后又push多少进去，初步设计应该尽量分割步骤，目标是迅速写出正确的算法，后面再做优化。</p>
<p>所以初步设想是，k路数组，每个数组自己内部有序，但k个数组的头，我们是不知道谁最小的，所以把k个数组的头放进堆，我们就可以立马拿到最小的数，此时堆里剩k-1个数，这时候应该将pop出去的那一路的新头补充进堆，因为我们知道数组内的都比堆里的大，只有堆里的有资格比拼一下，所以堆大小在运行期间应该保持为k，不需要多放，多了增加复杂度，少了就比不出全局最小了。</p>
<p>Grokking标准答案也是使用python heapq来做，这个确实写得最快。</p>
<h5 id="败者树"><a href="#败者树" class="headerlink" title="败者树"></a>败者树</h5><p>堆解法不是终点， 如果提到有没有别的思路，就肯定要说到败者树算法了。本质都是树，不会有数量级提升。但总有些区别。</p>
<h6 id="外排序todo"><a href="#外排序todo" class="headerlink" title="外排序todo"></a>外排序todo</h6><p>winner/loser tree很像B+树，非叶子节点是不存值的，所以，和B+树类似，它们可以用在“外排序external sorting”上。</p>
<p><a target="_blank" rel="noopener" href="https://www.cise.ufl.edu/~sahni/cop5536/">https://www.cise.ufl.edu/~sahni/cop5536/</a> 这个网站有很详细的exteral sorting的ppt，需要好好看看。（但是很难懂。。可以当作提纲）</p>
<p>针对winner/loser tree（统一可以叫做Tournament Tree）来讲，你需要知道，Tournament Tree可以利用于improve run generation, 也可以improve run merging。</p>
<p>解释下run generation。外排序不可能把所有的扔进内存里，所以只能先切分成小部分排序，然后做merge，这两步叫做，run generation和run merging。A run is a sorted squence of records。</p>
<p>improve run generation最简单的就是reduce the number of runs(也就是increase average run length)。但这也是有极限的，而且由于外排序在IO上很耗时，所以overlap IO也是一个优化方法。都在课件里，之后再慢慢看。</p>
<h6 id="返回tournament-tree"><a href="#返回tournament-tree" class="headerlink" title="返回tournament tree"></a>返回tournament tree</h6><p>败者树和胜者树是可以一起看的类似结构。胜/败者树都是类似B+树，只有叶子节点是真实值，非叶子节点是胜者/败者的标号，而且它是完全二叉树，不会有歧义。但胜者树和败者树<strong>不是</strong>单纯的一个非叶子节点记录胜者，一个非叶子节点记录败者，否则这两种就应该是一种树，只要compare函数求个反就行了。</p>
<p>胜者树</p>
<p>胜者树更简单，我们先看胜者树，比如小的是胜者，那么每个非叶节点都是它的子节点中更小的那一个。原理很简单，实现上要捋一捋。</p>
<p>可以把整个建树过程理解为打比赛，那比赛，肯定是从下往上打。最下层的非叶子结点先被填上值。按最简单的想法，胜者树用数组表示，每个元素是值（比较大小的值，不是索引）。这样子会有什么问题？当我们把胜者根节点拿出去，我们都不知道应该补上哪个list的元素。所以这个胜者树的节点，应该有索引，标记第i个list，这样就可以补充list[i].top进来。节点可以又保存值，又保存list标号，不过被拿来建树用的k个区间，本来也会放在一个地方，可以叫做ext数组，这样，胜者树节点只需要保存list标号就行了。ext[i]可以取值，list[i].top可以拿到补充用的区间。</p>
<p>而且注意，胜者树是所有参赛者都作为叶子节点的，比如，有3个叶子节点时怎么建树？有6个叶结点时，上一层3个节点，那它的上一层又怎么办？</p>
<p>注意，胜者树定义为complete binary tree，完全二叉树，它只有最底层可能少尾部一些节点，其他节点都是满的。所以，不会存在6个叶节点，上一层只有3个节点的情况，这棵树必须是最底层6个节点（理论上是8个），上一层4个节点（即使这一层最右的这个节点是没意义的，可以用max值，这样不影响比赛结果）。</p>
<p>解决胜者树的节点结构和树形，这两个问题，就可以写算法了。Ref </p>
<p><a target="_blank" rel="noopener" href="https://gist.github.com/vagetablechicken/8a2fc94da27f127921c0b6dd08d7863f">https://gist.github.com/vagetablechicken/8a2fc94da27f127921c0b6dd08d7863f</a></p>
<p>败者树</p>
<p>而败者树呢，非叶节点是记录败者，但是往上送的参赛者是“胜者”（关键点）。</p>
<p>为什么这么做呢？假设胜者树的重新比赛，一个叶子节点被换了，那么它要和它的兄弟节点比。而败者树里，更新的节点只需要找它的parent，就能决定parent是否要更新，不用去访问兄弟节点。</p>
<p>这里粗略一想，觉得很莫名，也没有节约多少东西？</p>
<p>假设两个兄弟节点n1、n2，n1之前不是胜者，但现在比较一下发现n1是胜者，n1的parent就要被我更新为n1？而在败者树里面，我虽然只需要访问n1和n1的parent，不用访问n2，但这能节约多少？</p>
<p>这个问题，如果只看算法题目这种规模当然节约不了什么。但败者树通常用于外排序，外排序的数据规模就很可观了。就访问而言，以前要访问两个，现在要访问一个，访问总次数一多，耗时差距就很大了。（应该不用觉得兄弟节点会需要单独一次I/O从磁盘里读出来，毕竟外部排序的归并部分也是应该保证在内存里进行的，归并部分都要存硬盘了，这个归并k选的也不太对了。）</p>
<p>逻辑上走通了，再来说说code的问题。两个叶子节点比较，得到败者作为父节点，这里还很常规，但是还得往上送胜者，这里就微妙了。难道代表败者树的数组，每个元素都得存两个东西，胜者和败者？还是说，得用node指针来构建树？</p>
<p>complete binary tree不用数组怪浪费的。而且node指针构建树，一开始只有k个单节点的败者树，还要把它们merge起来。merge得先两两merge，注意，要一直保持每棵树的complete binary tree性质。所以，还总是需要构建无意义的节点，为了保持complete binary tree。有点离谱。</p>
<p>还是尝试用数组来表示败者树。其实败者树从构建成功起，就不会再变更树结构，所以建树期间的胜者可以用单独变量来保存，建好树之后，它们就没有意义了，只有全局的那个胜者有意义。</p>
<p>还是在 <a target="_blank" rel="noopener" href="https://gist.github.com/vagetablechicken/8a2fc94da27f127921c0b6dd08d7863f">https://gist.github.com/vagetablechicken/8a2fc94da27f127921c0b6dd08d7863f</a></p>
<p>注意，胜者树可以随便更新参赛者，并且需要从叶子一路更新到根节点，不然可能存在问题。因为，新参赛者即使曾经是某一层的winner，现在值变了还是winner，但它的值变了，往上走它可能就不是了。只有它之前是loser，现在跟之前的winner比还是loser时，才可以停下来。这个优化可以，但没必要，容易写错。建议先写出简单不易错的算法，再谈要不要优化。</p>
<p>败者树则是必须更新winner所在的值，因为败者树要保证只更改胜者走的那条路径。有了这个保证，才能肯定parent存的败者一定是兄弟节点，才可以避免访问兄弟节点。败者树也得一路到根节点，不能因为以前是胜者，现在还是，就不往上比较了，值变了！！！</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://vagetablechicken.github.io/2021/05/06/grokking-5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Huang Wei">
      <meta itemprop="description" content="Hey">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wei">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/06/grokking-5/" class="post-title-link" itemprop="url">Grokking Pattern 5</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-05-06 10:58:13" itemprop="dateCreated datePublished" datetime="2021-05-06T10:58:13+08:00">2021-05-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-07-31 18:56:53" itemprop="dateModified" datetime="2023-07-31T18:56:53+08:00">2023-07-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Algo/" itemprop="url" rel="index"><span itemprop="name">Algo</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Grokking-the-Coding-Interview-Patterns-for-Coding-Questions"><a href="#Grokking-the-Coding-Interview-Patterns-for-Coding-Questions" class="headerlink" title="Grokking the Coding Interview: Patterns for Coding Questions"></a>Grokking the Coding Interview: Patterns for Coding Questions</h1><p>See <a href="/2021/05/06/grokking-1/" title="Grokking Pattern 1">Grokking Pattern 1</a>.</p>
<h2 id="5-Pattern-Cyclic-Sort"><a href="#5-Pattern-Cyclic-Sort" class="headerlink" title="5. Pattern Cyclic Sort"></a>5. Pattern Cyclic Sort</h2><p>这个cyclic sort，需要一点预备知识。cyclic sort条件是，数组元素必须是1到n，虽然乱序，但我们可以确定这个n长的数组里一定是1到n这n个数字，不会有别的数字。如果要对这种特别的数组排序，就可以环型排序，也可以叫圈排序。都知道1到n了还排序就很离谱，所以这并不是cyclic sort的使用场景。事实上，使用场景是Cyclic Sort这一题之外的题目。</p>
<h3 id="Cyclic-Sort-easy"><a href="#Cyclic-Sort-easy" class="headerlink" title="Cyclic Sort (easy)"></a>Cyclic Sort (easy)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Problem Statement</span><br><span class="line">We are given an array containing ‘n’ objects. Each object, when created, was assigned a unique number from 1 to ‘n’ based on their creation sequence.</span><br><span class="line">This means that the object with sequence number ‘3’ was created just before the object with sequence number ‘4’.</span><br><span class="line"></span><br><span class="line">Write a function to sort the objects in-place on their creation sequence number in O(n) and without any extra space.</span><br><span class="line">For simplicity, let’s assume we are passed an integer array containing only the sequence numbers, though each number is actually an object.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: [3, 1, 5, 4, 2]</span><br><span class="line">Output: [1, 2, 3, 4, 5]</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: [2, 6, 4, 3, 1, 5]</span><br><span class="line">Output: [1, 2, 3, 4, 5, 6]</span><br><span class="line"></span><br><span class="line">Example 3:</span><br><span class="line"></span><br><span class="line">Input: [1, 5, 6, 4, 3, 2]</span><br><span class="line">Output: [1, 2, 3, 4, 5, 6]</span><br></pre></td></tr></table></figure>

<p>这个题目着实惊呆我了，我遍历一遍直接将第i个元素改成i+1都通过测试。</p>
<p>不过老实做题的话，这个确实可以用cyclic sort做。cyclic sort具体步骤是，遍历，当当前的元素不在它应该在的位置时，把它和它应该在的那个位置的值做个交换，比如数组[4,3,2,1]，当前看第一个元素4，它应该在最后，所以就交换一下，变成[1,3,2,4]。并且下一个要处理的元素还是当前，因为被交换了过来的元素可能也不是正确位置。</p>
<p>这个排序法的时间复杂度看起来很诡异，不知道怎么算。但可以这么考虑，因为我每一次swap，必然把一个元素放对位置了，所以swap次数最多就n-1次。因为n-1个元素位置对了，自然最后一个元素位置就对了，所以只有n-1次。</p>
<p>可以举个最差例子，[3,1,2]每个元素都不在正确位置。看3，swap后为[2,1,3]，3就放对了，继续看2，swap后[1,2,3]，由于2放对了，最后剩的一个元素就对了。</p>
<p>代码很好写，不用赘述。</p>
<p>但这个排序算法的意义何在呢？接下来的题目里可以提现。</p>
<h3 id="Find-the-Missing-Number-easy-–-LeetCode"><a href="#Find-the-Missing-Number-easy-–-LeetCode" class="headerlink" title="Find the Missing Number (easy) – LeetCode"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/missing-number/">Find the Missing Number (easy) – LeetCode</a></h3><p>这个题目当然可以用cyclic sort做，但是需要注意，题目中是0-n少了某一个，然后乱序放在n长的数组里。假设缺少的那个数不是n，那么数组里就有n，上个题解中的cyclic sort，当然是不能把n这个数放对位置的，因为n长数组idx最大到n-1，没有n。</p>
<p>这怎么办呢？看了<a target="_blank" rel="noopener" href="https://emre.me/coding-patterns/cyclic-sort/">Coding Patterns: Cyclic Sort - emre.me</a>就知道了，只需要忽略n就可以了，如果访问到n，就跳过n，往后访问。这样，遍历操作一遍后，就会出现，n在“不存在的那个数”的位置上，其他数都在对应的位置上。再遍历一次数组，就可以找到missing number了，显然如果遍历一遍数字都对，那么就是missing n这个数了。</p>
<p>这个题目有多种解法，bitmap等等，还能用数学的方法来做。但cyclic sort有一个好处，就是完全没有用额外空间。</p>
<h3 id="Find-all-Missing-Numbers-easy"><a href="#Find-all-Missing-Numbers-easy" class="headerlink" title="Find all Missing Numbers (easy)"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/">Find all Missing Numbers (easy)</a></h3><p>跟上题不一样了，输入n长的数组，里面就是1-n的某些，数字可重复，要输出all missing numbers。</p>
<p>但也容易做出来，拿example 1推演一遍就知道该怎么做了。把”错误位置的元素swap到正确位置“这一条规则不变，但如果有重复元素，就会出现nums[i]!=i and nums[nums[i]] == nums[i]（意思是这么，但实际上idx从0到n-1，数值从1-n，代码里得偏移），此时nums[i]这个元素就是多余的，做一个特殊标记就行了，比如0或者-1，遍历中也要先ignore特殊值。于是missing numbers就是有特殊标记的那些，因为找不到值放在这些特殊位置上，说明这些值不存在。<del>代码也简单，不多赘述。</del></p>
<p>同样，什么bitmap之类的都能做这个题，但cyclic sort可以O(n) and without extra space。</p>
<p>说代码简单，但也撞上错误了。主要是想节约空间，就直接拿nums[nums[i]]来swap，python swap a,b = b,a 也是有执行顺序的，nums[i]中途变了，最后结果反而是没有swap。很神奇。</p>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/a/62038590">algorithm - How swapping variables is implemented in Python? - Stack Overflow</a>可以知道，a,b=b,a实际上是x1=a, x2=b,a=x2,b=x1，当然x1、x2是栈空间，还是需要auxiliary temporary locations。swap也没有magic。</p>
<p>不过还有一个点，就是swap这个写法，等式右边也是寻址才能拿到值，不是常量值，这里的规则是先把=右边算出来，详情见<a target="_blank" rel="noopener" href="https://stackoverflow.com/a/51950571">algorithm - python a,b = b,a implementation? How is it different from C++ swap function? - Stack Overflow</a>。假设nums[i]值为v1，nums[nums[i]]值为v2，</p>
<p>nums[i], nums[nums[i]] = nums[nums[i]], nums[i]这一句会先拿出=右边的值，于是等价于nums[i], nums[nums[i]] = v2, v1。</p>
<p>然后这个时候才会真正找左边的地址，走x1，x2那一套交换。先找nums[i]，找到了，然后赋值v2，然后nums[nums[i]]就是nums[v2]，会把v1赋值给nums[v2]。</p>
<p>本来这个写法最多就是触发了错误的赋值，因为nums[v2]这个位置原本不应该参与进来。</p>
<p>但有趣的是，如果case比较巧合，碰上了v2==i，例如[2,1,0]，取i=0，nums[i]=2，v1=2，nums[nums[i]]=0，v2=0，这就给循环上了。于是nums[i]先被赋值为v2，也就是nums[0]=0(v2)，然后nums[v2]被赋值v1，也就是nums[0]=2，搞了半天，什么也没有变，nums[i]这个位置的值变了又变回来。</p>
<p>恰好我随便写的例子[4,3,2,1]完美符合。</p>
<p>而leetcode的case1 [4,3,2,7,8,2,3,1]，也会死循环。举例说明，第一次交换时用的4和7(idx 0和3)，即num[i], nums[nums[i]-1] = (7, 4)，nums[0]=7，nums[7-1]=4，而第二次交换就要num[i], nums[nums[i]-1] = (4, 7)，nums[0]=4, nums[4-1]=7，第三次交换则是num[i], num[nums[i]-1]=(7, 4)，然后无限循环。这么说肯定很难懂，可以自己推演四五次交换，就会发现，由于第一次交换，无脑地使num[7-1]=4，导致之后，nums[4-1]和nums[7-1]就都不会变了，永远是7和4。然后nums[i]也就是nums[0]不是赋值为7就是赋值为4。</p>
<p>如果用nums[i]=v1,nums[v1]=v2来表示，假设nums[v2]可以访问，第一次交换后，nums[i]的值就会v1、v2反复横跳，nums[v1]永远=v2，nums[v2]永远=v1，虽然是（从1次开始计数）奇数次给v2赋值，偶数次给v1赋值，但第2次交换开始，给v1、v2赋的值永远一样，看起来就是永远不变。leetcode case1并没有太特别，只需要nums[v2]可以访问，就能永远死循环下去。</p>
<p>总之，一旦python swap的时候值是嵌套定位的，就要小心，最好避免swap里有嵌套。</p>
<h3 id="Find-the-Duplicate-Number-medium-–-LeetCode"><a href="#Find-the-Duplicate-Number-medium-–-LeetCode" class="headerlink" title="Find the Duplicate Number (medium) – LeetCode"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-the-duplicate-number/">Find the Duplicate Number (medium) – LeetCode</a></h3><p>这个题目grokking和leetcode的要求不一样，grokking是不允许额外空间，但可以修改输入数组。leetcode则是不能修改输入数组，并且只是用常数量的额外空间。</p>
<p>grokking的限制下，当然还是cyclic sort了，sort途中就能发现重复的那一个数（题目说只有一个，发现后立刻返回就行了）。</p>
<p>leetcode的限制下，就不一样了，最简单当然是set/hash存，但不满足额外空间的限制。不能简单求和，因为他不是保证1到n都出现，而是只限制在[1, n]范围内，而且虽然只有一个数重复出现，但它可以出现2次以上。没有预备知识，很难想到这个题目可以用二分查找或者链表来解，链表还好说点，二分查找这个方法真有点过绕了，而且复杂度也要到nlogn，纯属脑筋急转弯。。。</p>
<p>不过确实也是个思路，而且不能直接套用基础版的二分查找，需要一定的改动，就算没改动，也需要证明可行性。整理了一下，没什么特别的坑，很容易做出来。算法设计期间需要注意，[left, right]这个搜索范围能不能缩小，如果某些情况不能缩小，自然不能最后缩小为最终答案一个值。</p>
<ul>
<li><input disabled="" type="checkbox"> 链表方法解这道题</li>
</ul>
<h3 id="Find-all-Duplicate-Numbers-medium-–-LeetCode"><a href="#Find-all-Duplicate-Numbers-medium-–-LeetCode" class="headerlink" title="Find all Duplicate Numbers (medium) – LeetCode"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-all-duplicates-in-an-array/">Find all Duplicate Numbers (medium) – LeetCode</a></h3><p>这一题grokking和leetcode要求类似了，grokking不允许额外空间（一些临时变量的栈空间肯定是允许的，不然代码都写不了），也就是常数量级的空间了。</p>
<p>这题用cyclic sort很容易做。因为题目保证了数字最多出现2次，“出现2次”在cyclic sort框架里是可以判断的，比如规则写为“出现一次的就在对应的位置上，当又想swap该值到对应位置，就说明该值第二次出现，该位置记为-2”，当你读到-2的时候就说明i这个值出现了2次。出现更多次也可以以此类推。cyclic sort可以说是完美的，不论统计出现几次的值，都可以做到。</p>
<p>但包括这个题和之前的题目，都有另一种常见做法。本质上是hash算法，因为通过自定义的hash，我们能把原数组变成hash桶，原来的nums内每一个位置都是一个数值，hash以后，nums每一个位置i都表示“数值i”出现的情况（这个情况实际当然是数字，而且由于是原地修改nums数组，这个“情况”是编码后的样子，得对应解码才能得出真实信息。）核心就是“编码规则”。设想下，如果你不编码，假设遇到i位置上值为x，你改了nums[x]，并且不理会nums[x]原来位置的值，如果x大于i，你之后遍历到x位置时，就丢了这个数。所以必须编码，用一种方法，能够保留住原数值信息，同时也能存下这个位置i表示的数i出现了多少次。</p>
<p>最简单的做法就是+n+1，因为值最大到n，当你遍历数组时，发现i处的数值&gt;n+1时，说明i值在前面出现过，而出现几次就相应+n+1，这样数值为x时，可以x//(n+1)得到出现次数，而x%(n+1)就可以得到i位置原始的数值，不会漏数。这就是一种编解码规则。</p>
<p>P.S. 也可以+n，当然，计算公式要跟着改变，[1,n]中如果取值n，求余就只能得到0了，所以值-1再求余，才可以。刚好，余数直接对应idx，+n+1的情况余数是真实数值，还得减一才能得到idx。</p>
<p>取反也是可以使用的编解码规则，出现一次就取反，但出现第二次还取反的话，就不行了，所以最多做到得出“出现两次”这个信息（都只能即时拿到，不能二次取反写入nums数组，这样跟一次没出现的情况就混在一次了），不可能辨别有没有出现第三次。</p>
<h3 id="Problem-Challenge-1-Find-the-Corrupt-Pair-easy"><a href="#Problem-Challenge-1-Find-the-Corrupt-Pair-easy" class="headerlink" title="Problem Challenge 1 - Find the Corrupt Pair (easy)"></a>Problem Challenge 1 - Find the Corrupt Pair (easy)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">We are given an unsorted array containing ‘n’ numbers taken from the range 1 to ‘n’. The array originally contained all the numbers from 1 to ‘n’, but due to a data error, one of the numbers got duplicated which also resulted in one number going missing. Find both these numbers.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: [3, 1, 2, 5, 2]</span><br><span class="line">Output: [2, 4]</span><br><span class="line">Explanation: &#x27;2&#x27; is duplicated and &#x27;4&#x27; is missing.</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: [3, 1, 2, 3, 6, 4]</span><br><span class="line">Output: [3, 5]</span><br><span class="line">Explanation: &#x27;3&#x27; is duplicated and &#x27;5&#x27; is missing.</span><br></pre></td></tr></table></figure>

<p>题目不难，还是满足cyclic sort，但if-else有点多，不太简洁。因为我没有当发现duplicate number后即时保存，而是标记为-2，missing number则是标记为0。这样的算法，覆盖面更广，如果有多个duplicate或者missing number，都可以被查出来。但这个题已经明确说了dup和missing都只有一个，所以可以更简化一点。</p>
<p>回归最简单的cyclic sort，拿example推演一下，如果发现了nums[i]想要换到的位置已经有了，这个时候dup就知道了，但是这一次要不要swap？</p>
<p>举例说明，[1,2,3,2]，当我们看到第二个2时，显然不能swap，会死循环。不swap，那怎么做呢？按前面的算法逻辑，就该把[i]这个位置标记为0或者什么。但这么做的话，又会增加if-else，因为下一次读[i]可能有0这个值了，必须单独考虑。</p>
<p>所以，再简单点，不swap，我也不操作了，就i+=1去搞下一个元素。这么做，是没问题的，很类似Find the Missing Number (easy)“n长的数组，是0到n这n+1个数缺了某个数”。Find the Missing Number (easy)的数组中可能有n，n是没办法交换到它应该在的位置的，所以放着就好了，它会在missing的那个位置上，或者整个数组都ok，n这个值就是missing的那一个。</p>
<p>再总结，例如[1,2,3,2]这个数组，我们忽略第二个2，那么数组最后的样子就是[1,2,3,2]，再次遍历数组，i为3时[i]!=i+1，说明了什么？说明这个地方应该出现的值没在，所以i+1是missing number，而[i]==2，说明2是多的那个，所以[i]是dup number。</p>
<p>最后，再理解一下，这个题目其实和Find the Missing Number一模一样，因为dup和missing number都是通过错误的那一个位置可以得到。</p>
<p>代码见 <a target="_blank" rel="noopener" href="https://gist.github.com/vagetablechicken/31b210446ec55944cb490c658c3c6a04">https://gist.github.com/vagetablechicken/31b210446ec55944cb490c658c3c6a04</a></p>
<h3 id="Problem-Challenge-2-Find-the-Smallest-Missing-Positive-Number-medium"><a href="#Problem-Challenge-2-Find-the-Smallest-Missing-Positive-Number-medium" class="headerlink" title="Problem Challenge 2 - Find the Smallest Missing Positive Number (medium)"></a>Problem Challenge 2 - Find the Smallest Missing Positive Number (medium)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Given an unsorted array containing numbers, find the smallest missing positive number in it.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: [-3, 1, 5, 4, 2]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The smallest missing positive number is &#x27;3&#x27;</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: [3, -2, 0, 1, 2]</span><br><span class="line">Output: 4</span><br><span class="line"></span><br><span class="line">Example 3:</span><br><span class="line"></span><br><span class="line">Input: [3, 2, 5, 1]</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure>

<p>这个题目简单一想，就是cyclic sort，sort完后第一个nums[i]!=i+1的地方就是the smallest missing positive number。但是要注意到（就算没注意到，example 3也过不了），nums中可能会出现&gt;len+1的数，cyclic sort时也没办法把这种数放到“正确的位置”。再细想一下，总共就len这么多个数字，如果真就[1,len]每个数字出现一次，smallest missing positive number自然就只能是len+1了。所以，smallest missing positive number的取值范围只可能是[1,len+1]，不会更大了。</p>
<h3 id="Problem-Challenge-3-Find-the-First-K-Missing-Positive-Numbers-hard"><a href="#Problem-Challenge-3-Find-the-First-K-Missing-Positive-Numbers-hard" class="headerlink" title="Problem Challenge 3 - Find the First K Missing Positive Numbers (hard)"></a>Problem Challenge 3 - Find the First K Missing Positive Numbers (hard)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Given an unsorted array containing numbers and a number ‘k’, find the first ‘k’ missing positive numbers in the array.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: [3, -1, 4, 5, 5], k=3</span><br><span class="line">Output: [1, 2, 6]</span><br><span class="line">Explanation: The smallest missing positive numbers are 1, 2 and 6.</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: [2, 3, 4], k=3</span><br><span class="line">Output: [1, 5, 6]</span><br><span class="line">Explanation: The smallest missing positive numbers are 1, 5 and 6.</span><br><span class="line"></span><br><span class="line">Example 3:</span><br><span class="line"></span><br><span class="line">Input: [-2, -3, 4], k=2</span><br><span class="line">Output: [1, 2]</span><br><span class="line">Explanation: The smallest missing positive numbers are 1 and 2.</span><br></pre></td></tr></table></figure>

<p>看起来是挺简单的变种题目，但并不是。首先数组内元素没有限制，如果数组里存在&gt;len的数，它是会影响结果的，不能直接忽略。</p>
<p>可以也先不管&gt;len的数，但这样的结果就是，可以O(n)知道&lt;=len的missing numbers，更大的missing numbers只能枚举，而且还得排除存在于nums数组里的，所以得有个set保存nums中存在的&gt;len的数，每个数都要查一次是否存在，O(nlogn)。</p>
<p>这个&gt;len的查询是省不掉的。参考答案里也是这个方法，简单朴实。</p>
<p>注意一下example1，因为它有重复的5和5，不能用最简单的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">while i&lt;len:</span><br><span class="line">    if cond and nums[i] != i+1:</span><br><span class="line">        swap</span><br><span class="line">    else:</span><br><span class="line">        i+=1</span><br></pre></td></tr></table></figure>

<p>这么的话，经过几次swap，num[0]==5了，5想要被换到idx 4的地方，但恰好这里又是5，陷入死循环。</p>
<p>更好的逻辑是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">while i&lt;len:</span><br><span class="line">    j = nums[i]-1</span><br><span class="line">    if cond and nums[i] != nums[j]:</span><br><span class="line">        swap</span><br><span class="line">    else:</span><br><span class="line">        i+=1</span><br></pre></td></tr></table></figure>

<p>因为nums[i]==i+1时，j就等于i，指向的同一个位置i，[i]!=[j]就可以判断了，还避免了重复情况。</p>
<p>其他坑，例如要保证output个数为k个等等都比较好修复。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://vagetablechicken.github.io/2021/03/22/leetcode-roadmap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Huang Wei">
      <meta itemprop="description" content="Hey">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wei">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/22/leetcode-roadmap/" class="post-title-link" itemprop="url">leetcode-roadmap</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-03-22 20:15:54" itemprop="dateCreated datePublished" datetime="2021-03-22T20:15:54+08:00">2021-03-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-07-31 18:56:53" itemprop="dateModified" datetime="2023-07-31T18:56:53+08:00">2023-07-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Algo/" itemprop="url" rel="index"><span itemprop="name">Algo</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>推荐站点：</p>
<p><a target="_blank" rel="noopener" href="https://qoogle.top/xiaoxu-explaination-leetcode/">https://qoogle.top/xiaoxu-explaination-leetcode/</a></p>
<p><a target="_blank" rel="noopener" href="https://codetop.cc/">https://codetop.cc/</a> </p>
<h1 id="https-codetop-cc-微软"><a href="#https-codetop-cc-微软" class="headerlink" title="https://codetop.cc/ 微软"></a><a target="_blank" rel="noopener" href="https://codetop.cc/">https://codetop.cc/</a> 微软</h1><h2 id="227-基本计算器-II-2012-03-22-23"><a href="#227-基本计算器-II-2012-03-22-23" class="headerlink" title="227. 基本计算器 II 2012/03/22-23"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/basic-calculator-ii/">227. 基本计算器 II</a> 2012/03/22-23</h2><p>这道题，用栈是最快速的，可以现场推理思路，完成80%应该不是问题。<br>但这种表达式，很可能会被考变种，比如加了括号，加了UnaryOp，甚至更难。<br>括号，UnaryOp或是自定义函数，这几类还是可以通过少量修改代码支持。但要能做到像高级计算器一样的，抵抗各种灵活拷问，我目前知道的万能方法就是，编译器的基本思路，也就是词法-解析-翻译，这种流程。毕竟我们使用的编译器就是这个思路，没有比这个更完善的了。</p>
<p>当然，编译器思路不好写。总结来说，基本思路需要Lexer，Interpreter。如果Token过于复杂，最好加个Parser，Parser解析出AST，Interpreter再遍历AST树，计算结果。</p>
<p>面试时使用这个思路，写代码会慢一点，但是比栈思路，更深更硬核。</p>
<h3 id="双栈思路"><a href="#双栈思路" class="headerlink" title="双栈思路"></a>双栈思路</h3><p>一个栈存操作符Op，一个栈存数字Int。双栈思路的核心就是“先算乘除”，所以扫描处理完整个表达式后，Op栈里应该只有加减号，没有乘除号。</p>
<p>但还有一个点要考虑，就是Op里已有+号，此时你扫描到了新的+号，要怎么做？</p>
<p>如果将栈中的+号及时处理了（也就是同优先级优先计算前面的符号），那么整个表达式算完，就只有一个加号或减号，没什么问题。</p>
<p>如果选择了加减号不先算，直接放栈里，就需要注意，之后的计算顺序。举例说明，一个复杂的表达式化简成只剩加减号时，可能是1-2-3，这时候Op栈是“-，-”，Int栈是“1，2，3”，不能再使用栈的pop，那样就变成了1-(2-3)，得用list/vector的顺序计算。<br>（我临时推理时用了这个思路，大概率以后还会这么干😅。我习惯思维是只push进栈，不爱随时pop，最后会统一pop出来计算。大概是觉得这种流程，代码会比较好看。）</p>
<p>还是推荐大家尽量改善自己的思路，选择第一种方式，以免现场推理出来的逻辑不够完备。</p>
<h4 id="单栈"><a href="#单栈" class="headerlink" title="单栈"></a>单栈</h4><p>Leetcode官方题解其实是单栈，但如果你亲手写了双栈，你一定会感受到，如果及时计算同优先级的运算符，Op栈最多只会有一个运算符（+/-号），所以不需要栈，一个变量就能保存了。这就是单栈思路，没什么特别。</p>
<h4 id="边界"><a href="#边界" class="headerlink" title="边界"></a>边界</h4><p>栈的大体思路都是如此，如果加入括号或是其他二元运算符，都还能work。加入括号的话，请一定要用第一种方式😂，处理起来方便很多，不然思路容易卡住。</p>
<p>如果加入UnaryOp正负号，尤其是负号，也就是说leetcode 227题的表达式中的整数不保证是非负整数，又需要一次变化。巧妙的思路是给“-”打头的表达式开头添“0”，变成“0-正整数”。将所有”(-“替换为”(0-“，用字符串replace，还可以不用改变算法主体代码，很简单。<br>而如果还加正号，比如“3++4”合理，这种情况就比有负数的情况还要麻烦了。这要求你的算法能，判断第二个+号是和整数结合的正号（Unary Plus）。再扩展下，“3–++2”等等。代码上就得增加一段逻辑，来处理好UnaryOp。这样当然可以work，但是这也暴露了栈思路的一个问题，就是它没有符合逻辑的解析能力。它似乎只是我们在努力的修补规则，“3–++2”是读取了“3-”后发现还是符号，才会开始解释为一元符号，从左到右计算到底是正号还是负号。但按照逻辑，我们应该是将表达式看作3-(-(+(+(2))))，也就是，真的计算的时刻，2是和前面的正负号结合，然后作为整体又跟前面的正负号结合。也就是解析是顺序，计算是倒序，有种递归下降，然后逐层返回结果的感觉。</p>
<p>其实没什么差别，但是我个人觉得，栈的思路是有些勉强的。因此，当学了一点点编译原理后，我就想用编译的思路来解决这道题了。</p>
<h4 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h4><p>所有计算器题目，都总结下。</p>
<ol start="224">
<li><p>双栈，加减括号，注意允许(+4)这种写法出现，但不用考虑1++2。</p>
</li>
<li><p>双栈，加减乘除，无括号，不用考虑(+4)或一元运算符的情况。</p>
</li>
<li><p>基本计算器 IV，只可能使用编译器思路来解决了，而且还要能处理变量。</p>
</li>
</ol>
<h3 id="编译器思路"><a href="#编译器思路" class="headerlink" title="编译器思路"></a>编译器思路</h3><p>编译器思路，自然是难的，写起来也不够快。但是学习编译器基本原理，我觉得是有意义的，因为底层到程序编译，稍高层的SQL解析，都是这套思路。Parser，Token，blabla。</p>
<ul>
<li><input disabled="" type="checkbox"> 细节，新开一页讲，也可看<a target="_blank" rel="noopener" href="https://ruslanspivak.com/lsbasi-part1/">https://ruslanspivak.com/lsbasi-part1/</a> 一步一步跟着做</li>
</ul>
<p>简单来说，就是用代码实现几行范式。加入新的符号，就修改范式。</p>
<p>比如，只有加减乘除：</p>
<p><img src="https://ruslanspivak.com/lsbasi-part5/lsbasi_part5_grammar.png"></p>
<p>加入括号(LPAREN,RPAREN)：<br><img src="https://ruslanspivak.com/lsbasi-part6/lsbasi_part6_grammar.png"></p>
<p>再加入一元运算符（正负号）：<br><img src="https://ruslanspivak.com/lsbasi-part8/lsbasi_part8_grammar.png"></p>
<p>Parser/Interpreter实现这几条规则就可以了。</p>
<h2 id="91-解码方法-2021-03-24-25"><a href="#91-解码方法-2021-03-24-25" class="headerlink" title="91. 解码方法 2021/03/24-25"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/decode-ways/">91. 解码方法</a> 2021/03/24-25</h2><p>需要注意dp访问越界的问题。<br>通常dp[i]负责看第i个元素（索引其实是i-1），就可以保护住需要访问dp[i-1]的dp公式，因为计算dp数组是i从1开始，dp[0]不会越界。<br>如果dp公式有dp[i-2]，不要慌，dp[1]特殊处理后，dp[2]开始又可以通用处理了。</p>
<h2 id="124-二叉树中的最大路径和-2021-03-26"><a href="#124-二叉树中的最大路径和-2021-03-26" class="headerlink" title="124. 二叉树中的最大路径和 2021/03/26"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/">124. 二叉树中的最大路径和</a> 2021/03/26</h2><ul>
<li><input disabled="" type="checkbox"> wait zx</li>
</ul>
<h2 id="224-Basic-Calculator-2021-03-31-04-03"><a href="#224-Basic-Calculator-2021-03-31-04-03" class="headerlink" title="224. Basic Calculator 2021/03/31-04/03"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/basic-calculator/">224. Basic Calculator</a> 2021/03/31-04/03</h2><p>s consists of digits, ‘+’, ‘-‘, ‘(‘, ‘)’, and ‘ ‘.</p>
<p>227类型的题。这个版本由于没有乘除，用Lexer+Interpreter的版本，范式也不难写。</p>
<ul>
<li><input disabled="" type="checkbox"> TODO 写一下范式</li>
</ul>
<p>当然更简单的，还是可以使用双栈。</p>
<p>而且建议只记忆双栈，<strong>不用去记一些扩展性不够高的思路</strong>。</p>
<p>注意，test case有”1-(+1+1)”这种。虽然不用考虑1+-1这种写法，但’(‘号后跟’+/-‘号是要被考虑的。<br>因此是基本的双栈思路，加过滤空格，再加处理’(+/-‘。</p>
<p>具体说下双栈思路。</p>
<p>首先，框架是逐个字符扫描，但考虑到数字可能是多位，所以最方便的做法应该是<code>while i &lt; len(s):</code>，解析数字时i可能会多加点，其他符号只需+1。</p>
<p>再是每个字符c可能是些什么，各自需要如何处理。如果没什么印象，建议逐个分析，有需要的再合并，想不清楚，直接逐个if-else都行，总比写错了强。<br>所以，逐个看待，伪代码写作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">if c is space:</span><br><span class="line">    pass</span><br><span class="line">elif c is digit:</span><br><span class="line">    # func parse_int TODO</span><br><span class="line">    num = parse_int()</span><br><span class="line">    # TODO calc or push to nums?</span><br><span class="line">elif c is &#x27;(&#x27;:</span><br><span class="line">    # TODO handle &#x27;(+/-&#x27;</span><br><span class="line">    push to ops queue</span><br><span class="line">elif c is &#x27;)&#x27;:</span><br><span class="line">    # ops top is &#x27;(&#x27;</span><br><span class="line">    ops pop</span><br><span class="line">    num = nums.pop()</span><br><span class="line">    # TODO calc or push to nums?</span><br><span class="line">elif c is &#x27;+&#x27; or &#x27;-&#x27;:</span><br><span class="line">    push to nums queue</span><br></pre></td></tr></table></figure>

<p>上面就是最详细的分支情况，由于没有乘除，所以分支数量也没什么可以优化的点。注意我写的TODO，基本都应该封装为一个函数，以免主逻辑太难读，给自己增加难度。</p>
<p>特别的，<code>calc or push to nums</code>是最需要注意的一个地方，明显的，两个分支都用到这一逻辑，封成函数是最好的，我命名为<code>calc_with()</code>。</p>
<p>而这个数什么时候用来计算，什么时候直接push进栈呢？</p>
<p>举例分析，我想把nums栈顶top和现有的num拿来计算，那么ops栈顶当然得是+/-号，如果栈顶是’(‘，那自然不该算。只需要考虑这一个条件。</p>
<p>如果不计算，直接push。如果pop栈顶计算了一次，之后的结果，该如何处理？</p>
<p>很容易想到，这个结果，还是应该push进栈。但还是应该多思考一下，有没有什么坑？</p>
<p>这一点可能有点不直观，但你可以手写推理或者debug代码测试，就会知道，<code>calc_with()</code>总是在尽力地合并，只有遇到’(‘才会无法合并，导致nums和ops栈多增一个元素。</p>
<p>简单起见，假设只有+号没有-号，某个时刻的栈只能是<code>+(+((+</code>，不会有<code>++(++(++</code>。</p>
<p>假设此时ops栈为<code>+(+((+</code>,现有num，ops栈pop出+号，再nums栈里pop一个数num1，计算出结果res，这个res push回nums栈是合理的。无论后面跟什么符号，都能正确处理。</p>
<h2 id="770-基本计算器-IV"><a href="#770-基本计算器-IV" class="headerlink" title="770. 基本计算器 IV"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/basic-calculator-iv/">770. 基本计算器 IV</a></h2><p>这个题太长了，看的人头皮发麻。但是抽象一下，就能发现，它实际上难点在于括号展开。因为我们已有的知识已经能把一个有括号的表达式解析出来了，可以转成AST树，也可以在解析parse时及时计算。但是，没有包含过“括号展开”的逻辑。</p>
<p>简单的想一下，AST树完全不知道该怎么去实现括号的展开，所以pass。</p>
<p>所以就考虑下parse时及时计算的时候能不能加上“括号展开”。</p>
<p>parse时，可以知道pre_calc * new term的，具体2 * (a-b)，new term为(a-b)，之前的计算结果为2（简单起见，用数字举例）。</p>
<p>接下来，该怎么做？</p>
<p>应该做到拆出2 * a-2 * b。这一步即括号展开，是此题的核心。题目也暗示了可以理解为2 * a与-2 * b两项，那么也就是2要跟（1 * a)和(-1 * b)都分别乘一下。代码上其实就是for循环。当然(a-b)这个factor得拆成一个数组（2个元素，a和-b）。还需要拆成系数和word，那系数和word怎么对上号呢？</p>
<p>考虑到2 * a + 1 * a能合并为3 * a，主要功劳是在word上，所以以word为key，系数为value是很合适的。</p>
<p>所以可以用dict，{a: 1, b: -1}这样来表示。</p>
<p>再进一步完善，如果是(c * d - 2 * f) * (a - b)，那pre_calc，即(c * d - 2 * f)，也得用dict来表示。其实pre_calc没有什么特别，就是一个factor，无论是一个数，还是圆括号扩起来的长表达式。所以用一样的规则，{c*d: 1, f: -2}，很通用，也合理。</p>
<h3 id="整理思路"><a href="#整理思路" class="headerlink" title="整理思路"></a>整理思路</h3><ul>
<li><input disabled="" type="checkbox"> TODO 写出范式</li>
</ul>
<p>也就是说，每个factor（不可再拆分的元素）都可以用一组kv来表示，也就是一个dict。一个term是多个dict合并，最终可以得到1个dict（遍历所有dict，体现加法，因为负号作为系数去了，所以可以当作只有加法）。</p>
<p>term和term之间的乘法，也就是dict和dict组合出一个新的dict（二维for循环，体现乘法）。从左到右一个一个组合，最后得到一个dict，即为最后结果。</p>
<h2 id="剑指-Offer-40-最小的k个数"><a href="#剑指-Offer-40-最小的k个数" class="headerlink" title="剑指 Offer 40. 最小的k个数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/">剑指 Offer 40. 最小的k个数</a></h2><p>TopK，面试时也遇到过，我认为heap K最稳定，但面试官更希望我用快排思想，虽然快排思想有一定几率会很慢–最坏O(n^2)。除了复杂度，实际运行，由于现代计算机架构，inner loop可以很快，见<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/zh-cn/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F">wiki</a>。具体的复杂度算法也可以看wiki。不要仅考虑理论复杂度。</p>
<p>不过有个点，我也不知道是不是记错了，面试官当时可能说c++ stl的paritial_sort是快排思想，但实际paritial_sort就是先构建k大小的堆，然后把剩下的都和堆顶比。nth_element才是快排的思路。</p>
<p>核心快排思路见 <a href="/2022/10/07/abs-algo/" title="Quick Sort">Quick Sort</a>。</p>
<p>最小k个、最大k个，第k大，第k小问题底层都是一样的，快排，变换一下都可以变为“左边&lt;=，pivot，右边&gt;=”这样的格式。类似golang或stl里，pred作为参数传入。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://vagetablechicken.github.io/2021/01/08/bookmark/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Huang Wei">
      <meta itemprop="description" content="Hey">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wei">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/08/bookmark/" class="post-title-link" itemprop="url">Bookmarks</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-01-08 16:35:53" itemprop="dateCreated datePublished" datetime="2021-01-08T16:35:53+08:00">2021-01-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-07-31 18:56:53" itemprop="dateModified" datetime="2023-07-31T18:56:53+08:00">2023-07-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/tool/" itemprop="url" rel="index"><span itemprop="name">tool</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Bookmarks"><a href="#Bookmarks" class="headerlink" title="Bookmarks"></a>Bookmarks</h1><p>C &amp; Go 对照表：<a target="_blank" rel="noopener" href="https://hyperpolyglot.org/c">https://hyperpolyglot.org/c</a></p>
<p>vim等使用方法快查：<a target="_blank" rel="noopener" href="https://hyperpolyglot.org/text-mode-editors">https://hyperpolyglot.org/text-mode-editors</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://vagetablechicken.github.io/2021/01/07/java-string-charset/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Huang Wei">
      <meta itemprop="description" content="Hey">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wei">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/07/java-string-charset/" class="post-title-link" itemprop="url">JAVA String Charset</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-01-07 16:25:05" itemprop="dateCreated datePublished" datetime="2021-01-07T16:25:05+08:00">2021-01-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-07-31 18:56:53" itemprop="dateModified" datetime="2023-07-31T18:56:53+08:00">2023-07-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/programming/" itemprop="url" rel="index"><span itemprop="name">programming</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="JAVA-String-Charset"><a href="#JAVA-String-Charset" class="headerlink" title="JAVA String Charset"></a>JAVA String Charset</h1><p>JAVA的String使用上一般不会考虑到编码字符集的问题，即encode charset。但如果出现数据交互，就需要考虑了，因为不同环境就可能存在差别。如果编码对不上，可能会出现乱码。JAVA中我经常见到的是<code>?</code>乱码（多个问号），不排除其他可能。</p>
<h1 id="An-Example"><a href="#An-Example" class="headerlink" title="An Example"></a>An Example</h1><p>host A用utf-8编码<code>String</code>，以<code>byte[]</code>形式发送到host B，如果host B只简单的用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new String(receivedBytes)</span><br></pre></td></tr></table></figure>
<p>来转成String使用，这里使用的charset就是default charset。</p>
<blockquote>
<p>The Java platform depends heavily on a property called the default charset. The Java Virtual Machine (JVM) determines the default charset during start-up.</p>
</blockquote>
<p>可以用下面的方法测试出当前平台的default charset。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Charset.defaultCharset().displayName();</span><br></pre></td></tr></table></figure>
<p>我个人的jvm default charset是<code>US-ASCII</code>，所以不设置String的charset就出现乱码。</p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><ol>
<li><code>new String</code>时指定charset</li>
<li>修改JVM的default charset，方法自行搜索</li>
</ol>
<h1 id="Further"><a href="#Further" class="headerlink" title="Further"></a>Further</h1><p>即使String的编码正确了，也不代表console output或output file就不会乱码。涉及了多个模块，可能需要更多的配置，请随机应变。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://vagetablechicken.github.io/2021/01/06/build-hexo/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Huang Wei">
      <meta itemprop="description" content="Hey">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wei">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/06/build-hexo/" class="post-title-link" itemprop="url">Hexo</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-01-06 11:18:37" itemprop="dateCreated datePublished" datetime="2021-01-06T11:18:37+08:00">2021-01-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-09-03 15:41:43" itemprop="dateModified" datetime="2023-09-03T15:41:43+08:00">2023-09-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/build/" itemprop="url" rel="index"><span itemprop="name">build</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h1><p>Hexo的创建使用不多赘述。</p>
<h2 id="With-github"><a href="#With-github" class="headerlink" title="With github"></a>With github</h2><p>Hexo通过<code>hexo d</code>来发布到github，因此github中deploy到的分支是网站目录。也就是deploy后在本地可以看到的<code>.deloy_git</code>。<br>我个人使用了另一个branch来保存hexo项目的原始文件，也就是_config.yml配置，md文档等等。</p>
<h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><p>名字解释：<br><code>&lt;root&gt;</code>: 指的网页根目录，或者说是hexo deploy到的repo分支根目录。</p>
<p>Q: 遇到网站repo中路径是存在的，比如<code>&lt;root&gt;/categories/index.html</code>确实存在，但是浏览器点击却是404？<br>A: 可以自行访问尝试下<code>&lt;root&gt;/categories/</code>或者全路径，看看<code>index.html</code>是不是有问题。如果这样就能访问到正常页面，那么问题大概就是缓存了。你可以换个浏览器快速检查下，或清除该页面缓存重试下。</p>
<h3 id="附赠-chrome清除单个页面缓存"><a href="#附赠-chrome清除单个页面缓存" class="headerlink" title="附赠-chrome清除单个页面缓存"></a>附赠-chrome清除单个页面缓存</h3><p>chrome的<code>开发者工具-setting</code>中<code>Network-Disable cache(while DevTools is open)</code>，此选项打开后，在你想要调试的页面，打开开发者工具，就不会出现一些奇怪的缓存现象了。</p>
<h2 id="Hexo-cmds"><a href="#Hexo-cmds" class="headerlink" title="Hexo cmds"></a>Hexo cmds</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br><span class="line">cd &lt;blog-source&gt;</span><br><span class="line">npm install</span><br><span class="line"># if ERROR Package xxx is not installed</span><br><span class="line">npm install xxx</span><br><span class="line"></span><br><span class="line">hexo new draft &lt;draft_name&gt; # just the name, no .md</span><br><span class="line"># writing, writing, ...</span><br><span class="line">hexo publish &lt;draft_name&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo d</span><br></pre></td></tr></table></figure>

<p>If you want to delete a post, just delete it in the source folder.</p>
<p>Localhost debug way:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s --debug</span><br></pre></td></tr></table></figure>

<h2 id="Hexo-writing"><a href="#Hexo-writing" class="headerlink" title="Hexo writing"></a>Hexo writing</h2><h3 id="link-to-another-post"><a href="#link-to-another-post" class="headerlink" title="link to another post"></a>link to another post</h3><p>Ref <a target="_blank" rel="noopener" href="https://hexo.io/docs/tag-plugins.html#Include-Posts">Include Posts</a>.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% post_link 要跳转文章md文件名(不要后缀) %&#125;</span><br></pre></td></tr></table></figure>

<h3 id="pics"><a href="#pics" class="headerlink" title="pics"></a>pics</h3><p><a target="_blank" rel="noopener" href="https://hexo.io/docs/tag-plugins.html#Embed-image">https://hexo.io/docs/tag-plugins.html#Embed-image</a> ，hexo-renderer-marked 3.1.0不需要额外指定目录，只要图放在对应目录里。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-renderer-marked --save</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://hexo.io/docs/asset-folders#Embedding-an-image-using-markdown">https://hexo.io/docs/asset-folders#Embedding-an-image-using-markdown</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% asset_img foo.jpg %&#125;</span><br></pre></td></tr></table></figure>

<p>但这种不是markdown的语法，所以不能用在md文件中，想要写md时预览，可以vscode安装插件Hexo Utils。</p>
<h2 id="NPM-install"><a href="#NPM-install" class="headerlink" title="NPM install"></a>NPM install</h2><p>如果<code>apt install npm</code>遇到gcc update-alternatives slave问题，就先把update-alternatives清理了，再添加也方便，<a target="_blank" rel="noopener" href="https://gist.github.com/ArseniyShestakov/a458b96a354014f80ab8d95676100c03">清除参考写法</a>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># cleanup</span><br><span class="line">update-alternatives --remove-all gcc</span><br><span class="line"># set one g++</span><br><span class="line">update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-9 10</span><br><span class="line"># recover</span><br><span class="line">update-alternatives --remove-all cc</span><br><span class="line">update-alternatives --remove-all c++</span><br><span class="line">update-alternatives --remove-all gcc </span><br><span class="line">update-alternatives --remove-all g++</span><br><span class="line">update-alternatives --remove-all clang</span><br><span class="line">update-alternatives --remove-all clang++</span><br><span class="line">update-alternatives --remove-all icc</span><br><span class="line">update-alternatives --remove-all icc++</span><br><span class="line">update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-8 80 --slave /usr/bin/g++ g++ /usr/bin/g++-8 --slave /usr/bin/gcov gcov /usr/bin/gcov-8 --slave /usr/bin/c++ c++ /usr/bin/g++</span><br></pre></td></tr></table></figure>
<p>slave有个好处是不怕个别版本被修改，还是建议维持这个样子。</p>
<p>但ubuntu版本早的话，node.js版本可能太低了，hexo没法用，报错：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TypeError: line.matchAll is not a function</span><br><span class="line">       at res.value.res.value.split.map.line (/root/vagetablechicken.github.io/node_modules/hexo-util/lib/highlight.js:121:26</span><br></pre></td></tr></table></figure>
<p>比如，我ubuntu20.04装的node就是10.19.0，需要12及以上的。<br>升级：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt -y install curl dirmngr apt-transport-https lsb-release ca-certificates</span><br><span class="line">curl -sL https://deb.nodesource.com/setup_12.x | sudo -E bash -</span><br><span class="line">sudo apt -y install nodejs</span><br></pre></td></tr></table></figure>

<p><code>hexo version</code>可以查到相关version。</p>
<p>然后又可能遇到<code>npm rebuild node-sass</code>很慢的问题，卡在github上下载node-sass了。可以换下源试试，<code>npm i node-sass --sass_binary_site=https://npm.taobao.org/mirrors/node-sass/</code>。socks5代理会hang up，不知道是不是暂时的不稳定。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Huang Wei</p>
  <div class="site-description" itemprop="description">Hey</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">16</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Huang Wei</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
