<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"vagetablechicken.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Hey">
<meta property="og:type" content="website">
<meta property="og:title" content="Wei">
<meta property="og:url" content="http://vagetablechicken.github.io/index.html">
<meta property="og:site_name" content="Wei">
<meta property="og:description" content="Hey">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Huang Wei">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://vagetablechicken.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Wei</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Wei" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Wei</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://vagetablechicken.github.io/2023/09/02/bigdata-algo/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Huang Wei">
      <meta itemprop="description" content="Hey">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wei">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/09/02/bigdata-algo/" class="post-title-link" itemprop="url">BigData Algo</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-09-02 16:40:22" itemprop="dateCreated datePublished" datetime="2023-09-02T16:40:22+08:00">2023-09-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-09-03 15:24:28" itemprop="dateModified" datetime="2023-09-03T15:24:28+08:00">2023-09-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/BigData/" itemprop="url" rel="index"><span itemprop="name">BigData</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>一些通用的大数据、分布式等方面的算法总结。单独出一篇文章，因为这类算法都是通用的，但具体到各个系统，实现方式可能不同，本篇只总结算法思想，可能伪代码实现最基础的算法，必要时会给出现实系统的参考链接。</p>
<h2 id="一致性哈希"><a href="#一致性哈希" class="headerlink" title="一致性哈希"></a>一致性哈希</h2><p>哈希可以说是出现在大数据的方方面面了。一到切分，基本都是它。一致性哈希，先说哈希，也就是虚拟哈希空间，有2^32个片，叫哈希环。</p>
<p>然后哪个服务器负责处理哪些哈希片，是靠映射。具体方法没有规定，比如，可以用服务器ip来hash，还是2^32取模，得到的数字，它就处理哈希环上对应的片。数据来了先hash取模，得到的值然后顺时针找可以服务的服务器，就发给它。</p>
<p><img src="/./bigdata-algo/consistent-hashing.jpg" alt="chash"></p>
<p>如果中间某个服务器down了，反正算法是往后找到第一个服务器，它还是会被处理。当然这个就要求“数据可以被任何server处理”，不能是特别的。比如，相关数据只在某个节点，其他节点获取不到，处理条件都不满足。当然这是理想条件，现实很多也不满足，但它们涉及到的数据也可以是多节点都存有备份，但又不至于所有节点都需要。这个也等于缩容，受影响的数据是“会落到这一下线节点的数据”，我们称为nodeB，将前一个节点nodeA的末尾片记为end1，当前节点末尾片为end2，也就是<code>(end1, end2]</code>区间的数据原本应该找这个节点B，但它下线了，就会变成去找下一个节点nodeC。其他片上的数据不会受到影响。虚拟哈希环不会改变大小，永远的2^32片。如下图左边所示。</p>
<p>而扩容就在hash环上加一个node，原本<code>[start, end]</code>会找nodeD，你在nodeD前面塞了个nodeE，那么<code>[start, nodeE_end]</code>这部分数据就是受影响的数据，原来要找nodeD，现在变成nodeE。如下图右边所示。</p>
<p><img src="/./bigdata-algo/upscale-downscale.jpg" alt="scale"></p>
<p>优点不难猜测，节点上下线只会影响局部数据，这已经是很大的优点了。不能傻到还在N个节点，就hash(req)%N吧，增加节点你还需要把N改成N+1。而且它会改变很多请求的路由，缓存都不无法利用。（当然，要是系统就是这样的简单，啥也不要求，那也不用考虑改变了，简单就是最好的。）</p>
<p>但这还有优化空间，因为在前面所说的算法中，nodeX总是要分到连续的多片，现实中是很难保证每片都差不多热度，也就更不能要求每个node的请求都是均匀的。而且节点数量改变时，在现实条件下，上下节点是要改变很多东西的，可能你要将一些数据复制到节点中才能正常服务，也叫做Node rebuilding。它是一个很重的操作。</p>
<p>为了解决，又引入“虚拟节点机制”，就是hash环上不是物理server node，而是每个物理server都膨胀出，node0-0、node0-1等等的虚拟节点，这样虚拟节点打散分布在hash环上，倾斜可能性就小些。不再是一个node去处理连续的一大片区域。如下图所示。</p>
<p><img src="https://miro.medium.com/v2/resize:fit:720/format:webp/1*OAiDSxqJBpVkT55fK7n0oA.jpeg" alt="vnodes"></p>
<p>向图中展示的一样，一个server node处理离散的几个片，那么每个server的负载均衡就很好操作了，比如，我可以让1个server服务3个高热度的，其他server负载10个低热度的。不用费心去在环上取一个很好的位置，才能把连续的几片服务好，有变化时更是运维难度大。而迁移片也是只对这么一个小区域，粒度更细，rebuild压力也就越小。</p>
<p>也有人说Vnodes负载均衡的情况还可能是让性能好的机器服务更多、更热的片，小机器就混一混。机器规格不一致的时候，确实是个好处。不过我实际在工作中挺难看到不一样的机型在同一个集群。可能现在机器越来越便宜了吧，以前还是很看重成本的，甚至看到机器闲置会进行降级。</p>
<p>整个算法知识都可以看文章 <a target="_blank" rel="noopener" href="https://interviewnoodle.com/how-to-use-consistent-hashing-in-a-system-design-interview-b738be3a1ae3">https://interviewnoodle.com/how-to-use-consistent-hashing-in-a-system-design-interview-b738be3a1ae3</a><br>，讲的很细，图都是引用的它的。</p>
<p>现在来讲讲如何代码实现一致性哈希。</p>
<h3 id="简版"><a href="#简版" class="headerlink" title="简版"></a>简版</h3><p>简单版本，我们只做哈希环，然后node负责连续分片。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">def hash(key):</span><br><span class="line">    return hash(key) % 2^32</span><br><span class="line"></span><br><span class="line">map&lt;hash_value, node&gt; ring</span><br><span class="line"># map key可以不是范围，而是end分片，这样可以用lower bound来找到第一个大于等于req_key的node</span><br><span class="line"># 但原生Python不支持，得新建class</span><br><span class="line"># Java ceilingEntry和C++ std都可以直接用</span><br><span class="line"></span><br><span class="line">def get_node(key):</span><br><span class="line">    hash_value = hash(key)</span><br><span class="line">    return ring[lower_bound(hash_value)]</span><br><span class="line"></span><br><span class="line"># main</span><br><span class="line">req_key = hash(req)</span><br><span class="line">node = get_node(req_key)</span><br><span class="line">node.handle(req)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果存在一群相同元素，那么 lower_bound 和 upper_bound 就可以找到这群元素的上下界限，前者指向下界限，用 lower 表示，后者指向上界限的后一个位置，用 upper 来表示。也就是说，lb是大于等于key的第一个元素，ub是大于key的第一个元素。</span><br></pre></td></tr></table></figure>

<h3 id="开源实现"><a href="#开源实现" class="headerlink" title="开源实现"></a>开源实现</h3><h4 id="Guava-consistentHash"><a href="#Guava-consistentHash" class="headerlink" title="Guava consistentHash"></a>Guava consistentHash</h4><p>Guava库中的<a target="_blank" rel="noopener" href="https://github.com/google/guava/blob/f491b8922f9dc8003ffdf0cbde110b76bcec4b6e/guava/src/com/google/common/hash/Hashing.java#L660">com.google.common.hash.Hashing.consistentHash</a>就实现一致性哈希算法。一般使用方法是，你有一个key，用Hashing中提供的某种hash算法来hash这个key（比自行提供hashCode会好，提供了murmur之类的算法），得到的HashCode去调用consistentHash方法，再加上一个bucket数据限定，就可以得到一个bucket的index，也就是说，你的key会被分到这个bucket里。</p>
<p>但仔细看它的consistentHash函数，它压根儿没做一致性哈希理论的那些事，完全没有哈希虚拟空间的事儿。</p>
<p>它的理论是源于此文章 <a target="_blank" rel="noopener" href="https://dl.acm.org/doi/10.1145/258533.258660">https://dl.acm.org/doi/10.1145/258533.258660</a> ，一致性哈希的根本定义是“对所有的 Buckets 和 Items 应用相同的哈希函数 H，按照哈希值的顺序把它们排列到一条线上，然后将距离 Bucket 最近的 Items 都放入该 Bucket 中”，哈希环是一种实现方式，但不是唯一的实现方式。</p>
<p>Guava一致性哈希算法实现者的文章，<a target="_blank" rel="noopener" href="https://arxiv.org/ftp/arxiv/papers/1406/1406.2294.pdf">https://arxiv.org/ftp/arxiv/papers/1406/1406.2294.pdf</a> ，批斗了一波原版，提出了新的“jump consistent hash”，不用存server/bucket服务哪些哈希片，速度还快。但它是有条件限制的，buckets必须是连续，否则这个index刚好是下线了的node id，那肯定不行。如果要用这一套，必然是得把bucket抽象化，也就是Vnodes那一套。</p>
<p>先只看JumpConsistentHash。首先，先抛弃一致性哈希的经典哈希空间，抛弃空间与真实bucket的对应关系，我们只去想这个算法要干什么，就是想将input放进bucket里，想均匀地放，当然也不能乱放。不乱放是指，key=k1，那么k1在bucket数目恒定时，就应该永远被放入同一个bucket，不然就是随意乱放了，random放，更甚者循环放就行了。</p>
<p>规律总结就是，记<code>ch(key, bucket_size)</code>为一致性哈希函数，那么得有：</p>
<ul>
<li>ch(k, 1)=0，即所有key都放bucket0，毕竟总数只有1个bucket</li>
<li>In order for the consistent hash function to balanced, ch(k, 2) will have to stay at 0 for half the keys, k, while it will have to jump to 1 for the other half. In general, ch(k, n+1) has to stay the same as ch(k, n) for n/(n+1) of the keys, and jump to n for the other 1/(n+1) of the keys.<br>ch(k,2)，就是分一半流量给新增的bucket1。进一步的，ch(k, n+1)对比ch(k, n)则是，n/(n+1)的key完全不变化，1/(n+1)的key，它们的bucket变更成n。（必须n/(n+1)部分是完全不变化，bucket值都不可改变，不然就算不得一致性哈希了，就是随便乱来算法。）而既然是最后还是要key平均进入bucket，当然是得每个bucket里抽出一部分来，放进新bucket。</li>
</ul>
<p>这样，就可以用ch(k,n)来描述ch(k,n+1)了。也就是说，ch(k,n+1)计算时，都是先用ch(k,n)计算出来，但有一部分key应该考虑分给新bucketn。从一个key的角度来看，它就是在不断jump，它在ch(k,1)时，就是0，然后在ch(k,2)时，就是0或1，满足条件，它就应该到1那儿去，然后在ch(k,3)时，它又该考虑是留在bucket1还是跳到bucket2，以此类推。还真是名副其实的jump。</p>
<p><img src="/./bigdata-algo/jump-chash.jpg" alt="jump"></p>
<p>图中，从左下框架上来看，只有?函数安排合理，就能得到一个非常简单的一致性哈希算法实现。那么，关键又变成了什么样的函数才能做到。假设k2是输入key，返回值是恒定的0.1，那么2个桶，它就会被判定去桶1，3个桶就去桶2。但这么就搞得只有小key才会挪动，不够随机。所以这里的函数一般是随机函数，但由于我们必须保证原则“bucket数量不变时，k应该对应唯一一个bucket index”，所以这个随机不是真的随机。所以实现上，会拿key本身作为seed，它对应不变的一组数字序列，是可预期的。所以对一个key来说，在bucket总数不变时，结果是一样的。</p>
<p>文中还做了进一步优化，大概是能跳过一些没必要的j loop，毕竟j越大，能跳的值就越少了，有些都不太需要处理这一遭。没有仔细看，有空再啃一下原文，可以参考 <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/625123381">https://zhuanlan.zhihu.com/p/625123381</a> 看一看。</p>
<h4 id="Ketama"><a href="#Ketama" class="headerlink" title="Ketama"></a>Ketama</h4><p>前面那个属于邪教了，课外读物，当然很厉害。真的去实现理论算法的，较为有名的一种实现叫Ketama算法，该算法最初是由Last.fm的程序员实现的并得到了广泛的应用</p>
<p>标准ketama好像是 <a target="_blank" rel="noopener" href="https://github.com/RJ/ketama">https://github.com/RJ/ketama</a> ，只有c实现，其他语言都是调用c库。本质没什么特别的好像，可能就是较早的广泛的算法实现。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/ultrabug/uhashring">https://github.com/ultrabug/uhashring</a> 是纯Python实现，其中也包含ketama。特点是，中途可以加减node，还有weight，weight就是大的vnode多一点，这样key会较多的到weight高的node上。这一版实现值得多看看。</p>
<h4 id="redis（其实并没有）"><a href="#redis（其实并没有）" class="headerlink" title="redis（其实并没有）"></a>redis（其实并没有）</h4><p>redis常有人说用到了一致性哈希，具体是说redis cluster的data sharding。但作者明确指出它的slot sharding不是一致性哈希，<a target="_blank" rel="noopener" href="https://redis.io/docs/management/scaling/%E3%80%82%E6%88%91%E4%BB%AC%E6%9D%A5%E5%88%86%E6%9E%90%E4%B8%8B%E3%80%82">https://redis.io/docs/management/scaling/。我们来分析下。</a></p>
<p>首先redis cluster data sharding的Hash槽就少一点，当然这不是拒绝被称为一致性哈希的理由。再就是一个redis node也是负责一堆slot，也可迁移slot，类似Vnodes，但不是Vnodes就一定是一致性哈希。因为redis cluster是让一个node服务一个slot，并没有当前node下线，就可以自动找下一个node的机制。因为node有存储，不是缓存，不天然满足一致性哈希的理论要求。但它倒确实是满足了“增删节点只影响一部分数据”这一条准则，让人觉得这就是一致性哈希才能做的事情。但还是要抓重点，<strong>redis cluster并没有为了做到能让下一个node服务，让nodeB多hold一份nodeA的存储数据</strong>。从这个角度看，它只是hash，很多分布式存储都哈希分数据，但它们也没谁说是用了一致性哈希。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HASH_SLOT = CRC16(key) mod 16384</span><br></pre></td></tr></table></figure>

<p>redis的client jedis倒是用了一致性哈希，client/proxy端做请求分流，还是很简单的。</p>
<h4 id="Dynamo"><a href="#Dynamo" class="headerlink" title="Dynamo"></a>Dynamo</h4><p>更标准的在存储端使用一致性哈希的例子，应该是Dynamo, 原文是《Dynamo: Amazon’s Highly Available Key-value Store》。再对比下Redis cluster和Dynamo，它们在哈希存储时，都面临存储node下线后就无法服务的问题，必然得想解决方案。最常规的办法是，为每个slot做一个多副本备份，slot副本之间用某种一致性协议保证数据同步。redis cluster也是如此，所以是master/slave机制，选主由外部服务sentinel负责。所以redis cluster架构其实就是普通分布式，当然它还有个特点是，用gossip协议组成集群，而不是中心化管理集群，实际工程上用起来贼难用。不管怎样，redis cluster是非常常见的hash shard+replica的分布式存储架构，只是具体选型有序别而已。</p>
<p>而Dynamo不一样，它硬是一条路走到底了。原文 <a target="_blank" rel="noopener" href="https://www.allthingsdistributed.com/files/amazon-dynamo-sosp2007.pdf">https://www.allthingsdistributed.com/files/amazon-dynamo-sosp2007.pdf</a> 。解读可以看 <a target="_blank" rel="noopener" href="https://medium.com/@adityashete009/consistent-hashing-amazon-dynamodb-part-1-f5719aff7681">https://medium.com/@adityashete009/consistent-hashing-amazon-dynamodb-part-1-f5719aff7681</a> 的系列文章，Vector Clocks，Sloppy Quorum等很多细节还没看。</p>
<p><img src="/./bigdata-algo/dynamo-replica.png" alt="dynamo"></p>
<p>可以看到，它真的贯彻了一致性哈希的思想，为了能在B节点挂了的时候，能继续服务，让B之后的数个节点都放数据备份。或者看下面这张更细致的图：</p>
<p><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--ptWksqUZ--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_800/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/mwpqwzenp3bb164vwz4m.jpg" alt="chash-storage-detail"></p>
<p>Dynamo也用到了Vnodes，但还是那句话，Vnodes是一个单独的机制，不是一致性哈希的核心，不影响上图的核心思想，所以Dynamo可以说是使用了一致性哈希的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; when a node is removed, the next node (moving clockwise on the ring) becomes responsible for all of the keys stored on the outgoing node.</span><br><span class="line"></span><br><span class="line">ref https://www.educative.io/answers/how-data-is-partitioned-in-dynamo</span><br><span class="line"></span><br><span class="line">是一致性哈希的最核心思想，也是最重要的特点。</span><br></pre></td></tr></table></figure>

<h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><p>TODO 怎么实现的，能不能作为分布式锁？</p>
<p>消息队列的逻辑，就是做和内存队列一样的事。但它的使用场景，是分布式的，内存队列是不可能做到的。通常也不会是单一角色的，所以还涉及多角色。于是，基本都会抽象为，producer发消息给它，它又发给consumers。为了保证可靠和堆积，消息会被MQ持久化。而consumers动态删减，又需要发布-订阅模式。</p>
<p>一个较简单的mq工程可以参考 <a target="_blank" rel="noopener" href="https://github.com/zeromicro/go-queue">https://github.com/zeromicro/go-queue</a> 。注意它是封装者，核心不在它这里，比如它底层接Kafka。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h4 id="RSMQ"><a href="#RSMQ" class="headerlink" title="RSMQ"></a>RSMQ</h4><p>真的MQ算法实现，RSMQ是一种经典方案，简单，具体实现有不少项目。可以看看这个 <a target="_blank" rel="noopener" href="https://github.com/mlasevich/PyRSMQ">https://github.com/mlasevich/PyRSMQ</a> 。</p>
<blockquote>
<p>One simple implementation of a message queue is using Redis. There is a Python implementation of Redis Simple Message Queue (RSMQ) called PyRSMQ . RSMQ emulates Amazon’s SQS-like functionality, where there is a named queue that is backed by Redis. Once the queue is created, producers can place messages in the queue and consumers can retrieve them .</p>
</blockquote>
<p>Here’s an example of how you can use PyRSMQ to implement a simple message queue:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> rsmq <span class="keyword">import</span> RedisSMQ</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create a new instance of RedisSMQ</span></span><br><span class="line">queue = RedisSMQ(host=<span class="string">&quot;localhost&quot;</span>, port=<span class="number">6379</span>, qname=<span class="string">&quot;myqueue&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create a new message in the queue</span></span><br><span class="line">queue.sendMessage().message(<span class="string">&quot;Hello World&quot;</span>).execute()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Receive the next message from the queue</span></span><br><span class="line">msg = queue.receiveMessage().execute()</span><br><span class="line"><span class="built_in">print</span>(msg[<span class="string">&#x27;message&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Delete the message from the queue</span></span><br><span class="line">queue.deleteMessage(<span class="built_in">id</span>=msg[<span class="string">&#x27;id&#x27;</span>]).execute()</span><br></pre></td></tr></table></figure>

<p>这个项目是将redis作为远程存储，同时利用redis的一些功能，去实现一个MQ，不是简单的使用者。</p>
<h4 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h4><p>这是最经典的工程实现了吧，值得多研究研究。</p>
<p>一个队列的基本定义里就应该是有序，不过Kafka并非专注于MQ，它本质是一个分布式事件流平台，并不是RocketMQ，RabbitMQ这些。这一点要注意，Kafka只是可以用来搭建消息队列。</p>
<p><a target="_blank" rel="noopener" href="https://kafka.apache.org/intro">https://kafka.apache.org/intro</a> 官方文档介绍中有提到相关概念。划重点就是，事件驱动。</p>
<p>而消息队列也是消息驱动的，消息来了，订阅者/消费者就要知道。所以Kafka会被拿来作为MQ的底座。</p>
<p>消息队列kafka可以只partition有序，那它能不能保住全局有序？</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://vagetablechicken.github.io/2023/07/31/pwm/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Huang Wei">
      <meta itemprop="description" content="Hey">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wei">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/07/31/pwm/" class="post-title-link" itemprop="url">pwm</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-07-31 19:08:40" itemprop="dateCreated datePublished" datetime="2023-07-31T19:08:40+08:00">2023-07-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-09-02 12:21:57" itemprop="dateModified" datetime="2023-09-02T12:21:57+08:00">2023-09-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="PWM-脉冲宽度调制"><a href="#PWM-脉冲宽度调制" class="headerlink" title="PWM 脉冲宽度调制"></a>PWM 脉冲宽度调制</h1><p>Pulse width modulation，<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Pulse-width_modulation">https://en.wikipedia.org/wiki/Pulse-width_modulation</a></p>
<p>突然想到了大学实验课上的呼吸灯实验，联想起来自己还是不太理解当时为什么要那么写代码，所以这次来深度了解一下。当时只是知道代码写法，并不理解原理，现在才查到是PWM。</p>
<p>首先，PWM并不唯一，它可以用在很多地方，它本身的实现也很多，呼吸灯就是个简单实验而已。</p>
<p>模拟电路的缺点不多说了，总之是希望用数字电路来顶替模拟电路，但是数字电路的输出是高电平或低电平，而模拟电路的输出是连续的，可以是高低电平范围内的任何一个值，PWM就是来解决这个取值问题的。</p>
<p>硬件，比如LED灯，本来就是可以接收一个范围的电压，并给与相应的亮度，当然，此处还是理想地说，电压是稳定的一个值，LED就在那里亮着。如果LED接受的电压不是稳定的，是脉冲呢？假设脉冲很慢，1s高，1s低，我们就能看到LED在闪烁，但是如果脉冲很快，比如10ms高，10ms低，我们就看到LED是亮的，但是亮度不是100%，而是50%（10ms仅仅是个假设，我不知道具体什么频率才能让人眼看到，频率过快应该跟常亮没有区别）。100Hz应该就看不到闪烁了。这就是PWM呼吸灯的基础，PWM调光，PWM Dimming。</p>
<p>有了Dimming，我们可以在LED上实现各种亮度，比如50%，75%等等，只要每一小段时间变换亮度，就能实现呼吸灯。</p>
<p>那么，PWM Dimming具体什么样子？</p>
<p>可以想象，如果当前给一条高电平直线，我们看到的是常亮；如果直线中每个1s只出现1ms的低电平，那个时候LED肯定是熄灭的，但持续低电平时间太短了，人眼根本无法察觉，而且LED还可能有余晖，不会瞬间黑了，就更加容易掩盖熄灭的时间，也就是视觉残留。</p>
<p>但为何视觉残留，就能完美模拟出0-100%的亮度呢？我们为什么<strong>不能</strong>从50%空占比（Duty Cycle）中捕捉到那么一瞬的高于50%的亮度？这个从经验上有人总结过，就是说，人眼看到的是一种平均值，而不是瞬间的值，所以，如果LED的空占比是50%，那么人眼看到的就是50%的亮度，而不是瞬间的100%亮度。这个叫做<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Talbot-Plateau_law">Talbot-Plateau Law</a>，中文名不统一，可能叫塔尔博特-普拉托定律。它是由实验支撑的，就是那个黑白盘，又称扇形实验。</p>
<p><img src="https://en.wikipedia.org/wiki/File:Talbot-Plateau_disk.png" alt="圆盘"></p>
<p><img src="https://pic3.zhimg.com/v2-214e5dfea486d22f905b465587e8cd0a_b.jpg" alt="PWM调光"></p>
<p>圆盘的一个环和PWM调光的某个亮度是类似的，转起来后，我们人眼就是看到了一个平均值，而不是瞬间的值。背后的生物理论还不了解，但这个实验还是能让人理解，我们人眼确实是被这么骗了。</p>
<p>顺带一提，PWM虽然骗过人眼感受，但实际还是让我们的眼部细胞被迫处理瞬时的变化。所以有些PWM频率过低，会让人眼睛类，甚至头疼。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://vagetablechicken.github.io/2023/01/08/parallel-computing/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Huang Wei">
      <meta itemprop="description" content="Hey">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wei">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/01/08/parallel-computing/" class="post-title-link" itemprop="url">ParallelComputing</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-01-08 18:34:22" itemprop="dateCreated datePublished" datetime="2023-01-08T18:34:22+08:00">2023-01-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-07-31 18:56:53" itemprop="dateModified" datetime="2023-07-31T18:56:53+08:00">2023-07-31</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Why-Use-Parallel-Computing"><a href="#Why-Use-Parallel-Computing" class="headerlink" title="Why Use Parallel Computing?"></a>Why Use Parallel Computing?</h1><p>blabla.<br>但真正让我感受到计算能力的有限，是在一次物理大作业中。具体的内容记不清了，但反正需要matlab写出三重for循环，来找出极值。然后CPU就开始疯狂转了，等了老半天才出结果。<br>虽然这个作业能不能并行化，我也记不清了，但是，它让我体会了电脑算力不如我想象的高（我还用的是笔记本电脑，性能比较差）。以前我真的认为要很大的数据规模，才会需要服务器，超算。</p>
<p>直到后来更加系统学习了算法的一些知识，每次估算算法时长时，才发现，CPU的几GHz其实也挺小的。算出某个算法要几个小时才能跑完时，就会想，CPU如果再快个几倍该多好。</p>
<p>semaphores <a target="_blank" rel="noopener" href="https://greenteapress.com/wp/semaphores/">https://greenteapress.com/wp/semaphores/</a><br>java <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/tutorial/essential/concurrency/procthread.html">https://docs.oracle.com/javase/tutorial/essential/concurrency/procthread.html</a> book … in practice</p>
<p>books, need to read?<br><a target="_blank" rel="noopener" href="https://www.amazon.co.uk/Introduction-Parallel-Computing-Ananth-Grama/dp/0201648652/ref=sr_1_2?ie=UTF8&amp;s=books&amp;qid=1279904224&amp;sr=8-2">https://www.amazon.co.uk/Introduction-Parallel-Computing-Ananth-Grama/dp/0201648652/ref=sr_1_2?ie=UTF8&amp;s=books&amp;qid=1279904224&amp;sr=8-2</a><br><a target="_blank" rel="noopener" href="https://www.amazon.co.uk/Parallel-Scientific-Computing-MPI-Implementation/dp/0521520800/ref=sr_1_3?ie=UTF8&amp;s=books&amp;qid=1279904267&amp;sr=1-3">https://www.amazon.co.uk/Parallel-Scientific-Computing-MPI-Implementation/dp/0521520800/ref=sr_1_3?ie=UTF8&amp;s=books&amp;qid=1279904267&amp;sr=1-3</a></p>
<h1 id="一些演变过程"><a href="#一些演变过程" class="headerlink" title="一些演变过程"></a>一些演变过程</h1><p>参考《Java Concurrency in Practice》第1章。</p>
<p>最初，只存在单进程。后来，操作系统引入多进程，多进程可以简化代码编写的难度，因为你可以只对一种任务写一个程序。各个程序间可以交互，而调度交由操作系统。<br>-&gt; 比在单进程中塞各种任务更容易。（此时串行的基本单位是进程，所以这里说“单进程”）</p>
<p>后来出现多核，多处理器，单个程序也可以不串行，也就是多线程。不仅是提高资源利用率，而且把一个程序拆成多个子任务，每个任务的逻辑单独编写，必要时再交互，也可以简化程序逻辑。<br>-&gt; 比在单线程中塞不同子任务更容易。（因为此时有多线程了，串行的基本单位是线程，所以这里说“单线程”。实际要表达的是一样的。）</p>
<p>但由于操作系统也是慢慢进化的，早期的操作系统通常会将进程中可创建的线程数量限制在一个<strong>较低的阈值</strong>内，大约在数百个（甚至更少）左右。因此，操作系统提供了一些高效的方法来实现多路I/O，例如 Unix 的 select 和poll 等系统调用，要调用这些方法，Java 类库需要获得一组实现非阻塞 IO 的包 (java.nio）。然而，在<strong>现代操作系统</strong>中，线程数量已得到极大的提升，这使得在某些平台 上，即使有更多的客户端，为每个客户端分配一个线程也是可行的。</p>
<p>也就是说，理论上肯定是多线程+阻塞I/O更好（指线程中使用BIO），可以降低开发难度，线程调度不需要我们操心。但现实是，过于多的线程就可能带来问题。线程使用的内存，线程上下文切换的CPU开销，在“过于多的线程”这个场景下，可能就是内存占的很多，处理速度也不快。可能使用NIO效果会更好，当然，是在某些场景下，无法绝对论。所以，NIO还不会被淘汰（虽然它真的有点复杂，不好理解，又是考点😂）。</p>
<h1 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h1><p>Java中线程封闭里有个特别点是ThreadLocal，它就是简化一下写法，并不是什么黑魔法。</p>
<p>首先，理解下ThreadLocal的原理，你使用ThreadLocal::get/set时，内部是去取该线程的ThreadLocalMap，注意Map是存在Thread里的，set就是set值到这个Map，kv是&lt;this（指ThreadLocal对象）, value&gt;，那么也说，一个ThreadLocal对象是同一个没错，但实际get出来的是从某个Thread对象的ThreadLocalMap里拿出来的value。（而不是一个ThreadLocal里存thread到value的映射）</p>
<p>需要注意，每个Thread里对ThreadLocal对象做set，是线程隔离了，各个线程之间不共享。但要是你set同一个value，那本质上还是多线程共享同一个对象。</p>
<p>那么，什么时候用的上ThreadLocal呢？为什么要用它，而不是每个线程都维护一个自己的对象？</p>
<p>网上大部分的ThreadLocal举例都是什么UniqueId、DateFormat，它们完全体现不出ThreadLocal的优点，反而像画蛇添足，原子变量都可以的为什么非要ThreadLocal写UniqueId，每个线程就可以有自己的成员变量直接new DateFormat不就行了，为什么要ThreadLocal来创建DateFormat。</p>
<p>我们先抽象一下场景，假设Thread内会创建某个对象，不管合不合适，我们将它存在Thread类的成员变量里，那么，多线程是new 多个Runnable或者多Thread，才能做到线程之间互不干扰。</p>
<p>如果是create一个Runnable，多线程都由这一个Runnable初始化，那这里就有限制了，多Thread实际用的一个Runnable对象，那多线程肯定就互相干扰了，这时候把Runnable里的成员变量直接改为ThreadLocal的，就可以立马获得线程安全的程序。这是一种ThreadLocal的好处，它可以简单地将单线程程序改成多线程程序。</p>
<p>再考虑这样一个场景，我们有多个函数，它们不是Thread/Runnable的函数，是别的类的，它们的输入都是context，每个线程单独一个context，那使用方式就是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">context = new Context</span><br><span class="line">A.func1(context)</span><br><span class="line">B.func2(context)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>那如果你不想这么频繁传递，比如，<code>A.func1()</code>这些函数内部可以写为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context = ContextTL.get()</span><br></pre></td></tr></table></figure>
<p>它们就自然获得该线程的context，那么这个ContextTL自然用ThreadLocal来做，就可以达到目的。使用方式就变成了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">context = new Context</span><br><span class="line">ContextTL.set(context)</span><br><span class="line">A.func1()</span><br><span class="line">B.func2()</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>单实例变量或全局变量共享，就是这么个意思。没有ThreadLocal的话，set 类static变量当然是线程不安全的，有了ThreadLocal就可以。在线程的角度看来，就像是单线程的情况下，去set一个跟别的对象共享的变量。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://vagetablechicken.github.io/2022/10/07/abs-algo/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Huang Wei">
      <meta itemprop="description" content="Hey">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wei">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/07/abs-algo/" class="post-title-link" itemprop="url">抽象算法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-10-07 19:48:30" itemprop="dateCreated datePublished" datetime="2022-10-07T19:48:30+08:00">2022-10-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-07-31 18:56:53" itemprop="dateModified" datetime="2023-07-31T18:56:53+08:00">2023-07-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Algo/" itemprop="url" rel="index"><span itemprop="name">Algo</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>很多题目都有基础的数据结构和算法，但也有它独特的corner case。所以，本文主要记录抽象的算法，避免重复记录。</p>
<h2 id="Quick-Sort"><a href="#Quick-Sort" class="headerlink" title="Quick Sort"></a>Quick Sort</h2><p>快速排序</p>
<p>快排容易想的方法是3个while，一个while外循环，加每次左标移动和右标移动两个while。但这个翻译成代码很容易出错，主要是感觉while的保护和退出条件不容易记忆。出错了，你没法跑单测就很难补好洞。虽然面试的自己可能都写不出来，但他复制你的代码去跑，那就还是你gg。所以我倾向于记忆单循环的写法，主要是不需要什么保护和退出，简单。不过，3 while确实更加贴近抽象算法的原理，可以尝试记忆一下。</p>
<p>我们记锚点为pi，它位置上的值为piv。</p>
<h3 id="单循环思路"><a href="#单循环思路" class="headerlink" title="单循环思路"></a>单循环思路</h3><p>快排建议记忆单循环的写法，该写法也不用死记，需要记住几个点：</p>
<ul>
<li>单次循环，那么就是把每个比piv（pivot的value）小的数都挪到前面去。</li>
<li>第一次挪怎么挪？第一个数是piv，从第二个数开始比大小，如果第二个数小于piv，是原地不动还是扔到第一个位置？这里重点记忆<strong>不要交换pivot，pivot最后再交换</strong>。可以推理出，第二个数如果小于piv，就应该放在第二个位置，就是原处。如果它大于等于piv，它不动，就比下一个数，如果它小于piv，就挪到前面去。<ul>
<li>总结规则是：当某数大于等于piv时，是跳过，直接看下一个数。如果小于piv，交换，交换到此处的值，可能是大于等于piv的，也可能就是原地交换（比如piv就是最大的值，就会一直触发原地交换），但反正不用再次考虑，还是可以直接下一个数。</li>
</ul>
</li>
<li>遍历完成后，就形成了三块区域，[piv, &lt; piv, &gt;=piv]。这个时候交换piv和&lt; piv的最后一个数，区域就可以变成[&lt; piv, piv, &gt;=piv]，符合快排partition后的结果。</li>
<li>partition函数有了，快排的递归partition怎么写？重点要注意的是怎么标记partition的输入范围，是左闭右开，还是全闭？目前感觉都可以，因为快排的衍生问题都是pivot很重要，区间问题不影响pivot，pivot不会漂移。<br>所以伪代码写为：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">def partition:</span><br><span class="line">	# [lo, hi)</span><br><span class="line">	piv, j = a[lo], lo</span><br><span class="line">	for i in range(lo+1,hi):</span><br><span class="line">		if a[i] &lt; piv:</span><br><span class="line">			j ++</span><br><span class="line">			swap i,j</span><br><span class="line">	swap lo, j</span><br><span class="line">	return h</span><br><span class="line">def qsort:</span><br><span class="line">	if lo + 1 &gt;= hi: # 长度为1或0都不需要排序</span><br><span class="line">		return</span><br><span class="line">	pi = partition(a, lo, hi)</span><br><span class="line">	qsort(a, lo, pi) # 这里指排序[lo,pi)，pi不参与排序</span><br><span class="line">	qsort(a, pi+1, hi)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>如果partition函数像做成全闭的，那么&lt; piv的游标j和循环的取值范围，以及qsort里的退出条件和qsort递归范围变化一下就好了，没什么坑。<br>如果侥幸你记得pivot可以选最右（我每次都记不得），那么&lt; piv的游标j和循环的取值范围要改一下，以及最后应该交换pivot和j+1。感觉没简单化什么东西，不必记忆。</p>
<p>判断条件用 &lt;= 或 &lt; 应该都可以，只要能保证最后pivot的交换能满足快排定义。看网上题解 &lt;= 多，但我觉得 &lt; 挺好用的，减少一些swap可能，比如<a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000004410119">这个题解就是用的小于做判断</a>，<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/kth-largest-element-in-an-array">oj</a>上也没测出问题来。</p>
<h3 id="3-while思路"><a href="#3-while思路" class="headerlink" title="3 while思路"></a>3 while思路</h3><p>3 while思路，推荐在<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Ya4y1x771?p=7">陈斌老师的写法</a>上改进一点点，也就是去掉done这个flag，没什么必要加它。3 while思路的难写点在于，双mark写法过长，可能做不好越界保护。</p>
<p>首先看基础思路：</p>
<p>我们先暂时放下while的保护条件，先讨论理想情况。两个游标怎么游？算法中不是要&lt; piv, piv, &gt; piv，毕竟可能piv有多个，而是&lt;=piv, piv, &gt;=piv，<strong>注意，两边都可能==piv，不是必须在哪一边</strong>。因此内层两个while判定条件是&lt;=piv ++,  &gt;=piv –，遇到等于的可以继续游，不需要停下。<br>所以伪代码可写为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">while True:</span><br><span class="line">	while … and [lmark]&lt;=piv: lmark++</span><br><span class="line">	while … and [rmark]&gt;=piv: rmark--</span><br><span class="line">	some cases</span><br><span class="line">	exchange</span><br><span class="line">handle pivot</span><br></pre></td></tr></table></figure>
<p>很明显，内层2个while不可能让2个mark一直++/–，所以我在2个while判断的最前面都留了保护条件。</p>
<p>让我们思考下这个保护和2个while结束后，哪些情况不能走到exchange，或者得直接退出外层while。</p>
<p>首先，可以提醒自己<strong>交换价值</strong>，就是2个mark什么时候是需要交换的，值得交换的，不值得的时候，可能要跳过或退出（也就是上面代码的some cases）。通常的看，当然是lmark &lt; rmark时应该交换，lmark==rmark和lmark &gt; rmark时都是不应该交换的。那么，假设走完内层2个while时可以存在lmark==rmark的情况，我们该干什么？</p>
<p>如果while保护条件为lmark &lt; rmark，那很可能出现这个lmark==rmark。可能是lmark知道了前面的值&lt;= piv，所以++到了此处，由于保护条件，第2个while就也跳过了。又或者lmark确实到了此处，它&gt;piv，rmark又走过&gt;=piv的值，到了此处，被保护条件卡住。可能还有别的情况，但总的来讲，就是<strong>你无法明确lmark==rmark时，这个位置的值是个什么情况，它没有保证</strong>。为了这个情况，就得单独去判定大小，并看往哪儿放。不是说不可以这么写，就是挺麻烦。</p>
<p>举例说明：</p>
<p>[5,7,2,8]它以5为piv，会交换一次7和2，成为[5,2,7,8]，然后就会遇到lmark==rmark，也就是7所在的位置2。简单地想，pivot 5和双mark指向的7应该交换，但是这个例子不能，得先判断出7比piv大，不能动，然后往左看到2，发现它可以和piv交换。这里又会衍生，要不要保护，pivot是不是就是最小的，不用交换等等情况。特殊情况就很多，很烦，容易想漏想错。</p>
<p>所以再换个思路。如果保护条件是lmark &lt;= rmark，就会发现，走过2个while后，不存在lmark==rmark的情况（可以assert看看）。因为一个数它跟piv比只有三种情况，而三种情况，两个游标都不可能同时停下，必然有人要跨过去，所以安全。那么，lmark&gt;rmark时我们退出外层while，这时候如何处理pivot？会不会比前面思路的处理逻辑简单？</p>
<p>lmark &gt; rmark除了这个位置关系，数组当前会是什么情况，能保证一些什么关系？首先明确它们只可能是lmark=rmark+1，就是相邻的，不可能交错后继续拉开距离。</p>
<ul>
<li>lmark &gt; rmark可能是lmark先走，触发保护，然后rmark的while直接跳过。这个情况，lmark都能穿过rmark，自然lmark的左边（不包含自己）都是&lt;=piv的。此时rmark可能是走动过，也可能是完全没移动过，但都ok。走动过，那么它必然是停在了&lt; piv 的值上，也保证它的右边全是&gt;= piv的。这个大小关系下，很自然，pivot和rmark交换下就好了，把&lt; piv的值放到最左边，很合理。如果rmark没走动，那它就在最右边，lmark又保证了除pivot以外整个区间都&lt;=piv。这个情况把pivot扔到最右边也很合理。</li>
<li>lmark停在了&gt;piv的值上，rmark一直往左，穿过了lmark。这里也保证了rmark的右边都是&gt;=piv的，rmark当前位置好像unknown，因为rmark只是因为保护停下。但考虑到lmark停在此处，当然是rmark停在了&lt;=piv的值上，而lmark在紧邻的右边。这个关系下，pivot和rmark交换，也很合理。那如果lmark压根儿没走动，rmark就走到了pivot这个最左边的点上，原地交换下也没错。</li>
</ul>
<p>可以看到，保护条件是lmark &lt;= rmark时，rmark指向的值有明显的大小保证，不需要再次确认什么。所以，用lmark &lt;= rmark这样的保护条件最好，对应的lmark &gt; rmark时退出外层while。<strong>重点记忆，“交错”(lmark&gt;rmark)就停止</strong>，自然，不交错的话游标还可以继续跑，所以内层2while的保护条件是lmark &lt;= rmark。（这个记忆法仅用于记忆，没办法去推理代码的完备性。）</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><strong>核心是“交错”，交错就停止，只要不交错，3 while都可以继续</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">while True:</span><br><span class="line">	while lmark&lt;=rmark and [lmark]&lt;=piv: lmark++</span><br><span class="line">	while lmark&lt;=rmark and [rmark]&gt;=piv: rmark--</span><br><span class="line">	if lmark &gt; rmark:</span><br><span class="line">		break</span><br><span class="line">	exchange</span><br><span class="line">exhange rmark and left</span><br></pre></td></tr></table></figure>

<p>实际oj测试，还是双mark速度快点。</p>
<p>另一种写法见<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/solution/jian-zhi-offer-40-zui-xiao-de-k-ge-shu-j-9yze/">leetcode题解</a>，3 while用的i &lt; j，注意写法是右标先移动，否则有问题。这种大概率记不住，先左后右比较顺。</p>
<h2 id="Binary-Tree-Traversal"><a href="#Binary-Tree-Traversal" class="headerlink" title="Binary Tree Traversal"></a>Binary Tree Traversal</h2><p>二叉树遍历</p>
<p>二叉树的三种遍历递归写法都没难度，不过稍微加点东西就容易搞不定了。还是不够熟悉递归，不够熟悉将稍复杂的逻辑想清楚，所以转换为代码会卡住。</p>
<p>另外，再注意一下，先序、中序、后序都是看的当前节点cur，所以先是cur-left-right，中是left-cur-right，后是left-right-cur。不要认为后序就是right要放前面了，有时候容易脑子短路。</p>
<h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">https://leetcode.cn/problems/binary-tree-inorder-traversal/</a></p>
<p>中序递归遍历，一般就用result数组来存结果就行了，因为result在递归中也是一个一个append结果的。拼接的写法<code>inorder(root.left)+[root]+inorder(root.right)</code>大可不必，空间消耗有点过分了，也没简单多少。</p>
<p>而中序迭代遍历，该怎么写？首先得加个辅助结构，或者改当前的数据结构，否则不够用。</p>
<p>我们先说“加辅助结构”的算法。中序是左-中-右，递归不用额外结构因为它可以回到中，即使已经在左子树游了一圈了。那迭代就需要记住中，因二叉树单向的，往下走回不来，不缓存起来就回不去。不管是栈还是队列，一维数组肯定够了。当然一般“递归-&gt;迭代”都是栈，递归本质也是先进后出。</p>
<p>再看怎么使用栈，其实就是模仿递归，递归往左下走到底后，可以逐步回来，所以迭代里就应该往左下走，并且记录每个“中”节点。到底后，就可以向result加结果了。拿最左的叶子节点举例，它左子节点None了，就类似递归回到了它，它作为中节点，被加入result，那么此时还应该考虑它的右子节点。而以这个右子节点作为起始，做的实际还是中序遍历，不过是子树的中序遍历，所以这里代码可以复用，只需要以右子节点作为起始节点。可以看出，中先进栈，左子再进，把左子和中都弹出栈后，右子才会进栈，不用担心右子节点遍历完了后就断了，因为中的上一层还在栈里面。</p>
<p>伪代码写作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cur = root</span><br><span class="line">stack = []</span><br><span class="line">while ?:</span><br><span class="line">	while cur:</span><br><span class="line">		cur -&gt; stack</span><br><span class="line">		cur = cur.left</span><br><span class="line">	# no more left child, cur == None now</span><br><span class="line">	top = stack.pop</span><br><span class="line">	top -&gt; result</span><br><span class="line">	cur = top.right # next loop will traversal the right child</span><br></pre></td></tr></table></figure>

<p>最后看终止条件怎么写，stack为空，没法pop，肯定得保护，但是因为内层while也在填充stack，所以并不是stack为空就得终止，内层while可能会补充。不过如果cur和stack都为空，那就没必要了。</p>
<p>所以终止条件为<code>while cur or stack</code>。</p>
<h3 id="前序遍历-先序遍历"><a href="#前序遍历-先序遍历" class="headerlink" title="前序遍历/先序遍历"></a>前序遍历/先序遍历</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-preorder-traversal/">https://leetcode.cn/problems/binary-tree-preorder-traversal/</a></p>
<p>递归写法是“中-左子-右子”，因为中就是当前，左子就<code>.left</code>往左走就行了，所以只需存右子，且是先进后出。用简单例子演示一遍也可以知道，伪代码可以写作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">stack, cur = [], root</span><br><span class="line">while ?:</span><br><span class="line">	if not cur:</span><br><span class="line">		cur = stack.pop</span><br><span class="line">	cur -&gt; result</span><br><span class="line">	if cur.right: -&gt; stack</span><br><span class="line">	cur = cur.left # be the new traversal root</span><br></pre></td></tr></table></figure>

<p>最后看终止条件，stack为空，如果有cur，也可以走下去（比如root节点）；如果cur为空，stack还有，也能走（比如走到树的最底层，但树右边还有节点没遍历到）。所以终止条件还是<code>while cur or stack</code>。</p>
<h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-postorder-traversal/">https://leetcode.cn/problems/binary-tree-postorder-traversal/</a></p>
<p>依然要记牢，迭代就是模拟递归，所以这里依旧需要用栈来模拟递归时天然拥有的栈信息。递归是“左子-右子-中”，所以还是先把最左边的路走通，存下每个左子。每个左子从栈中取出时，我们假设某个节点名为node1，都应该先把node1右子当作新的root，把右子树走完，才回到这个node1。只拿到node1，是可以找到其右子的，但是node1此时不出栈，我们会再次拿到它，如何区别它的两个状态（该让右子进栈，还是就该它出栈，它完成遍历）？</p>
<p>这里比较常规的想法是要不栈就存&lt; node, flag &gt;，通过flag来，进栈的flag都为false，如果我们将它右子放进栈，就把flag改为true。下次pop出flag为true的node，就跳过压右子，直接让它进入result，视为它和它的子树都完成了遍历。</p>
<p>但其实还可以更简单，需要察觉到一个关系问题。比如，栈目前是[1,2]，然后2是叶子，2出栈。然后我们看到1，1有右子3，那么此时就是[1,3]，注意一定有node1.right==node3这个关系。3的子树怎么操作，不用关心，假设它已经完成了，此时应该3出栈了，栈又变成了[1]，而如果我们记住了3，当我们看到栈里的1，有node1.right==node3时，就知道了，node1的右子node3已经访问过了，node1可以出栈了。这个关系完全是即时的，它只需要记住出栈的节点，所以只需要一个变量就可以，通常记为pre。pre可行的原因就是遍历的连续性，右子节点出了，马上就是中这个节点出，中间不会夹杂别的。记住右子，就能判断出中是第二个状态了，不需要再管右子节点。</p>
<h2 id="skiplist"><a href="#skiplist" class="headerlink" title="skiplist"></a>skiplist</h2><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/czkZcQL8mEqG2xeX8huqsA">https://mp.weixin.qq.com/s/czkZcQL8mEqG2xeX8huqsA</a></p>
<h2 id="Heap"><a href="#Heap" class="headerlink" title="Heap"></a>Heap</h2><p>堆，一般指二叉堆。</p>
<p>我们希望有一个数据结构，它可以迅速pop出最小的，push一个新的数也希望是对数时间里完成，这样的时间复杂度才有价值，不然简单的有序数组pop/push都是O(n)就足够了，还简单。</p>
<p>这个理想的数据结构，应该考虑树形，毕竟对数时间。</p>
<p>再说什么树，因为没有什么限定条件，二叉树就是最简单的。然后再想，n个数去构建二叉树，如果n不是2^k-1，那这个二叉树就不满，不满也不能乱搞，因为对数时间，你当然希望这个树足够矮小，不然最坏情况又是线性了。所以平衡二叉树是理想形态。</p>
<p>而平衡二叉树并不必须用链表作为节点，<strong>它可以用连续数组表示</strong>。这也是让代码更简单的一个优点。</p>
<p>再来说说堆的基本操作逻辑。</p>
<p>一个是pop，pop出堆顶后，树的根节点就空了，这个“树”就不是有效的树了，那得想个办法修好，办法就是把最尾部的元素移动到堆顶，这个时候不满足堆有序，那么就去让它有序，画画图也可以发现，只有堆顶也就是根节点不符合堆有序，那么调整根节点和它的两个子节点，比如它和左子节点交换，它们三个就堆有序了。但因为左子节点变了，它和它的两个子节点可能又乱了，就继续调整。一层一层往下，也叫做“下沉”。只会沿着某一条路径下沉到叶子，所以复杂度是logn，不会影响别的路径。</p>
<p>二是push，新增一个元素到已形成的堆，将新元素塞入树中间显然不合理，放在最后一个位置，就像是多给某个节点加了个子节点。然后，这个节点和它的一个或两个子节点，可能不满足堆有序，就需要调整。调整后，它作为子节点，可能又不能有序，于是就一直“上浮”，上浮到根节点就结束了。同样的，只会影响一条路径，也是O(k)（k层的树，n个节点树高也就是k=logn）。（如果当前堆已经满了呢？新加的节点，在逻辑上看，就是树多加了一层，这一层只有一个节点。说得通。）</p>
<h3 id="Python-heapq"><a href="#Python-heapq" class="headerlink" title="Python heapq"></a>Python heapq</h3><p>再提一嘴python的heapq，优先队列一般底层结构就是二叉堆，具体二叉堆怎么实现都行，python这里也是使用数组，但是它的内部方法实现不是前面提到的算法，它更高效，可以仔细看下heapq的实现和注释，实名diss了前面的常规算法???。但这个不影响时间复杂度，不可能比logn更小，只是时间优化。（heapq算法里的siftup,siftdown和上浮下沉就对不上了。有空可以学习下。）</p>
<p>heapq原理在代码里也不过，就观察下整个源码实现吧。</p>
<ul>
<li><p>heappush，就是新加一个elem到heap，源码实现为，append到数组末尾，然后siftdown(0,last),第二个参数last指从这个节点开始，往上走到第一个参数0，也就是根节点。其实就是一次上浮（对应Algorithm 4th的swim），但不知道为什么叫down？</p>
<blockquote>
<p> Pasanen, Tomi (November 1996). Elementary Average Case Analysis of Floyd’s Algorithm to Construct Heaps (Technical report). Turku Centre for Computer Science. CiteSeerX 10.1.1.15.9526. ISBN 951-650-888-X. TUCS Technical Report No. 64. Note that this paper uses Floyd’s original terminology “siftup” for what is now called sifting down.<br><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Binary_heap#cite_ref-13">https://en.wikipedia.org/wiki/Binary_heap#cite_ref-13</a></p>
</blockquote>
<p>  Floyd大概是<a target="_blank" rel="noopener" href="https://dl.acm.org/doi/pdf/10.1145/355588.365103">这一篇</a>，里面siftup确实是j=2*i，往下走的，可能python heapq按照这个逻辑来的吧。</p>
</li>
<li><p>heappop，和抽象的算法没有区别，把堆顶拿走，把最后一个数放到堆顶，然后下沉（sink），只是heapq里叫siftup。siftup有个神奇的点是它在最后call了一次siftdown。注意整个siftup的实现，简化一下是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> siftup(pos):</span><br><span class="line">newitem = heap[pos]</span><br><span class="line">while childpos &lt; endpos:</span><br><span class="line">	childpos = max(left, right)</span><br><span class="line">	heap[pos] = heap[childpos]</span><br><span class="line">	pos = childpos</span><br><span class="line">heap[pos] = newitem</span><br><span class="line">siftdown(pos)</span><br></pre></td></tr></table></figure>
<p>  它并不是在while里，用当前pos跟它的两个子节点比大小，选择跟哪个子节点交换，而是无条件交换。也就是说while不是一次完整下沉，所以是while+siftdown组成一次完整下沉。<br>  看下它的<a target="_blank" rel="noopener" href="https://github.com/python/cpython/blob/e47b13934b2eb50914e4dbae91f1dc59f8325e30/Lib/heapq.py#L221">注释</a>。</p>
</li>
</ul>
<p>在这个函数之前的评论区中，作者已经解释了他们为什么做出这样的选择，这初看起来效率较低，但在实践中却发现会导致更少的比较。</p>
<p>We could break out of the loop as soon as we find a pos where newitem &lt;= both its children, but turns out that’s not a good idea, and despite that many books write the algorithm that way. During a heap pop, the last array element is sifted in, and that tends to be large, so that comparing it against values starting from the root usually doesn’t pay (= usually doesn’t get us out of the loop early). See Knuth, Volume 3, where this is explained and quantified in an exercise.</p>
<p>heapq提供<a target="_blank" rel="noopener" href="https://github.com/python/cpython/blob/e47b13934b2eb50914e4dbae91f1dc59f8325e30/Lib/heapq.py#L147">heapreplace</a>，也就是把堆的pop和push两步放在一步完成，因为size恒定。你如果pop[0]，就把新的元素放在[0]就行，让它下沉。</p>
<p>注意heapq.heapreplace是一定replace的，它不会管你想push的元素会不会比heap top更小。它一定输出heap的top，再把push值塞进heap里。不过我们这个题目，是可以保证push的大于等于heap top的，不会有问题。</p>
<p>如果没有这一点保证，你想做的事情就应该抽象为“push后pop”（当然内部应该优化，不是愚蠢地真的push后又pop），因为你想从heap和想push的新值一起看的集合中最小的值，可以使用headpq.heappushpop。不过，这个自己写也行，逻辑不复杂，就是先peek一下堆顶，如果push的新值更小，就直接返回，如果不是，就把堆顶值取出，把新值放在堆顶，然后堆化。</p>
<h2 id="Ugly-Number"><a href="#Ugly-Number" class="headerlink" title="Ugly Number"></a>Ugly Number</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/ugly-number-ii/">https://leetcode.cn/problems/ugly-number-ii/</a></p>
<p>丑数，听到题目很自信，dp[i]表示i这个数字是不是丑数。然后直接超时GG。一个重要现实，<strong>大部分的数不是丑数</strong>，所以会很膨胀，比如n=476时，第476个丑数已经达到737280，73w了，太多数字不是丑数了。所以不应该用动态规划的i表示i这个数，而是表示第i个丑数。</p>
<p>去判断1个数字是否为丑数，这种一次性的判定，不去利用缓存是可以理解的，但找第i个丑数，当然不可能每个每个数字去判定，应该去找与前面的丑数的规律。所以，如果没想出动态规划怎么做，收集所有丑数，直到第n个，也是个办法。由于一个数<em>2，</em>3，*5都是丑数，但下一个丑数 *2不一定比前面的丑数 *3大，所以得排序。于是有了直接把数字插入堆里排序，这种方法，保证每次拿出最小的丑数来。第一次将1放入，1取出，2，3，5都放进去，反正1是最小的，可以安心输出。再从堆里取最小，2，2的2，3，5倍都是丑数又放进堆里。但注意得到2的3倍6进去了，3的2倍6又会进入堆一次，所以堆中拿出的丑数有重复，堆中拿出的丑数需要确认无重复，可以用map/set的key来去重，等map/set收集到第n个丑数时，停止收集。</p>
<p>再仔细理解一下人的解题思路。我们知道最小丑数是1，此时只能衍生出3个丑数2、3、5都是丑数，就三个选择，取最小的2，作为下一个丑数，而这个丑数又可以衍生出2<em>2,2</em>3,2*5三个，加上前面还没用上的的3和5，可以看到，这么想的话很膨胀，备选数会越来越多。但当前最后的丑数2，它的3倍5倍都很大，没必要此时就参与比较，只有2 * 2较小，可以和1的3倍和5倍比一比，谁是下一个丑数。但它们也不能被丢掉，后面的比较里它们也要成为备选。所以，换个角度，不要从“每个数的2、3、5倍都是丑数”这样发散，而是从“每个丑数都要被2、3、5乘”来考虑。也就是说，2、3、5它们三个要跟我们已生成的丑数序列的每个数都乘一次，且只需要一次，用完就扔，跳到下一个丑数去。</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/ugly-number-ii/solutions/714340/gong-shui-san-xie-yi-ti-shuang-jie-you-x-3nvs/">这个题解</a>的说明更加清晰，推荐阅读。</p>
<p>这个思路可行后，还需要注意2 * 3和3 * 2这个重复问题，以2为例，看到当前的a[i] * 2 == a[-1]，那么应该取下一个a[i+1] * 2作为竞争者，跳过a[i]。所以我的代码是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def nthUglyNumber(self, n: int) -&gt; int:</span><br><span class="line">        a = [1]</span><br><span class="line">        L = [0,0,0,0,0,0]</span><br><span class="line">        # L[i] = pi, candidate is a[L[i]]*i, i = 2,3,5</span><br><span class="line">        while len(a) &lt; n:</span><br><span class="line">            if a[L[2]]*2 == a[-1]: L[2]+=1</span><br><span class="line">            if a[L[3]]*3 == a[-1]: L[3]+=1</span><br><span class="line">            if a[L[5]]*5 == a[-1]: L[5]+=1</span><br><span class="line"></span><br><span class="line">            # 3 candidates</span><br><span class="line">            m = 2</span><br><span class="line">            min_n = a[L[2]]*2</span><br><span class="line">            if min_n &gt;= a[L[3]]*3:</span><br><span class="line">                m,min_n = 3, a[L[3]]*3</span><br><span class="line">            if min_n &gt;= a[L[5]]*5:</span><br><span class="line">                m,min_n = 5, a[L[5]]*5</span><br><span class="line">            L[m] += 1</span><br><span class="line">            a.append(min_n)</span><br><span class="line">        # print(a)</span><br><span class="line">        return a[-1]</span><br></pre></td></tr></table></figure>
<p>就是在侯选前，去跳越重复值。<br>但更简单的写法是，在后面跳跃，比如[1,2,3,4,5]后的下一个丑数备选是3 * 2，2 * 3，2 * 5这三个，它们取出的最小值是6，但没必要取看它是丑数 *2还是 *3的结果，因为这两个指针都应该++。所以，更简洁的代码是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">while :</span><br><span class="line">	min_n = min(a[p2]*2, a[p3]*3, a[p5]*5)</span><br><span class="line">	if min_n == a[p2]*2:</span><br><span class="line">		p2 += 1</span><br><span class="line">	if min_n == a[p3]*3:</span><br><span class="line">		p3 += 1</span><br><span class="line">	if min_n == a[p5]*5:</span><br><span class="line">		p5 += 1</span><br><span class="line">	a.append(min_n)</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://vagetablechicken.github.io/2022/09/23/big-data/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Huang Wei">
      <meta itemprop="description" content="Hey">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wei">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/23/big-data/" class="post-title-link" itemprop="url">BigData</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-09-23 14:27:15" itemprop="dateCreated datePublished" datetime="2022-09-23T14:27:15+08:00">2022-09-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-07-31 18:56:53" itemprop="dateModified" datetime="2023-07-31T18:56:53+08:00">2023-07-31</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="BigData-Interview-Questions"><a href="#BigData-Interview-Questions" class="headerlink" title="BigData Interview Questions"></a>BigData Interview Questions</h1><p>涉及大数据的面试题，通常是没法写代码的。当然，也有部分题目本质上是归并、堆或是快排等算法，那就还能写写。</p>
<p>说说常见试题。</p>
<p>常见的就是给定一个大数据集，但是内存小，不能做到一次性load数据并处理。例如，给1G的文件，内存限制在1M，等等类似的条件。</p>
<p>大数据必然是“分治”，大数据都要能拆成小数据。所以，遇到大数据题目，可以先假定能拆分出小数据，即使还不知道应该hash拆分还是别的算法做拆分。（当然，通常都是hash算法拆分。）</p>
<p>那么，问题就被分割了。我认为应该更早去考虑小数据集的部分，跳过拆分。因为，在考虑小数据集如何处理时，你会想到小数据最好是什么样的组合形式。</p>
<p>比如，如果是word count类，你自然希望小数据里可以直接包含某个word，这个word不在别的小数据集中出现。那么自然的，拆分就应该用hash算法，它能保证一个word都被hash到一个片里。再比如，如果你是希望小数据集之间能有一定顺序，可能按首字母来排序，那么切分数据集时就应该按着首字母来分出26份，这里用hash算法就没啥意义了。（当然，hash是更常见的，无论是题目还是生产中。）</p>
<p>大部分题目，在拆分为小数据集后，就基本默认小数据集满足内存要求了。也就是只做一次hash拆分。更进阶的，应该要考虑到如果一次切分后，有些小数据集仍然过大的情况。</p>
<p>很多网上的答案都是再hash，但这个也不是一定能分出来，或许面试不会问这么细节，不过也值得考虑一下。</p>
<p>我认为实际代码里不可能花时间去不断hash，通常试几次，不好使，就可以放弃了。如果碰到hash后的分片，它就是有点大，那可能它里面只有几个key，甚至只有单key。那应该如何处理？work count类的问题，需要在内存维护的是map，而不是原始数据，那么只要key不丰富，在内存内就装的下。1G的大数据，可能有超过1M的不同key，但都拆的较小的情况下，还有1M不同key，可能性还是很小的。</p>
<p>真要假设超过1M的这个分片里，key就是都不同的，hash值真就一样，hash拆分不了，这个情况下，如何处理？</p>
<p>因为足够小了，我觉得无论是用某种省内存的方式先全局排序，还是等大小切分，分别word count处多个map，然后merge map（由于假设的条件，整个分片的map是放不了内存的，可能得一次只处理部分key，存入硬盘，再做下一组），都是可以的。</p>
<p>对于常规分片，就可以做常规处理。就和快速排序一样，我们还是相信大概率的，最坏情况总是少的。</p>
<h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><p>分布式锁不是说锁是分布式的结构。是说如果系统是分布式的，进程间（无论是同一主机上还是多主机）要保证某些资源的独占，就得有个外部工具帮忙来指挥。硬要系统内部做，不引入外部工具，也不是不行，但是从工程角度来看，肯定是直接利用现成工具更好，而且也减轻代码复杂度。（虽然大家经常先用zookeeper，随后又嫌弃它，又移除zookeeper。但前期还是需要zookeeper，毕竟搭建快。）</p>
<p>常见分布式锁就是zookeeper和redis。</p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/RViDM1WHE61SDLNKzUmTAg">这篇文章介绍的redis做分布式锁</a>。我们先读读看。</p>
<h2 id="CAP定理-theorem-principle"><a href="#CAP定理-theorem-principle" class="headerlink" title="CAP定理 theorem/principle"></a>CAP定理 theorem/principle</h2><p>我的记忆中一直是都满足P，只是看CP还是AP。有一天朋友跟我说有CA，我就混乱了。所以来重新学一遍CAP吧。</p>
<p>注意大前提：分布式系统， a distributed system with replication。</p>
<ul>
<li>Consistency (C): Either get the most recently written data or get an error for each read</li>
<li>Availability (A): Every request can get a (non-error) response, but there is no guarantee that the latest written data will be returned.</li>
<li>Partition fault tolerance (P): Although any number of messages are lost (or delayed) by the network between nodes, the system continues to operate</li>
</ul>
<p>consistency一致性很好理解，分布式多副本，就需要考虑读写同一个分片的不同副本会不会有问题。强一致性协议的系统，当然是保证C的，例如paxos，raft。弱一致性协议当然不保证C，例如gossip。需要注意，强一致也不是说每次read都能读到有效数据，如果副本异常，你报错，那也是合理的。起码不会读出更早的数据，用户会当作自己读到的是最新的数据。</p>
<p>availability可用性，很多强一致性系统也说自己高可用，但其实也没那么高可用。这个A说的可用，并没有特指什么东西。系统可以更随便，比如，就是只要能返回给你数据就行，旧的我也给；又或者，系统给你回复，但是很慢很慢才回，但我也没拒绝你的request，也没报错，你也不能说我不A。</p>
<p>partition tolerance分区容忍最难懂，因为如果分区，有中心的系统找不到中心的一个分区必然就挂了，这么说好像就都没有P了。<br>P是指网络不可信了，信息会丢，paxos/raft等协议也提到过这个概念。</p>
<p>很多地方将CAP三个东西分开讲，也有人说某某系统是CA的，说的好像三个任选其二。但下面这个<a target="_blank" rel="noopener" href="https://github.com/henryr/cap-faq#10-why-do-some-people-get-annoyed-when-i-characterise-my-system-as-ca">理论</a>我觉得更有道理一点：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Possibility of Partitions =&gt; Not (C and A)</span><br></pre></td></tr></table></figure>

<p>只要你会面临分区的问题，你就无法同时保证C和A。而不是去讲那个系统能保证P。如果你非要讨论单机系统，那当然没有分区问题，它CA都满足，那当然可以。（但我们的讨论前提是分布式）</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://vagetablechicken.github.io/2022/05/07/env-note/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Huang Wei">
      <meta itemprop="description" content="Hey">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wei">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/07/env-note/" class="post-title-link" itemprop="url">环境note</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-05-07 00:23:43" itemprop="dateCreated datePublished" datetime="2022-05-07T00:23:43+08:00">2022-05-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-08-26 12:17:54" itemprop="dateModified" datetime="2023-08-26T12:17:54+08:00">2023-08-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="环境note"><a href="#环境note" class="headerlink" title="环境note"></a>环境note</h1><h2 id="About-OS"><a href="#About-OS" class="headerlink" title="About OS"></a>About OS</h2><h3 id="macOS"><a href="#macOS" class="headerlink" title="macOS"></a>macOS</h3><h4 id="homebrew"><a href="#homebrew" class="headerlink" title="homebrew"></a>homebrew</h4><p>默认源太卡，容易install失败。换tuna的源，设置方法见</p>
<p><a target="_blank" rel="noopener" href="https://mirrors.tuna.tsinghua.edu.cn/help/homebrew/">homebrew</a>，<a target="_blank" rel="noopener" href="https://mirrors.tuna.tsinghua.edu.cn/help/homebrew-bottles/">homebrew-bottles</a>。（注意，这两个都要配置）</p>
<h4 id="gdb-lldb"><a href="#gdb-lldb" class="headerlink" title="gdb/lldb"></a>gdb/lldb</h4><p>mac中使用lldb，不需要指定bin。<code>lldb -c /cores/xxx</code>即可。</p>
<h3 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h3><h3 id="debian源"><a href="#debian源" class="headerlink" title="debian源"></a>debian源</h3><p><a target="_blank" rel="noopener" href="https://mirrors.tuna.tsinghua.edu.cn/help/debian/">debian | 镜像站使用帮助 | 清华大学开源软件镜像站 | Tsinghua Open Source Mirror</a></p>
<p>apt update</p>
<p>apt install maven</p>
<h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><p>Windows下的终端Terminal，如何加入snippet，参考<a target="_blank" rel="noopener" href="https://github.com/microsoft/terminal/issues/6412#issuecomment-964343941%E3%80%82%E6%88%91%E4%B8%AA%E4%BA%BA%E5%B8%B8%E4%B8%BAOpenMLDB%E5%8A%A0%E7%9A%84snippet%EF%BC%9A">https://github.com/microsoft/terminal/issues/6412#issuecomment-964343941。我个人常为OpenMLDB加的snippet：</a></p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;action&quot;</span><span class="punctuation">:</span> <span class="string">&quot;sendInput&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;input&quot;</span><span class="punctuation">:</span> <span class="string">&quot;set @@execute_mode=&#x27;online&#x27;;\r&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;on&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;action&quot;</span><span class="punctuation">:</span> <span class="string">&quot;sendInput&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;input&quot;</span><span class="punctuation">:</span> <span class="string">&quot;set @@execute_mode=&#x27;offline&#x27;;\r&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;off&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;action&quot;</span><span class="punctuation">:</span> <span class="string">&quot;sendInput&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;input&quot;</span><span class="punctuation">:</span> <span class="string">&quot;set @@sync_job=true;\r&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;sync&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;action&quot;</span><span class="punctuation">:</span> <span class="string">&quot;sendInput&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;input&quot;</span><span class="punctuation">:</span> <span class="string">&quot;:set mouse-=a\r&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;mouse&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>不需要快捷键，<code>Ctrl+Shift+P</code>可以根据name快速选择，快捷键还懒得记。</p>
<h2 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h2><p>vim时用鼠标选择一段文本，可能进入VISUAL模式。VISUAL模式下的复制/粘贴/剪切得用<code>y</code>,<code>p</code>,<code>d</code>。注意，VISUAL模式下复制的文本，不会记录在剪贴板，只能在vim中使用，拷贝不出去。</p>
<p>更习惯不进入VISUAL模式的话，<code>set mouse-=a</code>。更改默认配置，把这个设置放在<code>~/.vimrc</code>里。</p>
<h2 id="python"><a href="#python" class="headerlink" title="python"></a>python</h2><p>python源也可以用tuna的，可以直接</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -i https://pypi.tuna.tsinghua.edu.cn/simple &lt;pkg&gt;</span><br></pre></td></tr></table></figure>

<p>全局配置方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python -m pip install --upgrade pip</span><br><span class="line">pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure>

<p>详情见<a target="_blank" rel="noopener" href="https://mirrors.tuna.tsinghua.edu.cn/help/pypi/">pypi | 镜像站使用帮助 | 清华大学开源软件镜像站 | Tsinghua Open Source Mirror</a>。</p>
<h2 id="sh"><a href="#sh" class="headerlink" title="sh"></a>sh</h2><h3 id="git"><a href="#git" class="headerlink" title="git"></a>git</h3><p>move or remove them before you merge, use this to get related files</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git xxx 2&gt;&amp;1|grep -E &#x27;^\s&#x27;|cut -f2-|xargs -I &#123;&#125; echo &quot;&#123;&#125;&quot;</span><br></pre></td></tr></table></figure>

<h3 id="ps-and-network"><a href="#ps-and-network" class="headerlink" title="ps and network"></a>ps and network</h3><p>no ps需要<code>apt install procps</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps axu | grep xx | awk &#x27;&#123;print $2&#125;&#x27; | xargs kill -9</span><br><span class="line">netstat -ltnup</span><br></pre></td></tr></table></figure>

<h3 id="run-bins"><a href="#run-bins" class="headerlink" title="run bins"></a>run bins</h3><p>运行当前目录下所有文件，测试时常用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for f in *; do ./$f; done</span><br></pre></td></tr></table></figure>

<h3 id="top-record"><a href="#top-record" class="headerlink" title="top record"></a>top record</h3><p>记录一段时间进程cpu mem等资源的变化，适合抓出程序最大占用内存的时间点。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">true</span>; <span class="keyword">do</span> <span class="built_in">sleep</span> 10 &amp;&amp; top -b -p 25440 -n1 | <span class="built_in">tail</span> -1 ; <span class="keyword">done</span> &gt;&gt; process.top</span><br><span class="line"><span class="comment"># add time</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">true</span>; <span class="keyword">do</span> <span class="built_in">sleep</span> 10 &amp;&amp; <span class="built_in">date</span> &amp;&amp; top -b -p 25440 -n1 | <span class="built_in">tail</span> -1 ; <span class="keyword">done</span> &gt;&gt; process.top</span><br></pre></td></tr></table></figure>

<h2 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h2><p>如果目的是pnpm，不用单独下载npm，直接下载pnpm就行。 <a target="_blank" rel="noopener" href="https://pnpm.io/zh/installation">https://pnpm.io/zh/installation</a></p>
<p>如果是npm，下载nvm更合适管理node版本。</p>
<h2 id="keyboard"><a href="#keyboard" class="headerlink" title="keyboard"></a>keyboard</h2><p>rk61键盘配合mac使用，支持很差，还是需要改键。使用karabiner-element做改键。</p>
<p>可以直接修改<code>~/.config/karabiner/karabiner.json</code>，注意里面的device是有vendor id和product id的，得填对，可以用karabiner直接查到。</p>
<p>windows下改键，使用PowerToys的键盘管理器。</p>
<h2 id="docker源"><a href="#docker源" class="headerlink" title="docker源"></a>docker源</h2><p>就是<code>registry-mirrors</code>这个配置项。linux直接在 <code>/etc/docker/daemon.json</code>里改，mac可以在docker desktop设置里找到配置文件，也是一样的修改。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;registry-mirrors&quot;: [</span><br><span class="line">        &quot;http://hub-mirror.c.163.com&quot;,</span><br><span class="line">        &quot;https://docker.mirrors.ustc.edu.cn&quot;,</span><br><span class="line">        &quot;https://registry.docker-cn.com&quot;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重启后<code>docker info</code>可以查看。</p>
<h2 id="tmux"><a href="#tmux" class="headerlink" title="tmux"></a>tmux</h2><p>tmux如果另一个没退，就又attach，可能分辨率会用另一个的，就会右边下边出现很多点点。可以ctrl-b/a，再shift-b（大写B），选择分辨率，选小的就能撑满屏幕。</p>
<h2 id="debug"><a href="#debug" class="headerlink" title="debug"></a>debug</h2><h3 id="oom"><a href="#oom" class="headerlink" title="oom"></a>oom</h3><p>怀疑进程被oom kill了，需要查日志，dmesg -T没有权限要求，但它的时间<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/619173424?utm_id=0">不准确</a>，甚至可能是未来时间。最好查/var/log/messages，但它可能需要root权限。<br>Docker内的进程也是被物理机管理的，如果占满内存，也是会被kill，而且在物理机上会有日志。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://vagetablechicken.github.io/2021/05/06/grokking-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Huang Wei">
      <meta itemprop="description" content="Hey">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wei">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/06/grokking-2/" class="post-title-link" itemprop="url">Grokking Pattern 2</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-05-06 10:58:13" itemprop="dateCreated datePublished" datetime="2021-05-06T10:58:13+08:00">2021-05-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-07-31 18:56:53" itemprop="dateModified" datetime="2023-07-31T18:56:53+08:00">2023-07-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Algo/" itemprop="url" rel="index"><span itemprop="name">Algo</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Grokking-the-Coding-Interview-Patterns-for-Coding-Questions"><a href="#Grokking-the-Coding-Interview-Patterns-for-Coding-Questions" class="headerlink" title="Grokking the Coding Interview: Patterns for Coding Questions"></a>Grokking the Coding Interview: Patterns for Coding Questions</h1><p>See <a href="/2021/05/06/grokking-1/" title="Grokking Pattern 1">Grokking Pattern 1</a>.</p>
<h2 id="2-Pattern-Two-Pointers"><a href="#2-Pattern-Two-Pointers" class="headerlink" title="2. Pattern: Two Pointers"></a>2. Pattern: Two Pointers</h2><h3 id="Pair-with-Target-Sum-easy-–-LeetCode"><a href="#Pair-with-Target-Sum-easy-–-LeetCode" class="headerlink" title="Pair with Target Sum (easy) – LeetCode"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/two-sum/">Pair with Target Sum (easy) – LeetCode</a></h3><p>这题第一感觉是map或者排序后二分查找，双指针是个什么操作？</p>
<p>双指针自然得用在排序后的数组上，头尾各一个，[left]+[right] == target返回，&gt;target right–，&lt;target left++。确实也比二分好写，如果不能用库函数二分，双指针编码不容易错，也是个很好的选择。</p>
<p>就是答案要求返回索引，排序后的索引怎么查也是个问题。代价还是不小的。</p>
<h3 id="Remove-Duplicates-easy-–-LeetCode"><a href="#Remove-Duplicates-easy-–-LeetCode" class="headerlink" title="Remove Duplicates (easy) – LeetCode"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/remove-duplicates-from-sorted-array/">Remove Duplicates (easy) – LeetCode</a></h3><p>原地当然是要原地替换了，那么应该被替换的地方需要一个指针，理应替换到前面去的需要一个指针。</p>
<p>比如，00111，第二位的0会被第三位1覆盖，那么第三位理论上是个空缺位，但编码上，不用管一位，因为一视同仁的话，序列等于是01111，第三位是1，也不并妨碍接着删除1。所以可以不用特别处理，代码会写的很简单。</p>
<h3 id="Squaring-a-Sorted-Array-easy-–-LeetCode"><a href="#Squaring-a-Sorted-Array-easy-–-LeetCode" class="headerlink" title="Squaring a Sorted Array (easy) – LeetCode"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/squares-of-a-sorted-array/">Squaring a Sorted Array (easy) – LeetCode</a></h3><p>非递增序列，类似概念还有：非递减，单调递增，单调递减。。。</p>
<p>单调就是相邻两个数不会相等，非xx自然是可能相等的。</p>
<p>用高数教材的定义，当x1&lt;x2时，都有f(x1)&lt;f(x2)，f(x)就是递增函数，increasing function。其实“单调”这个词有些干扰。</p>
<p>increasing就是上升，不存在横着走，non-decreasing就是不下降，那自然可能横着走走（也就是，可能相邻几个数相等）。剩下两个同理。</p>
<p>题目本身很简单，结果是从小到大，但是绝对值最小的数不好找，所以反其道而行之，找大的然后放在尾部就行了。</p>
<h3 id="Triplet-Sum-to-Zero-medium-–-LeetCode"><a href="#Triplet-Sum-to-Zero-medium-–-LeetCode" class="headerlink" title="Triplet Sum to Zero (medium) – LeetCode"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/3sum">Triplet Sum to Zero (medium) – LeetCode</a></h3><p>在此题必然用双指针的提示下，想到了固定1个数，然后变成两数之和问题，用双指针处理这一子问题。</p>
<p>但这个题的输出很多限制，需要排除的东西很多，示例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [-1,0,1,2,-1,-4]</span><br><span class="line">Output: [[-1,-1,2],[-1,0,1]]</span><br></pre></td></tr></table></figure>

<p>基本包含所有可能，完成这个test就能AC。</p>
<p>编码上，可以避开很多不必要计算，始终记住，假设当前固定的数是nu ms[i]=a，双指针肯定是i&lt;left&lt;right。不要把left始终设为从0开始，没必要。</p>
<h3 id="Triplet-Sum-Close-to-Target-medium-–-LeetCode"><a href="#Triplet-Sum-Close-to-Target-medium-–-LeetCode" class="headerlink" title="Triplet Sum Close to Target (medium) – LeetCode"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/3sum-closest/">Triplet Sum Close to Target (medium) – LeetCode</a></h3><p>其实比上一题简单，因为不用担心解重复的问题。注意的是result一开始设置一个极大值以便更新，别写做10^4了，这个python里会解释为14。表示次方使用两个星号。</p>
<h3 id="Triplets-with-Smaller-Sum-medium-google-–-LintCode"><a href="#Triplets-with-Smaller-Sum-medium-google-–-LintCode" class="headerlink" title="Triplets with Smaller Sum (medium, google) – LintCode"></a><a target="_blank" rel="noopener" href="https://www.lintcode.com/problem/3sum-smaller/description">Triplets with Smaller Sum (medium, google) – LintCode</a></h3><p>不是直接套用模板能搞定的了，好好理解下面这个example。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input:  nums = [-2,0,1,3], target = 2</span><br><span class="line">Output: 2</span><br><span class="line">Explanation:</span><br><span class="line">Because there are two triplets which sums are less than 2:</span><br><span class="line">[-2, 0, 1]</span><br><span class="line">[-2, 0, 3]</span><br></pre></td></tr></table></figure>

<p>应该是能O(n^2)解决的。</p>
<p>稍微暴力点，但容易想到的解法是for i, for j in [i+1, n)，这一层，可能有多个k可以是三数之和&lt;target。这里可以考虑二分找，lower bound还是upper bound，不用细想，但可以知道二分方法能做到。但是复杂度就是n^2 * logn，肯定有优化点。忘记二分，如果我们顺序找k，从左或者从右都行，但考虑到“如果这一轮j找到了，j++后k是不需要跳回最右边的，k可以就从当前位置开始”，这个应该很好懂。所以如果k是从右往左找，代码就可以写的很简洁。而且明显降低了复杂性。</p>
<p>再来思考下复杂度是多少，由于固定i后，j和k又是最多只会遍历[i+1,n)的部分，所以总的是O(n^2)。</p>
<h3 id="Subarrays-with-Product-Less-than-a-Target-medium"><a href="#Subarrays-with-Product-Less-than-a-Target-medium" class="headerlink" title="Subarrays with Product Less than a Target (medium) *"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/subarray-product-less-than-k/">Subarrays with Product Less than a Target (medium) *</a></h3><p>要求输出所有subarrays，也有要求输出subarrays个数。输出要求都不太难。</p>
<p>套用双指针或者说是滑动窗口模板时，需要考虑到乘积的写法。尤其是当某一个数本身就&gt;=k时，窗口应该收缩成0。这个用双while写起来就很怪，所以我是在最开头就判断下，如果是就重新设置那一堆变量，进入下一次循环。官方代码使用for-while把这一情况包含了，不用单独判断。这里可以再思考下，官方的是不是正确，当nums内有数字1或者k==1时又会不会有奇怪的问题出现？</p>
<p>for-while的写法，就是可能会出现while结束后，start == end + 1，此时product == 1，因为没有取到任何一个数。接着会马上进入下一次外层for，end++后就会是start == end，即想选择[end]这一个数作为subarrary，然后接着while判断。这一整段没毛病。</p>
<p>至于nums内有数字1，完全不影响计算。而k==1，也不会有问题，走一遍逻辑就知道了，k==1时无论数组长什么样，结果都是0个，不存在&lt;1的正整数，更不会有乘积&lt;1了。</p>
<p>官方还有二分查找法，乘积[0, i]是非递减的，确实有道理。而且由于乘积可能很大，还用对数，很强势，看一看。</p>
<ul>
<li><input disabled="" type="checkbox"> 取对数后很难是正整数，那么必然有精度损失，不影响正确性？</li>
</ul>
<h3 id="Problem-Challenge-1-Quadruple-Sum-to-Target-medium"><a href="#Problem-Challenge-1-Quadruple-Sum-to-Target-medium" class="headerlink" title="Problem Challenge 1 - Quadruple Sum to Target (medium) *"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/4sum/">Problem Challenge 1 - Quadruple Sum to Target (medium) *</a></h3><p>四数之和，数组是整数但可零可负。</p>
<p>在已知此题可用双指针的情况下，自然去思考如何利用双指针，但双指针只能用于两数和问题（指定这两个数和为某定值，找出两数的所有可能解），那四数还有两个数怎么办，最简单的想法就是把这两个数所有可能列出来。于是平方复杂度列举出所有a和b的可能，对每一对ab，用线性复杂度的双指针找出c和d的所有可能解。大约就是三次方的复杂度了（可能真实复杂度可以算的更精确点，但反正小于等于三次方复杂度，暂不纠结这个问题，简单看待）。</p>
<p>想到这里，三次方的复杂度让我有点虚。不过，转头想这个题如果是暴力解法就是四次方，如果是定三个数再利用有序二分找第四个数，就是n^3*logn，n^3的复杂度好像瞬间就容易接受了。</p>
<p>题目有个麻烦点是不能有重复的四元组，如果不通过某种方式设置set（对四元组去重）的话，就需要跳过那些重复的组合。也能写出来，就是代码有点丑，也需要case来调试。不能一气呵成。</p>
<p>这个比较顺畅的思路是：</p>
<ol>
<li><p>首先思考第一个和第二个数，简写为a和b，它们都是for循环，比较类似。</p>
<p>假设a固定，看b的移动。b如果右移还是同样的值，“右移之后的解集”只会小于等于“右移前”的（cd因为b的右移，可能性变少了），可以想到，解集不会增加任何可能性，反而只可能减少，b的取值却又是一模一样，那么右移后的abcd组合，在右移前遍历中都考虑完了，自然完全没必要重复遍历，所以b要一直跳到和前一个值不一样的地方，才需要进行遍历求解。</p>
<p>而a的情况也一样，a的右移只可能使得bcd组合减少，没有新花样，a右移前后的解，值都一样，右移后的完全可以被跳过。所以a也是要跳到和前一个值不一样的地方。</p>
</li>
<li><p>再思考cd两个值，如何过滤重复的解。</p>
<p>c+d不等于想要的值时，方向很明确，只会left或者right某一个移动。如果c移动到下一个值还是不变，那还是c+d不等于期望值。所以不等于的情况不用过滤。而c+d==期望值时，如果只有left右移，那么肯定要跳过重复的值。但如果是right那边重复，只left跳过重复值，能否解决问题？答案是可以。举例说明，当left这边序列是11111xxx时，1+d==期望值，那么left一直移动到最后一个1，下一个数就不是1的时候，abcd这个组合可以成为一个合法解，然后left++，那么下一次while时就是大于1的数+没有动的d，那肯定是大于期望值，right那边就会左移，遇到重复的right还是左移，并不需要考虑过滤。</p>
<p>当然，只做right的重复过滤也可以。没必要做两边的。当然两边都跳过也行，但少写代码少错😄。</p>
</li>
</ol>
<p>再思考下几数和问题，两数和就是双指针，线性复杂度，三数和就是指定一个数再解决两数和，平方复杂度，四数和三次方复杂度。</p>
<h3 id="Problem-Challenge-2-Comparing-Strings-containing-Backspaces-medium"><a href="#Problem-Challenge-2-Comparing-Strings-containing-Backspaces-medium" class="headerlink" title="Problem Challenge 2 - Comparing Strings containing Backspaces (medium)"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/backspace-string-compare/">Problem Challenge 2 - Comparing Strings containing Backspaces (medium)</a></h3><p>顺序找规律怎么也找不到时，一定要记得反向试试。数组题一定要记得反向可能有奇效！！！</p>
<p>此题没有什么巧妙写法，写出来的代码有点长，不过容易调试成功。</p>
<h3 id="Problem-Challenge-3-Minimum-Window-Sort-medium"><a href="#Problem-Challenge-3-Minimum-Window-Sort-medium" class="headerlink" title="Problem Challenge 3 - Minimum Window Sort (medium) *"></a>Problem Challenge 3 - Minimum Window Sort (medium) *</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Given an array, find the length of the smallest subarray in it which when sorted will sort the whole array.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: [1, 2, 5, 3, 7, 10, 9, 12]</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: We need to sort only the subarray [5, 3, 7, 10, 9] to make the whole array sorted</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: [1, 3, 2, 0, -1, 7, 10]</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: We need to sort only the subarray [1, 3, 2, 0, -1] to make the whole array sorted</span><br><span class="line"></span><br><span class="line">Example 3:</span><br><span class="line"></span><br><span class="line">Input: [1, 2, 3]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: The array is already sorted</span><br><span class="line"></span><br><span class="line">Example 4:</span><br><span class="line"></span><br><span class="line">Input: [3, 2, 1]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The whole array needs to be sorted.</span><br></pre></td></tr></table></figure>

<p>这个题没找到OJ地址。思考的时候想到了拐点，不过后续思考没跟上。</p>
<p>首先，找到了subarray之后，这个subarray一旦能排好序，整个array就有序了。那么，非subarray的值就应该是它们应该在的位置。</p>
<p>Example1中1和2在应该在的位置，就很容易想到指针找到第一个比右边还大的值（也就是拐点），也就是5。但Example2直接打脸，1本就不在该在的位置。</p>
<p>到这儿就没继续沿着这个思路继续下去了。然后就没找到思路了。。。</p>
<p>找到左右两边的拐点后，拐点之间的这个区间必然不是都在正确位置上，所以这个区间肯定在subarray里面。但Example2也提示了，找到了拐点区间[3,2,0,-1]，可以看到前面的1也是错的，为什么呢？因为1排序后也不应该站在它现在的位置，也就是说subarray应该还需要扩张。</p>
<p>扩张的依据是什么？这个元素是否在当前区间的最大最小值之间。因为如果在之间，全局排序后，这个元素和当前区间的位置都是要变的。画一下折线图，纵坐标表示值的大小，横坐标是元素位置，就可以很直观的看到，区间的扩张是简单的，因为它只需要往外1个1个check就行了，没有什么复杂规则。</p>
<ul>
<li><input disabled="" type="checkbox"> code</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://vagetablechicken.github.io/2021/05/06/grokking-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Huang Wei">
      <meta itemprop="description" content="Hey">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wei">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/06/grokking-3/" class="post-title-link" itemprop="url">Grokking Pattern 3</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-05-06 10:58:13" itemprop="dateCreated datePublished" datetime="2021-05-06T10:58:13+08:00">2021-05-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-07-31 18:56:53" itemprop="dateModified" datetime="2023-07-31T18:56:53+08:00">2023-07-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Algo/" itemprop="url" rel="index"><span itemprop="name">Algo</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Grokking-the-Coding-Interview-Patterns-for-Coding-Questions"><a href="#Grokking-the-Coding-Interview-Patterns-for-Coding-Questions" class="headerlink" title="Grokking the Coding Interview: Patterns for Coding Questions"></a>Grokking the Coding Interview: Patterns for Coding Questions</h1><p>See <a href="/2021/05/06/grokking-1/" title="Grokking Pattern 1">Grokking Pattern 1</a>.</p>
<h2 id="3-Pattern-Fast-amp-Slow-pointers"><a href="#3-Pattern-Fast-amp-Slow-pointers" class="headerlink" title="3. Pattern: Fast &amp; Slow pointers"></a>3. Pattern: Fast &amp; Slow pointers</h2><h3 id="LinkedList-Cycle-easy"><a href="#LinkedList-Cycle-easy" class="headerlink" title="LinkedList Cycle (easy)"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/linked-list-cycle/">LinkedList Cycle (easy)</a></h3><p>题目描述很反人类，但其实就是给你一个链表（只有head指针），让你判断是否有环。进阶是只使用O(1)的空间，也就是常量空间。</p>
<p>有环的链表肯定会访问到重复的节点，环内有1个或以上的节点。搞一个空间存已经访问过的节点，查到之前访问过就能判断了，但空间最坏能到O(n)。常量空间，自然要用快慢指针。</p>
<p>推理一下，快慢指针什么时候能证明链表有环？</p>
<p>猜想肯定是快慢指针指向同一个节点时，但怀疑是否存在“有环链表下快慢指针也不会同时指向同一个节点”。画画图，列一下方程式，假设链表入环前有s个节点，环上有c个节点，可以知道，当走整数倍c（2倍起，同时还得&gt;s）的时候快慢指针是能遇到的，这个值不会不存在，还会多次相遇。所以不用担心快慢节点会永远遇不到。</p>
<p>编码上很简单了，记住init时fast，slow都指向head，然后while内先走再check。</p>
<h3 id="Middle-of-the-LinkedList-easy"><a href="#Middle-of-the-LinkedList-easy" class="headerlink" title="Middle of the LinkedList (easy)"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/middle-of-the-linked-list/">Middle of the LinkedList (easy)</a></h3><p>很简单的题，把两个case都手动推理一遍，就知道了。hint：fast先走，提前退出，slow就不用走了。</p>
<h3 id="Start-of-LinkedList-Cycle-medium"><a href="#Start-of-LinkedList-Cycle-medium" class="headerlink" title="Start of LinkedList Cycle (medium)"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">Start of LinkedList Cycle (medium)</a></h3><p>这个题猜得到是需要快慢指针相遇后再加点什么操作的，但是推理容易卡壳。主要还是对快慢指针相遇的情况理解的不够。</p>
<p>快慢指针相遇很好写，node地址相等就是了。但相遇时，快慢指针并不是可能走了无数圈。这里有一个点必须记住，就是“慢指针入环后，和快指针相遇时，慢指针在环上是不会走超过一圈的”。也就是慢指针入环后继续走，一圈以内必定碰到快指针。</p>
<p>这个知识点，我以前应该用方程式推过，也不记得推理有没有漏洞了，这次做题还没推出来。所以这里最直观也正确的解法是数学归纳法。我们讲slow入环后和fast相遇，那么最快相的情况，当然是slow和fast直接在入环点直接相遇，0步。再麻烦点，就是fast在slow的前面（此刻的位置是fast.next==slow），这样两个相邻的节点，只需1步就能相遇。假设fast更远一点，即fast.next.next==slow，就需要2步，以此类推，入环时刻，fast和slow的距离（fast的n个next==slow）假设为n，就需要n步相遇。但fast和slow之间最大距离就是fast在slow的前一个，假设环里有k个节点，fast和slow的最大距离就是k-1，所以最多k-1步，fast和slow必定相遇。所以slow不可能在相遇前走几圈。</p>
<p>知道slow在一圈内就会和fast相遇，其中几个关键长度如下图所示。那么相遇时slow的公式应该写为，slow=a+b，fast=a+b+n(b+c)。</p>
<p><img src="https://assets.leetcode-cn.com/solution-static/142/142_fig1.png" alt="示意图"></p>
<p>(leetcode图源，可能会挂，自行戳网址)</p>
<p>再回到题目本身，当两指针在紫色点上相遇时，代入化简一下已有式子，得a+b=n(b+c)，即a=c+(n-1)(b+c)，为什么化简成这样？不是因为这样a可以通过等式右边得到，右边这式子也没法继续求。而是因为，右边写成这样，b+c是一整圈，也就是说，如果一个指针从链表头开始走起，另一个指针从紫色点走了c长度又走了几个完整圈，它们会在入环口相遇，另一个指针走几圈完全不用在意。</p>
<p>但注意，这个式子可能有坑，思考下有没有可能a很小，c很大？</p>
<p>n必然&gt;=1，因为fast肯定走的多点，不然fast=a+b+n(b+c)就不对了。那么，a最小就等于c，不可能比c小。这个事情挺有趣的。没有想到一个很通俗易懂的表达，但数学证明了也就证明了吧。</p>
<h3 id="Happy-Number-medium"><a href="#Happy-Number-medium" class="headerlink" title="Happy Number (medium)"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/happy-number/">Happy Number (medium)</a></h3><p>这题现在是简单😂</p>
<p>题目没有读仔细，所以第一时间没能察觉到和快慢指针有什么联系。题目表述为“也可能是 <strong>无限循环</strong> 但始终变不到 1”，我简单地想到了不能一直计算，但忘记了无限循环不是每一次结果都不一样，它只是每次结果都是不是1，不是说每次结果都是从未出现的数字。</p>
<p>接着，就排除了用定义一直计算这种思路，变成了想利用数学之类的其他方法来解决。虽然也推理出了平方和计算中，不能爆出非常大的值，最大32bit的数，十进制也就是13位，就算13位都是9，一次平方和计算下来，也不过1053。而1053的平方和也挺小的，1053以内能算出较大平方和的也就是999。而999再算一步也就是243。</p>
<p>可以明显感觉到，不可能出现一个小的数字经过多次计算膨胀的很大，只可能很大的初始数一下子变得很小。当然像case1中19经过计算会变大，但这都是一定范围，最大不可能超过1053。</p>
<p>然而，从这里开始，我就期待用动态规划一类的方式，类似斐波那契数列，提前算好所有快乐数。所以我认为，可以从1，10，100，1000反推平方和等于它们的数，但是反推的链路有点长，说不定反推也会不能停止，毕竟这个思路不太对劲，可能有不少漏洞。</p>
<p>总结还是应该利用平方和结果范围有限这一点，也就是抽象成链表的有环判定。当然，因为平方和都是即时算的，不像链表问题提前准备好链表。简单的方案就是直接保存之前计算出的结果，也就是不用快慢指针，而是用是否已存在来判断。而如果还是想用快慢指针，可以def一个next函数，考虑到节约空间，next函数只管计算不用缓存。快指针两次next，慢指针一次next就好了。</p>
<p>纯数学的角度其实也可以继续推下去。但需要更仔细的范围研究。所以，回顾之前的推理，最大的数字13个9，也会瞬间收缩到1053，再归纳总结，12个9收缩到。。。4个9收缩到324，这里特别的来了，999到243。为什么说999到243特别，因为这里位数不降了，之前的那些大数都会收缩位数，变得更小，999虽然会经过一次计算变小，但位数不会收。所以一旦计算结果收缩到3位数，接下来的所有平方和结果都是三位数以内，不可能膨胀，且跌入三位数后（三位数后再计算一次），必然困在243以下。而为什么就243了，有没有可能实际数字更小？简单举例99就知道，它能变大到162，也就是涨到三位数，但不可能从三位数继续变大。所以，计算进入243以内后，可能会振荡，比如2位数蹦到3位数，但不可能比243更大，也就是出不去了。</p>
<p>那么，假设计算结果小于等于243时，我们能直接给出结论，是不是快乐数。就不用进入无限的循环了。所以问题变成243以内的数字，哪些是快乐数？</p>
<p>而这样的问题缩减，有什么好处呢？好处在于，243个数字，最大值也就是243，大可以暴力算加是否已存在判定，最大空间复杂度也就到243，比起给一个数就缓存，空间占用要小一些。（其实应该也小不了多少，毕竟收缩很快）但把&lt;=243的数字直接打成表，对于频繁查快乐数的情况，就会节约时间的多。oj时间上节省的会比较明显。如果只是一次快乐数判定，当然打表反而还浪费时间。</p>
<h3 id="Problem-Challenge-1-Palindrome-LinkedList-medium"><a href="#Problem-Challenge-1-Palindrome-LinkedList-medium" class="headerlink" title="Problem Challenge 1 - Palindrome LinkedList (medium)"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/palindrome-linked-list/">Problem Challenge 1 - Palindrome LinkedList (medium)</a></h3><p>难度简单。</p>
<p>很明显快慢指针能够找到链表的中部。而中部开始向左向右比对，就能判定是否回文。右半边很顺畅，不用改动，关键在于左半部分。但左半部分再快慢指针途中是被遍历访问过的。这其实也就提示了，如果修改链表，就能降低空间复杂度。题目进阶就是希望用O(1)空间，那大概率就是原地修改链表的左半部分。</p>
<p>很直接的就能想到是反向指。写写画画，不难得到简单的代码。得到了链表中部的指针后，当然是往两边走，逐个对比。但注意，奇数回文串和偶数回文串比较的起点是不一样的。我粗心的只想到了偶数回文，跑测试才发现奇数回文跑不过。</p>
<p>P.S.</p>
<p>这个题还有个递归解法，我不太擅长递归，经常起手就是迭代，所以这里值得再学习下。首先，递归能给我们什么？假设我们只是简单的print val，那么递归就能从尾到头，逆序读出每个节点的值。假设我们递归到底了，现在能读到尾部节点，这个时候我们应该拿头部节点和它进行比较，接着递归会读倒数第二个，而这时又应该拿顺数第二个节点比较。可以看到，从头部开始读也可以用一个指针来解决，但这个指针得是外部的变量，放在递归函数里面太困难了。再思考奇偶情况，奇数节点两指针地址会指向同一个节点，容易判断，偶数情况本来以为会麻烦点，但还好，因为两个指针指向的节点是相邻的，所以只要next判断一下就好了。leetcode官方解更飘逸，全遍历，不用提前返回，那对栈空间要求更高了。不大实用，但可以多熟悉下递归。论简单，还是递归这个写法代码少。</p>
<h3 id="Problem-Challenge-2-Rearrange-a-LinkedList-medium"><a href="#Problem-Challenge-2-Rearrange-a-LinkedList-medium" class="headerlink" title="Problem Challenge 2 - Rearrange a LinkedList (medium)"></a>Problem Challenge 2 - Rearrange a LinkedList (medium)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Given the head of a Singly LinkedList, write a method to modify the LinkedList such that the nodes from the second half of the LinkedList are inserted alternately to the nodes from the first half in reverse order. So if the LinkedList has nodes 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6 -&gt; null, your method should return 1 -&gt; 6 -&gt; 2 -&gt; 5 -&gt; 3 -&gt; 4 -&gt; null.</span><br><span class="line"></span><br><span class="line">Your algorithm should not use any extra space and the input LinkedList should be modified in-place.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: 2 -&gt; 4 -&gt; 6 -&gt; 8 -&gt; 10 -&gt; 12 -&gt; null</span><br><span class="line">Output: 2 -&gt; 12 -&gt; 4 -&gt; 10 -&gt; 6 -&gt; 8 -&gt; null</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: 2 -&gt; 4 -&gt; 6 -&gt; 8 -&gt; 10 -&gt; null</span><br><span class="line">Output: 2 -&gt; 10 -&gt; 4 -&gt; 8 -&gt; 6 -&gt; null</span><br></pre></td></tr></table></figure>

<p>跟challenge1类似，尝试了一下递归的写法，比较容易写，就是先把偶数链表搞定，再补一下奇数情况的判断就行了。但是注意，debug时别打印链表，修改中途的临时链表很可能是有环的，打印也打不出来。当然可以限制下打印的node个数，调试时还是可以有的。</p>
<p>如果不用递归写法，这个题还是和challenge1一样，可以把后半部分链表原地反转。不多赘述。</p>
<h3 id="Problem-Challenge-3-Cycle-in-a-Circular-Array-hard"><a href="#Problem-Challenge-3-Cycle-in-a-Circular-Array-hard" class="headerlink" title="Problem Challenge 3 - Cycle in a Circular Array (hard)"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/circular-array-loop/">Problem Challenge 3 - Cycle in a Circular Array (hard)</a></h3><p>题目有点难读，但解析下来，题目的意思是，首先有个环有n个节点，节点里的值表示下一步会向前or向后跳几个节点，可以理解为<strong>在做链表的next链接</strong>。这样下来很可能会出现环状的链表，而且题目定义的链表更狭窄点，k=1（一个节点自环）的不算，不算一会儿前进一会儿后退的。</p>
<p>根据“链表next”和“判断是否循环”，就知道可以用快慢指针。但快慢指针会测到自环，所以即使判断有环，还得再一次确认是否是k=1自环的情况。</p>
<p>而“不算一会儿前进一会儿后退”这一点很重要，题目的说法是循环的下标序列不是全正就是全负。那么指针跑的时候去要看自己现在所处的位置i，这个位置指定的步数，也就是nums[i]如果和之前的nums[…]符号不同，就可以直接判断为False。</p>
<p>那么，还剩两个问题。</p>
<ol>
<li>快慢指针没有null作为退出条件了，不知道能不能结束。这里可以考虑防御性编程，加个一定限制。但其实不需要，原因是，如果一个nums值全为正，选一个元素来看，它必然得指向某个元素，这个元素如果是它自己，就会发现一个自环；如果不是，它势必要指向一个新元素（我们还未访问的）。但访问得一直继续，如果每次都不是循环（快慢指针查不到的），不会停止，一直访问下去，那么元素迟早被访问完，那下一步会去哪儿呢？所以必然会有快慢指针能够查到的环，虽然自环不能算本题定义的“循环”。<ol>
<li>总结一下，就是，除了不是全正or全负会提前退出，快慢指针是必然会相遇的。自信点，不用防御编程。</li>
</ol>
</li>
<li>此题不是简单的从数组头开始。拿个示例画一下，也能发现，从某个下标开始跑快慢指针，结果都是不一样的。所以理论上，每个数组元素都是可能的循环的开始。</li>
</ol>
<p>总结到这里，突然想到一个问题，既然只有全正全负会陷入while loop不能提前退出，而全正全负又一定能有广义的环。那么完全不用快慢指针，只需要把每个点当作可能的入环口，也就是从这个点开始我能转回这个点，就找到了一个广义环。并不是非得快慢指针。只是这里有个坑，那就是这个点只是可能的入环口，它也有可能是类似有环链表的直线部分，走了几步才入环。所以得有个限制退出while步进，不然会死循环出不去。又由前面整理的结果，想要全正or全负没有环是不可能的，最大的环也就到整个数组的长度（当然，可能链表箭头走的很骚，不是说只能沿着数组+1/-1步这么走，但长度是不能再长了）。</p>
<p>这个思路比快慢指针代码上简单点，时间复杂度上却不是变少，因为这个思路走满环，最坏时能达到数组长度，O(n)，快慢指针中fast指针和slow指针第一次相遇时slow也没有走满环，fast多一倍步数，也没差多少。所以这个思路也不会带来质变，聊胜于无。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://vagetablechicken.github.io/2021/05/06/grokking-6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Huang Wei">
      <meta itemprop="description" content="Hey">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wei">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/06/grokking-6/" class="post-title-link" itemprop="url">Grokking Pattern 6</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-05-06 10:58:13" itemprop="dateCreated datePublished" datetime="2021-05-06T10:58:13+08:00">2021-05-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-07-31 18:56:53" itemprop="dateModified" datetime="2023-07-31T18:56:53+08:00">2023-07-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Algo/" itemprop="url" rel="index"><span itemprop="name">Algo</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Grokking-the-Coding-Interview-Patterns-for-Coding-Questions"><a href="#Grokking-the-Coding-Interview-Patterns-for-Coding-Questions" class="headerlink" title="Grokking the Coding Interview: Patterns for Coding Questions"></a>Grokking the Coding Interview: Patterns for Coding Questions</h1><p>See <a href="/2021/05/06/grokking-1/" title="Grokking Pattern 1">Grokking Pattern 1</a>.</p>
<h2 id="6-Pattern-In-place-Reversal-of-a-LinkedList"><a href="#6-Pattern-In-place-Reversal-of-a-LinkedList" class="headerlink" title="6. Pattern In-place Reversal of a LinkedList"></a>6. Pattern In-place Reversal of a LinkedList</h2><h3 id="Reverse-a-LinkedList-easy"><a href="#Reverse-a-LinkedList-easy" class="headerlink" title="Reverse a LinkedList (easy)"></a>Reverse a LinkedList (easy)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Given the head of a Singly LinkedList, reverse the LinkedList.</span><br><span class="line"> Write a function to return the new head of the reversed LinkedList.</span><br></pre></td></tr></table></figure>

<p>反转的基本操作：两个指针，一前一后，改变后一节点的next指针，同时就会失去后一节点的原next，所以需要第三个指针，保住后一节点的原next。</p>
<p>再优化：由于每一次新的比较，都只需要两个指针，指向“后一节点的next节点”的指针是可以在此基础上再找到的，不需要一直追着。</p>
<p>遍历结束后，最后一个节点就是头节点，所以不需要别的额外的变量。</p>
<h3 id="Reverse-a-Sub-list-medium"><a href="#Reverse-a-Sub-list-medium" class="headerlink" title="Reverse a Sub-list (medium)"></a>Reverse a Sub-list (medium)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Given the head of a LinkedList and two positions ‘p’ and ‘q’, reverse the LinkedList from position ‘p’ to ‘q’.</span><br></pre></td></tr></table></figure>

<p>p,q是positions，也就是第几个元素。不是value，更不是直接的node地址。</p>
<h3 id="Reverse-every-K-element-Sub-list-medium"><a href="#Reverse-every-K-element-Sub-list-medium" class="headerlink" title="Reverse every K-element Sub-list (medium) *"></a>Reverse every K-element Sub-list (medium) *</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Given the head of a LinkedList and a number ‘k’, reverse every ‘k’ sized sub-list starting from the head.</span><br><span class="line"></span><br><span class="line">If, in the end, you are left with a sub-list with less than ‘k’ elements, reverse it too.</span><br></pre></td></tr></table></figure>

<p>首先看边界，因为末尾不足k的也翻转，所以可以无脑翻转。如果题目末尾变成不足k的<strong>不可以翻转</strong>（<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-nodes-in-k-group/">leetcode 原题</a>），那么就得先数k，不到k个就退出，有k个再翻转，多了一次遍历，不过也是O(n)。</p>
<p>题目有些细节，但本质还是两个指针的事情，不难做对。不过我第一反应是不会改动初始链表的，但这一题如果加哨兵（一个dummy node接上链表head），会更简单点，不用在遍历while里写if判断是不是首次翻转，如果是首次，需要存下这个new head。（效率还是更高的，虽然不算太重要）</p>
<h3 id="Problem-Challenge-1-Reverse-alternating-K-element-Sub-list-medium"><a href="#Problem-Challenge-1-Reverse-alternating-K-element-Sub-list-medium" class="headerlink" title="Problem Challenge 1 - Reverse alternating K-element Sub-list (medium)"></a>Problem Challenge 1 - Reverse alternating K-element Sub-list (medium)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Given the head of a LinkedList and a number ‘k’, reverse every alternating ‘k’ sized sub-list starting from the head.</span><br><span class="line"></span><br><span class="line">If, in the end, you are left with a sub-list with less than ‘k’ elements, reverse it too.</span><br></pre></td></tr></table></figure>

<h3 id="Problem-Challenge-2-Rotate-a-LinkedList-medium"><a href="#Problem-Challenge-2-Rotate-a-LinkedList-medium" class="headerlink" title="Problem Challenge 2 - Rotate a LinkedList (medium)"></a>Problem Challenge 2 - Rotate a LinkedList (medium)</h3>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://vagetablechicken.github.io/2021/05/06/grokking-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Huang Wei">
      <meta itemprop="description" content="Hey">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wei">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/06/grokking-1/" class="post-title-link" itemprop="url">Grokking Pattern 1</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-05-06 10:58:13" itemprop="dateCreated datePublished" datetime="2021-05-06T10:58:13+08:00">2021-05-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-07-31 18:56:53" itemprop="dateModified" datetime="2023-07-31T18:56:53+08:00">2023-07-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Algo/" itemprop="url" rel="index"><span itemprop="name">Algo</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Grokking-the-Coding-Interview-Patterns-for-Coding-Questions"><a href="#Grokking-the-Coding-Interview-Patterns-for-Coding-Questions" class="headerlink" title="Grokking the Coding Interview: Patterns for Coding Questions"></a>Grokking the Coding Interview: Patterns for Coding Questions</h1><p><a target="_blank" rel="noopener" href="https://www.educative.io/courses/grokking-the-coding-interview?aff=K7qB">课程原地址</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/cl2333/Grokking-the-Coding-Interview-Patterns-for-Coding-Questions">题目目录与答案 Python版</a>——完整题目目录，包含challenge。 </p>
<p><a target="_blank" rel="noopener" href="https://github.com/Huixxi/Algorithm-with-Cplusplus/tree/master/%E8%8E%B1%E7%89%B9%E6%89%A3%E7%9A%84-%E7%B3%BB%E5%88%97">题目目录与答案 C++版(附题目OJ的地址)</a>——推荐用OJ测试自己的算法，但是这个repo里基本没有challenge题目。</p>
<h2 id="1-Pattern-Sliding-Window"><a href="#1-Pattern-Sliding-Window" class="headerlink" title="1. Pattern: Sliding Window"></a>1. Pattern: Sliding Window</h2><h3 id="Maximum-Sum-Subarray-of-Size-K-easy-–-GeeksforGeeks"><a href="#Maximum-Sum-Subarray-of-Size-K-easy-–-GeeksforGeeks" class="headerlink" title="Maximum Sum Subarray of Size K (easy) – GeeksforGeeks"></a><a target="_blank" rel="noopener" href="https://www.geeksforgeeks.org/find-maximum-minimum-sum-subarray-size-k/">Maximum Sum Subarray of Size K (easy) – GeeksforGeeks</a></h3><p>k长的<strong>连续子序列</strong>，使该子序列和最大，这个和为output。<br>窗口长度都固定了，只需在遍历一遍时加后一个减前一个就行了，O(n)。</p>
<h3 id="Smallest-Subarray-with-a-given-sum-medium-–-LeetCode"><a href="#Smallest-Subarray-with-a-given-sum-medium-–-LeetCode" class="headerlink" title="Smallest Subarray with a given sum (medium) – LeetCode"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/minimum-size-subarray-sum/">Smallest Subarray with a given sum (medium) – LeetCode</a></h3><p>注意读题，nums都是正整数，target也是正整数。这个条件大概率需要用到。</p>
<p>假设有一段连续子序列了，它已经&gt;=target了，就不需要再继续加入元素了（序列外右边第一个元素），因为再加的话size就变大了。而这个size可以向右横移一格，可以立马算出新的sum（这里很节约时间，降低算法复杂度）。</p>
<p>这个sum如果 &gt;= target，那么它就有机会再小一点，而这一次需要的是减去序列内的第一个元素，可以理解为“收缩窗口”。<br>这个sum如果 &lt; target，那就可以再向右横移了，因为size扩大，对结果没有任何帮助。</p>
<p>总体看下来，只要横移和收缩，算法复杂度是O(n)。</p>
<h4 id="初步思路"><a href="#初步思路" class="headerlink" title="初步思路"></a>初步思路</h4><p>初步思路是，先算个nums[0…x]之和 &gt;= target的窗口，然后这个窗口开始向右移并尝试收缩。但其实不对，因为第一个窗口，不是非得从第0个元素开始，这个窗口自身就应该尝试收缩。这个逻辑补上后是能ac的。<br>不过，初步思路翻译为代码，还是有些小坑，肉眼很难查。建议背一个滑动窗口模板。</p>
<h4 id="滑动窗口模板思路"><a href="#滑动窗口模板思路" class="headerlink" title="滑动窗口模板思路"></a>滑动窗口模板思路</h4><p>此思路最核心的思想就是，不强求窗口横移，反正先向右扩展1个，再左边收缩一个，就达到了横移。<br>因此滑动窗口的头尾都可以移动，而且是分别移动，用两个变量来表示，（start，end）。<br>因为收缩（start向右移）和扩展（end向右移）可以各做各的，所以没必要先找到一个总和 &gt;= target的初始窗口了。</p>
<p>所以，步骤可以化简为，<strong>每一次都扩展1下，然后尽力收缩</strong>（while不定次收缩）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">while end &lt; n:</span><br><span class="line">    tmp_sum += nums[end]</span><br><span class="line">    while tmp_sum &gt;= target:</span><br><span class="line">        win_size = min(win_size, end-start+1)</span><br><span class="line">        tmp_sum -= nums[start]</span><br><span class="line">        start += 1</span><br><span class="line">    end += 1</span><br></pre></td></tr></table></figure>

<p>至于几个变量的初始值，现场推理一下也可以得到，不做赘述。<br>P.S. win_size没必要用int的max，用len(nums)+1就可以了，反正都是不可能的值。</p>
<h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><p>滑动窗口的算法，nums就算有负数也无所谓。（被烟雾弹迷惑🐶）这个条件大概是为“前缀和”这一方法准备的。</p>
<p>前缀和方法，简单来讲就是nums[0..i]之和组成一个sum数组，这个数组严格递增，都不存在相等的元素。</p>
<p>然后就可以用二分来找了（看到有序就要想到二分），当前sum[i]为0到i元素的和，<code>sum[j] - sum[i] &gt;= target</code>转换为<code>sum[j]&gt;=target+sum[i]</code>，那么就是在sum数组里找<code>target+sum[i]</code>的lower bound。</p>
<p>为什么不是以j为结尾，<code>sum[j] - sum[x] &gt;= target</code>转换成<code>sum[x] &lt;= sum[j]-target</code>，找sum[x]呢？因为是upper bound（第一个&gt;某值的元素）的前一个（必定&lt;=某值），不如直接找lower bound简洁，而且不用处理减出负数的情况。</p>
<h3 id="Longest-Substring-with-K-Distinct-Characters-medium-google-–-LintCode"><a href="#Longest-Substring-with-K-Distinct-Characters-medium-google-–-LintCode" class="headerlink" title="Longest Substring with K Distinct Characters (medium, google) – LintCode"></a><a target="_blank" rel="noopener" href="https://www.lintcode.com/problem/longest-substring-with-at-most-k-distinct-characters/description">Longest Substring with K Distinct Characters (medium, google) – LintCode</a></h3><p>Given a string, find the length of the longest substring in it with no more than K distinct characters.</p>
<p>也就是LeetCode340题 Longest Substring at Most K Distinct Characters。</p>
<p>这道题输出是最长子串的长度，所以显然可以套用滑动窗口的模板。和上一个题目一样，都是扩展会使得条件不符，要通过收缩来满足条件。<br>即，窗口扩展一旦字符种类超过k，就可以通过窗口收缩来削减字符种类。<br>唯一不同的点是：update longest string的时机（其实就是用end-start+1来尝试更新记录的longest）<br>因为while distinct_count(dict) &gt; k时是去收缩，break while时说明distinct_count(dict) 已经&lt;=k了，这个时候的[start, end]才是一个可能解，符合条件的可能解。<br>所以update longest string len是在while循环外，而且是之后。<br>至于如何实现dict和distinct_count，随便吧，简单也好，高效也好。</p>
<p>P.S.注意到了吗，这个题目和前面一题Smallest Subarray的区别？</p>
<p>看不出来也正常，我做了几道题才突然回头发现的😂而且明明之前做过笔记，重蹈覆撤🙄️</p>
<p><del>果然人类的本质都是复读机</del></p>
<p>这个题已经开始了longest之路，也就是说，只是想求一个最长的长度，根本不在意“重复无意义的更新”。</p>
<p>按之前的模板，此题的伪代码应写为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">while end &lt; n:</span><br><span class="line">    dic[s[end]]+=1</span><br><span class="line">    while len(dic)&gt;k:</span><br><span class="line">        dic[s[start]]-=1</span><br><span class="line">        if dic[s[start]]==0:</span><br><span class="line">            del dic[s[start]]</span><br><span class="line">        start+=1</span><br><span class="line">    longest = max(longest, end-start+1)</span><br><span class="line">    end+=1</span><br></pre></td></tr></table></figure>

<p>这样的写法，保证了longest变量更新时，当前窗口都是len(dic)&lt;=k的，也就是合法的情况。但确实可能会出现窗口被收缩的很小的时候（为了合法），此时max更新也是白干的（longest还是原值）。</p>
<p>而如果代码将内层while变为if：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">while end &lt; n:</span><br><span class="line">    dic[s[end]]+=1</span><br><span class="line">    if len(dic)&gt;k:</span><br><span class="line">        dic[s[start]]-=1</span><br><span class="line">        if dic[s[start]]==0:</span><br><span class="line">            del dic[s[start]]</span><br><span class="line">        start+=1</span><br><span class="line">    longest = max(longest, end-start+1)</span><br><span class="line">    end+=1</span><br></pre></td></tr></table></figure>

<p>自然，在longest更新时，当前窗口可能都还满足条件，不合法，但仍旧去做了一次longest的更新。但从数值上来讲，由于不满足条件会被收缩一次，加上前面的end扩展一次，窗口等于做了一次平移。那么end=start+1的值就不会变大，longest的更新自然也是不会有实际作用的。</p>
<p>这一个改动，它到底好在了哪里呢？光看经过，start，end两个游标都是单向前进的，2-while和while-if都不会使两个游标左右飘。但由于2-while会保证每次窗口都是合法的，和while-if相比，start这个游标可能会更靠右。举个极端例子，如果longest是[0, n-2]这个窗口，下一次扩展end就会到末尾n-1，while-if此时发现窗口不合法，收缩一次，就溜了。而2-while，会愣是要求[start, n-1]窗口合法，可能start从0不断右移，直到n-1才停止。无用操作在这个例子就占了一半。具体例子就是AAAAB, k =1。</p>
<p>这个优化并不容易读，我也不建议平时代码搞这么tricky。在这个题目里，仅仅在节省len查询和dict更新，都是较高效的操作，而且有次数上限（由于start标最多都走到末尾，操作次数最多n次）。优化效果仅仅锦上添花。但这个将while改为if，在其他题目中可能有奇效。因为while的判断条件如果复杂度较高，这里的收益就很大了，见Longest Substring with Same Letters after Replacement一题。</p>
<h3 id="Fruits-into-Baskets-medium-–-LeetCode"><a href="#Fruits-into-Baskets-medium-–-LeetCode" class="headerlink" title="Fruits into Baskets (medium) – LeetCode"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/fruit-into-baskets/">Fruits into Baskets (medium) – LeetCode</a></h3><p>跟上题一模一样。题目暗示着连续区间，就可以尝试滑动窗口方法。</p>
<p>但这一题case比上一题的规模大，最简单的dict实现（不及时删除value为0的项，每次都要遍历得到distinct count）这种方法就超时了。还是推荐及时删除value为0的项，其实比不删还简单，因为删除这个操作只会在收缩时出现（只有此处count–）。</p>
<p>可优化为while-if。</p>
<h3 id="No-repeat-Substring-medium-–-LeetCode"><a href="#No-repeat-Substring-medium-–-LeetCode" class="headerlink" title="No-repeat Substring (medium) – LeetCode"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/longest-substring-without-repeating-characters/">No-repeat Substring (medium) – LeetCode</a></h3><p>和前面的题目毫无差别。</p>
<p>但注意第二层while的判断条件是什么，如果判断条件是“窗口dict的value全为1”，那么你可以改出while-if。</p>
<p>如果是“当前字符c的count&gt;1”，就改不了了。因为现在只看当前字符，那就意味着窗口必须是合法的，然后扩展，加入当前字符。while-if便不可用。</p>
<p>“只看当前字符”这种方法的优化思路是，如果start要跳，直接让start去“当前字符上一次出现的位置的右边”。 因为前面的字符都可以跳过了。还可以再化简代码，但会很难读，所以还是适合而止吧。</p>
<h3 id="Longest-Substring-with-Same-Letters-after-Replacement-medium-amazon-–-GeeksforGeeks"><a href="#Longest-Substring-with-Same-Letters-after-Replacement-medium-amazon-–-GeeksforGeeks" class="headerlink" title="Longest Substring with Same Letters after Replacement (medium, amazon) – GeeksforGeeks"></a><a target="_blank" rel="noopener" href="https://practice.geeksforgeeks.org/problems/maximum-sub-string-after-at-most-k-changes/0">Longest Substring with Same Letters after Replacement (medium, amazon) – GeeksforGeeks</a></h3><p>We have a string <strong>s</strong> of length n, which consist only UPPERCASE characters and we have a number k (always less than n and greater than 0). We can make at most k changes in our string such that we can get a sub-string of maximum length which have all same characters.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;ABAB&quot;, k = 2</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: Change 2 &#x27;B&#x27; into &#x27;A&#x27;.</span><br></pre></td></tr></table></figure>

<p><strong>Example:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;ABCD&quot;, k = 1</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: Change one &#x27;B&#x27; into &#x27;A&#x27;.</span><br></pre></td></tr></table></figure>

<p>这种要替换字符的题目，往往不用真的替换，只要数值上达到某个条件就行了。比如这个题，不用想着应该替换哪些字符，而应该想“总字符个数 - 不需要被替换的字符个数 &gt;= k”就行了。很容易想到，“不需要被替换的字符个数”就是区间内个数最多的那个字符，这样，总字符数才能多一点（对某个区间而言，不需要理会那些无意义的可能解，“保留频率最高的字符，把其他的替换为该字符”肯定是操作数最少的）。于是，替不替换的问题就化简为简单的统计问题。</p>
<p>统计问题虽然简单，但是复杂度略高。想要快速，可能需要两个map，ch-&gt;count, count-&gt;ch。所以，while-if就很适合了，由于只收缩一次，max_count就从dict里统计一次就好了，不用强求更快速。</p>
<h3 id="Longest-Subarray-with-Ones-after-Replacement-medium-–-GeeksforGeeks"><a href="#Longest-Subarray-with-Ones-after-Replacement-medium-–-GeeksforGeeks" class="headerlink" title="Longest Subarray with Ones after Replacement (medium) – GeeksforGeeks"></a><a target="_blank" rel="noopener" href="https://www.geeksforgeeks.org/longest-subsegment-1s-formed-changing-k-0s/">Longest Subarray with Ones after Replacement (medium) – GeeksforGeeks</a></h3><p>比上题更简单，只需要一个int变量就能描述一个窗口内的0的个数。</p>
<h3 id="Problem-Challenge-1-Permutation-in-a-String-hard"><a href="#Problem-Challenge-1-Permutation-in-a-String-hard" class="headerlink" title="Problem Challenge 1 - Permutation in a String (hard)"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/permutation-in-string/">Problem Challenge 1 - Permutation in a String (hard)</a></h3><p>排列，不允许多一个字符，所以窗口大小是固定的，滑动用来节省“更新窗口属性的代价”。题目如果对字符多加限制，比如此题限制只有小写字母，也就只有26个可能，其实描述窗口用长26的数组都可以，不用非要用counter。用counter有个麻烦点在于当某个字符的count为0时，你需要删掉它，不然就没法和s1的counter比大小。如果两个字符串的counter都先把26个字母的空间开出来，那还不如数组节省空间。</p>
<h3 id="Problem-Challenge-2-String-Anagrams-hard"><a href="#Problem-Challenge-2-String-Anagrams-hard" class="headerlink" title="Problem Challenge 2 - String Anagrams (hard)"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/submissions/">Problem Challenge 2 - String Anagrams (hard)</a></h3><p>和challenge1没有区别</p>
<h3 id="Problem-Challenge-3-Smallest-Window-containing-Substring-hard"><a href="#Problem-Challenge-3-Smallest-Window-containing-Substring-hard" class="headerlink" title="Problem Challenge 3 - Smallest Window containing Substring (hard) *"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-window-substring/">Problem Challenge 3 - Smallest Window containing Substring (hard) *</a></h3><p>没啥特别，就是用collections.Counter()减法，比自己写的比较函数要慢不少，1200ms vs 500ms。</p>
<h3 id="Problem-Challenge-4-Words-Concatenation-hard"><a href="#Problem-Challenge-4-Words-Concatenation-hard" class="headerlink" title="Problem Challenge 4 - Words Concatenation (hard)"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/substring-with-concatenation-of-all-words/">Problem Challenge 4 - Words Concatenation (hard)</a></h3><p>注意读题！words长度相同！匆忙读题后，我还以为要处理不同的切割方式，以为会出现“一个substring里有几种正确的word排列”。那这题可能不止hard了。</p>
<p>可以简单想到的办法就是窗口从0一直滑到尾，step为1，每一次窗口都得重新计算下word-count，然后和words参数比较。</p>
<p>显然这个没有什么巧妙点，没有节约计算量，所以想要利用滑动窗口，当然得想点骚方法。其实就是，每一次都设置一个起点，从这个起点开始，只会按词长来拓展，这样就能像字符型的题目一样，充分利用滑动窗口的扩展收缩，减少计算。举例说明，就是一个单词长度为len，s串总长为n的话，第一趟是从0开始一个len切一刀，这样切割后的串扩展和收缩都是一个词的，第二趟就是从1开始切，以此类推，最后一次是len-1开始切。可以想到，这样也是把所有可能性都考虑到了。</p>
<p>改进后的滑动窗口方法效果是明显的，1000ms到100ms。</p>
<h3 id="Additional"><a href="#Additional" class="headerlink" title="Additional"></a>Additional</h3><h4 id="Sliding-Window-Maximum-hard-–-LeetCode"><a href="#Sliding-Window-Maximum-hard-–-LeetCode" class="headerlink" title="Sliding Window Maximum (hard) – LeetCode"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/sliding-window-maximum/">Sliding Window Maximum (hard) – LeetCode</a></h4><p>这个题跟滑动窗口模板毫无关系，窗口大小都固定牢了。唯一的问题点在于用什么结构体来提炼窗口信息，既能很快查到最大值，又能在窗口滑动时很快更新好（滑动本质就是加入一个数，去掉一个数）。快速查到最大值，可以想到利用堆。但是堆有一个明显问题，就是它不适合去删除内部的某个元素（不是堆首）。而“去掉一个数”这个操作很可能就是去删除某个中间的值。堆的删除操作是个不太ok的操作，因为这个堆是简单的堆（并非压平了看，完全有序的，不是堆排序之后的结果），也就是删除操作不能快速定位到要删除的元素。</p>
<p>但是别直接放弃堆（我就放弃了，想别的方法，走远了）。这时候，尝试多推导一下，就会发现，不用着急删除元素。因为元素可以跟上自己的位置idx，如果堆顶拿到的idx已经不在窗口内，再删除也不迟。也就是延迟了删除操作，正好还让删除操作符合堆的操作习惯，只删堆顶。</p>
<p>到这里，起码算是题目做出来了，而且这个方法也不差，能交差。</p>
<p>但这道题更想考的点是别的，所以还需要再优化。说是优化，不如说是换了解法。从堆想到单调队列，反正我是做不到。。。</p>
<p>单调队列是什么东西？先记住它能够动态地维护定长序列中的最值。所以只要定长、最值，就可以想到尝试单调队列。具体来讲，单调队列是，push元素前会把前面的元素都从后往前访问一遍（遇到比自己大的停止），比当前元素小的都删除，再将元素放在队尾。其实，全访问也没关系，最后结果没有差别，不过，遇到比自己大的就停止可以节省点时间。最后的结果就是队列里头到尾是从大到小有序的。</p>
<p>举例说明(为了多点情况，和leetcode原例子有差别)：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nums = [1,3,-1,-3,-2,3,6,7], k = 3</span><br></pre></td></tr></table></figure>

<p>单调队列应该长什么样？</p>
<p>[1,3,-1]初始窗口入队列后，q=[3,-1]，那么这个窗口的最值就是3；</p>
<p>[3,-1,-3], q=[3,-1,-3]，最值还是3；</p>
<p>[-1,-3,-2], q=[3,-1,-2]，最值3，但3已经不在窗口内，所以pop，q=[-1,-2]，最值-1；</p>
<p>[-3,-2,3], q=[3]，最值3；</p>
<p>[5,3,6], q=[6]，最值6；</p>
<p>[3,6,7], q=[7]，最值7。</p>
<p>可以看到，只用进行简单比较，就能维持着最值，比堆的时间复杂度低。</p>
<p>单调队列它为什么做到了呢？</p>
<p>可以这么想，首先简单起见，只考虑窗口内元素的单调队列情况，比如3,1,2序列，k=3，很明显1会在2进入时被扔掉，因为2进入了之后，怎么也是2比1晚出窗口，就算可能是最大值，也是2可能，1是完全没有可能竞争最大值的。</p>
<p>再考虑队列前部还有窗口外元素的情况，窗口外的元素还留在队列里（可以称为过期元素），也就是说窗口内的单调队列最大值（也就是队列列首）比过期元素小。但这并不影响窗口元素那部分的选择，无论有没有过期元素，窗口那部分的单调队列都长一个样。所以过期元素可以简单地pop出来扔掉。</p>
<p>总的来说，单调队列就是剔除了“必然不能争最大值”的那部分无用值。单调队列实现上没有什么难度，不再赘述。</p>
<p>P.S. Python实现遇到超时问题，因为我没有用pop，而是选择到一个点，取出切片[:x]，然后又append。具体细节待调查。从耗时来看，很明显这一连串操作应该搞出了deep copy之类的耗时操作。都叫单调队列了，就好好用python collections里的deque。</p>
<h4 id="Shortest-Subarray-with-Sum-at-Least-K-hard-–-LeetCode"><a href="#Shortest-Subarray-with-Sum-at-Least-K-hard-–-LeetCode" class="headerlink" title="Shortest Subarray with Sum at Least K (hard) – LeetCode"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/shortest-subarray-with-sum-at-least-k/">Shortest Subarray with Sum at Least K (hard) – LeetCode</a></h4><p>仔细读题，这个题的数组里有负数。滑动窗口的算法模板是没办法直接套用的，因为窗口收缩的停止条件是sum &lt; k，由于有负数，你不能在窗口sum &lt; k时停止，你必须继续收缩，否则就可能错过解。</p>
<p>停留在滑动窗口算法模板这个框架里，是没办法找到解法的。</p>
<p>这时候<del>只能躺平</del>。</p>
<p>只能说先回答个O(n^2)的解法吧，聊胜于无。很明显，所有区间和都是可能的最佳答案，所以前缀和加<strong>二级遍历</strong>所有区间，能得到答案。</p>
<p>当然可以优化，但是很难凭空想出来参考答案“单调队列”。接下来的说明是以知道“前缀和+单调队列是较好解法”为前提来看这个题目，所以没有什么顺理成章推导，全凭参考答案提示。</p>
<p>单调队列维护什么？</p>
<p>题目核心是求最短的合法子串，所以短是最核心的，和只要&gt;=k什么都行。那么假设当前看i，以i开头的最佳子串，当然是从i开始寻找第一个j，能使sum[i..j]&gt;k（前缀和数组里两个数减一下就好了）。j之后的都不用找了，没有比i到j更短的了。那么反过来思考，从i到j，中间可能有多个值，一一遍历就是暴力解法，优化当然是更快找到j，那么如何迅速定位到j呢？</p>
<p>或者换个说法，i到j中间的多个可能性，有哪些是必然不可能的，可以直接过滤？答案是没得😛。因为如果从[i, n)区间提取出单调递增的部分，可以使用二分，但这个题应该用不着。那这个思路还有什么优势呢？我们一一遍历到j，然后得到这个i的最优解，然后i++，然后你还是得遍历过去，因为单调递增队列本身不能有更多的改动，最多把队列头比i小的pop出来。那换个角度，递增队列是不是能从后往前看，当某个靠后的j满足了条件，你能把它怎么样？你不能动它，因为接下来的i（更大的i）和j一起也能满足条件，这个窗口长度肯定比现在的短，你删了这个j，就丢掉了解。</p>
<p>那么就应该考虑换个顺序，以当前j为标杆，去找前面的i，它有个什么好处呢？当你从前往后找i，某个i满足条件后，你可以大胆删了它，因为j会++，当前的i充分发挥价值（用来更新window len）后，就不需要了，后面的j和这个i组合是无意义的。</p>
<p>P.S. 我想到了以j找i，但又想的是从j-1往0这个方向找，想想看，跟以i找j没什么差别，它们跟暴力解法比，完全不是稳定降低复杂度，甚至可以劣到没区别。（于是Python实现也完美超时了）</p>
<p>总的看“前缀和+单调队列”，大概的最好状态是每次O(1)，然后n个j，所以O(n)，比如，每次看队列头d[0]的preSum都很大，不能让preSum[j]-preSum[d[0]]&gt;=k，单调递增的d后面的元素也不能满足要求了，所以每次就立马完成。最差的状态可能是某次j，从0到j遍历，每次都符合条件，都要pop并更新window len。但很明显，队列最多跟n一样长，而且pop出去了又不会回来，所以次数最多n次，并不会膨胀。所以总的复杂度还是O(n)的。</p>
<p>这道题还是很难的，难在拼出正确的方法，知道方法后，代码实现不难。</p>
<h4 id="Max-Consecutive-Ones-III"><a href="#Max-Consecutive-Ones-III" class="headerlink" title="Max Consecutive Ones III"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/max-consecutive-ones-iii/">Max Consecutive Ones III</a></h4><p>突如其来的一道复习题。while-if即可，虽然和while-while实测没什么区别，大概是case的原因。</p>
<h4 id="Replace-the-Substring-for-Balanced-String-medium-–-LeetCode"><a href="#Replace-the-Substring-for-Balanced-String-medium-–-LeetCode" class="headerlink" title="Replace the Substring for Balanced String (medium) – LeetCode"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/replace-the-substring-for-balanced-string/">Replace the Substring for Balanced String (medium) – LeetCode</a></h4><p>题目是说要替换的字符包含在一个子串里，要求子串最短，子串符合某个条件即可，那就很适合套用滑动窗口模板了。</p>
<h4 id="Count-Number-of-Nice-Subarrays-medium-–-LeetCode"><a href="#Count-Number-of-Nice-Subarrays-medium-–-LeetCode" class="headerlink" title="Count Number of Nice Subarrays (medium) – LeetCode"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/count-number-of-nice-subarrays/">Count Number of Nice Subarrays (medium) – LeetCode</a></h4><p>这题一看就不适合立马套用模板，扩展和收缩求最长最短很有效，但这里没有用处。举例说明，当我们找到一个窗口恰好有k个奇数，此时可以滑动窗口么？当然不能。所以放弃吧。然后考虑到奇数是核心，先找到k个奇数的最小可能，它的左右两边如果分别有a个偶数和b个偶数，那么这里就有很多个子串可能，1+a+b+a*b。而找奇数，可以直接抽出奇数，这样奇数数组里每k个就是一个base，延展下两边的偶数。既没有重复也不会漏算。</p>
<p>滑动窗口完结撒花🎉</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Huang Wei</p>
  <div class="site-description" itemprop="description">Hey</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">16</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Huang Wei</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
